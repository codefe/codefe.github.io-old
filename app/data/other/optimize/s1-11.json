{"sta":1,"data":{"subTitle":"常规优化","content":"<ul><li><p>传递方法取代方法字符串</p><p>一些方法例如<code>setTimeout()</code>、<code>setInterval()</code>，接受<code>字符串</code>或者<code>方法实例</code>作为参数。直接传递方法对象作为参数来避免对字符串的二次解析。</p><ul><li><p>传递方法</p><pre><code><span>set</span>Timeout(<span>test</span>, 1);\n</code></pre></li><li><p>传递方法字符串</p><pre><code>setTimeout('test()', <span>1</span>)<span>;</span>\n</code></pre></li></ul></li><li><p>使用原始操作代替方法调用</p><p>方法调用一般封装了原始操作，在性能要求高的逻辑中，可以使用原始操作代替方法调用来提高性能。</p><ul><li><p>原始操作</p><pre><code><span>var min</span> = a&lt;b?a:b;\n</code></pre></li><li><p>方法实例</p><pre><code><span>var</span> <span>min</span> = Math.<span>min</span>(a, b);\n</code></pre></li></ul></li><li><p>定时器</p><p>如果针对的是不断运行的代码，不应该使用<code>setTimeout</code>，而应该是用<code>setInterval</code>。<code>setTimeout</code>每次要重新设置一个定时器。</p></li><li><p>避免双重解释</p><p>当<code>JAVASCRIPT</code>代码想解析<code>JAVASCRIPT</code>代码时就会存在双重解释惩罚，双重解释一般在使用<code>eval</code>函数、<code>new Function</code>构造函数和<code>setTimeout</code>传一个字符串时等情况下会遇到，如。</p><pre><code><span>eval</span>(<span>\"alert('hello world');\"</span>);\n<span>var</span> sayHi = <span>new</span> <span><span>Function</span><span>(<span>\"alert('hello world');\"</span>)</span></span>;\nsetTimeout(<span>\"alert('hello world');\"</span>, <span>100</span>);\n</code></pre><p>上述<code>alert('hello world');</code>语句包含在字符串中，即在JS代码运行的同时必须新启运一个解析器来解析新的代码，而实例化一个新的解析器有很大的性能损耗。 我们看看下面的例子：</p><pre><code><span>var</span> sum, num1 = <span>1</span>, num2 = <span>2</span>;\n<span>/**效率低**/</span>\n<span>for</span>(<span>var</span> i = <span>0</span>; i &lt; <span>10000</span>; i++){\n    <span>var</span> <span><span>func</span> = <span>new</span> <span>Function</span><span>(<span>\"sum+=num1;num1+=num2;num2++;\"</span>)</span></span>;\n    <span><span>func</span><span>()</span></span>;\n    <span>//eval(\"sum+=num1;num1+=num2;num2++;\");</span>\n}\n<span>/**效率高**/</span>\n<span>for</span>(<span>var</span> i = <span>0</span>; i &lt; <span>10000</span>; i++){\n    sum+=num1;\n    num1+=num2;\n    num2++;\n}\n</code></pre><p>第一种情况我们是使用了new Function来进行双重解释，而第二种是避免了双重解释。</p></li><li><p>原生方法更快</p><ul><li>只要有可能，使用原生方法而不是自已用JS重写。原生方法是用诸如C/C++之类的编译型语言写出来的，要比JS的快多了。</li></ul></li><li><p>最小化语句数</p><p>JS代码中的语句数量也会影响所执行的操作的速度，完成多个操作的单个语句要比完成单个操作的多个语句块快。故要找出可以组合在一起的语句，以减来整体的执行时间。这里列举几种模式</p><ul><li><p>多个变量声明</p><pre><code><span><span>/<span>**不提倡**</span>/</span></span>\n<span>var</span> i = <span>1</span>;\n<span>var</span> j = <span>\"hello\"</span>;\n<span>var</span> arr = [<span>1</span>,<span>2</span>,<span>3</span>];\n<span>var</span> now = <span>new</span> Date();\n<span><span>/<span>**提倡**</span>/</span></span>\n<span>var</span> i = <span>1</span>,\n    j = <span>\"hello\"</span>,\n    arr = [<span>1</span>,<span>2</span>,<span>3</span>],\n    now = <span>new</span> Date();\n</code></pre></li><li><p>插入迭代值</p><pre><code><span><span>/<span>**不提倡**</span>/</span></span>\n<span>var</span> name = values[i];\ni++;\n<span><span>/<span>**提倡**</span>/</span></span>\n<span>var</span> name = values[i++];\n</code></pre></li><li><p>使用数组和对象字面量，避免使用构造函数Array(),Object()</p><pre><code><span>/**不提倡**/</span>\nvar a = new Array()<span>;</span>\na[<span>0</span>] = <span>1</span><span>;</span>\na[<span>1</span>] = <span>\"hello\"</span><span>;</span>\na[<span>2</span>] = <span>45</span><span>;</span>\nvar o = new Obejct()<span>;</span>\no.name = <span>\"bill\"</span><span>;</span>\no.age = <span>13</span><span>;</span>\n<span>/**提倡**/</span>\nvar a = [<span>1</span>, <span>\"hello\"</span>, <span>45</span>]<span>;</span>\nvar o = {\n    name : <span>\"bill\"</span>,\n    age : <span>13</span>\n}<span>;</span>\n</code></pre></li></ul></li><li><p>避免使用属性访问方法</p><ul><li><p>JavaScript不需要属性访问方法，因为所有的属性都是外部可见的。</p></li><li><p>添加属性访问方法只是增加了一层重定向 ，对于访问控制没有意义。</p><p>使用属性访问方法示例</p><pre><code><span><span>function</span> <span>Car</span><span>()</span> </span>{\n   <span>this</span> .m_tireSize = <span>17</span>;\n   <span>this</span> .m_maxSpeed = <span>250</span>;\n   <span>this</span> .GetTireSize = Car_get_tireSize;\n   <span>this</span> .SetTireSize = Car_put_tireSize;\n}\n\n<span><span>function</span> <span>Car_get_tireSize</span><span>()</span> </span>{\n   <span>return</span> <span>this</span> .m_tireSize;\n}\n\n<span><span>function</span> <span>Car_put_tireSize</span><span>(value)</span> </span>{\n   <span>this</span> .m_tireSize = value;\n}\n<span>var</span> ooCar = <span>new</span> Car();\n<span>var</span> iTireSize = ooCar.GetTireSize();\nooCar.SetTireSize(iTireSize + <span>1</span>);\n</code></pre><p>直接访问属性示例</p><pre><code><span><span>function</span> <span>Car</span><span>()</span> </span>{\n   <span>this</span> .m_tireSize = <span>17</span>;\n   <span>this</span> .m_maxSpeed = <span>250</span>;\n}\n<span>var</span> perfCar = <span>new</span> Car();\n<span>var</span> iTireSize = perfCar.m_tireSize;\nperfCar.m_tireSize = iTireSize + <span>1</span>;\n</code></pre></li></ul></li><li><p>减少使用元素位置操作</p><ul><li><p>一般浏览器都会使用增量reflow的方式将需要reflow的操作积累到一定程度然后再一起触发，但是如果脚本中要获取以下属性，那么积累的reflow将会马上执行，已得到准确的位置信息。</p><pre><code>offsetLeft\noffsetTop\noffsetHeight\noffsetWidth\nscrollTop/Left/Width/Height\nclientTop/Left/Width/Height\n<span><span>getComputedStyle</span><span>()</span></span></code></pre></li></ul></li></ul>"}}
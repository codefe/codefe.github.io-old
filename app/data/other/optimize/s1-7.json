{"sta":1,"data":{"subTitle":"JIT与GC优化","content":"<ul><li><p><code>untyped</code>（无类型）。</p><ul><li><p><code>JAVASCRIPT</code>是个无类型的语言，这导致了如<code>x=y+ｚ</code>这种表达式可以有很多含义。</p><ul><li><code>y</code>，<code>z</code>是数字，则<code>+</code>表示加法。</li><li><code>y</code>，<code>z</code>是字符串，则<code>+</code>表示字符串连接。</li></ul><p>而JS引擎内部则使用“<code>细粒度</code>”的类型，比如：</p><ul><li>32-bit* integer。</li><li>64-bit* floating-point。</li></ul><p>这就要求js类型-js引擎类型，需要做“boxed/unboxed（装箱/解箱）”，在处理一次<code>x=y+z</code>这种计算，需要经过的步骤如下。</p><ol><li>从内存，读取<code>x=y+z</code>的操作符。</li><li>从内存，读取<code>y</code>，<code>z</code>。</li><li>检查y，z类型，确定操作的行为。</li><li><code>unbox y，z</code>。</li><li>执行操作符的行为。</li><li><code>box x</code>。</li><li>把<code>x</code>写入内存。</li></ol><p>只有第<code>5</code>步骤是真正有效的操作，其他步骤都是为第<code>5</code>步骤做准备/收尾，<code>JAVASCRIPT</code>的<code>untyped</code>特性很好用，但也为此付出了很大的性能代价。</p></li></ul></li><li><p><code>JIT</code>。</p><ul><li><p>先看看<code>JIT</code>对<code>untyped</code>的优化，在<code>JIT</code>下，执行<code>x=y+z</code>流程。</p><ol><li>从内存，读取<code>x=y+z</code>的操作符。</li><li>从内存，读取&nbsp;<code>y</code>，<code>z</code>。</li><li>检查<code>y</code>，<code>z</code>类型，确定操作的行为。</li><li><code>unbox y，z</code>。</li><li>执行 操作符 的行为。</li><li><code>box x</code>。</li><li>把<code>x</code>写入内存。</li></ol><p>其中<code>1</code>，<code>2</code>步骤由<code>CPU</code>负责，<code>7</code>步骤<code>JIT</code>把结果保存在寄存器里。但可惜不是所有情况都能使用JIT，当<code>number+number</code>，<code>string+string</code>&nbsp;等等可以使用<code>JIT</code>，但特殊情况，如：<code>number+undefined</code>就不行了，只能走旧解析器。</p></li><li><p>新引擎还对“对象属性”访问做了优化，解决方案叫<code>inline caching</code>，简称：<code>IC</code>。简单的说，就是做<code>cache</code>。但如果当<code>list</code>很大时，这种方案反而影响效率。</p></li></ul></li><li><p><code>Type-specializing JIT</code></p><blockquote><p><code>Type-specializing JIT</code>引擎用来处理<code>typed</code>类型（声明类型）变量，但<code>JAVASCRIPT</code>都是<code>untype</code>类型的。</p></blockquote><ul><li><p><code>Type-specializing JIT</code>的解决方案是：</p><ul><li>先通过扫描，监测类型。</li><li>通过编译优化（优化对象不仅仅只是“类型”，还包括对JS代码的优化，但核心是类型优化），生成类型变量。</li><li>再做后续计算。</li></ul></li><li><p><code>Type-specializing JIT</code>的执行<code>x=y+z</code>流程：</p><ul><li>从内存，读取<code>x=y+z</code>的操作符。</li><li>从内存，读取<code>y</code>，<code>z</code>。</li><li>检查<code>y</code>，<code>z</code>类型，确定操作的行为。</li><li><code>unbox y，z</code>。</li><li>执行操作符的行为。</li><li><code>box x</code>。</li><li>把<code>x</code>写入内存。</li></ul><p>代价是：</p><ul><li>前置的扫描类型</li><li>编译优化。</li></ul><p>所以·Type-specializing JIT·的应用是有选择性，选择使用这个引擎的场景包括：</p><ul><li>热点代码。</li><li>通过启发式算法估算出来的有价值的代码。</li></ul><p>另外，有2点也需要注意：</p><ul><li>当变量类型 发生变化时，引擎有2种处理方式：<ul><li>少量变更，重编译，再执行。</li><li>大量变更，交给JIT执行。</li></ul></li><li><code>数组</code>，<code>object properties</code>， 闭包变量 不在优化范畴之列。</li></ul></li></ul></li></ul>"}}
{"sta":1,"data":{"subTitle":"代码优化","content":"<p>优化原则：</p><blockquote><p>JS与其他语言不同在于它的执行效率很大程度是取决于<code>JS engine</code>的效率。除了<code>引擎实现</code>的优劣外，<code>引擎</code>自己也会为一些特殊的<code>代码模式</code>采取一些优化的策略。例如<code>FF</code>、<code>Opera</code>和<code>Safari</code>的<code>JAVASCRIPT</code>引擎，都对字符串的拼接运算（<code>+</code>）做了特别优化。所以应该根据不同引擎进行不同优化。</p><p>而如果做跨浏览器的web编程，则最大的问题是在于IE6（JScript 5.6），因为在不打hotfix的情况下，JScript引擎的垃圾回收的bug，会导致其在真实应用中的performance跟其他浏览器根本不在一个数量级上。因此在这种场合做优化，实际上就是为JScript做优化，所以第一原则就是只需要为IE6（未打补丁的JScript 5.6或更早版本）做优化。</p></blockquote><p><!--StartFragment--><!--EndFragment--></p><ul><li><p>JS优化总是出现在大规模循环的地方：</p><p>这倒不是说循环本身有性能问题，而是循环会迅速放大可能存在的性能问题，所以第二原则就是以大规模循环体为最主要优化对象。</p><p>以下的优化原则，只在大规模循环中才有意义，在循环体之外做此类优化基本上是没有意义的。</p><p>目前绝大多数JS引擎都是解释执行的，而解释执行的情况下，在所有操作中，函数调用的效率是较低的。此外，过深的prototype继承链或者多级引用也会降低效率。JScript中，10级引用的开销大体是一次空函数调用开销的1/2。这两者的开销都远远大于简单操作（如四则运算）。</p></li><li><p>尽量避免过多的引用层级和不必要的多次方法调用：</p><p>特别要注意的是，有些情况下看似是属性访问，实际上是方法调用。例如所有DOM的属性，实际上都是方法。在遍历一个NodeList的时候，循环 条件对于nodes.length的访问，看似属性读取，实际上是等价于函数调用的。而且IE DOM的实现上，childNodes.length每次是要通过内部遍历重新计数的。（My god，但是这是真的！因为我测过，childNodes.length的访问时间与childNodes.length的值成正比！）这非常耗费。所以 预先把nodes.length保存到js变量，当然可以提高遍历的性能。</p><p>同样是函数调用，用户自定义函数的效率又远远低于语言内建函数，因为后者是对引擎本地方法的包装，而引擎通常是c,c++,java写的。进一步，同样的功能，语言内建构造的开销通常又比内建函数调用要效率高，因为前者在JS代码的parse阶段就可以确定和优化。</p></li><li><p>尽量使用语言本身的构造和内建函数：</p><p>这里有一个例子是高性能的String.format方法。 String.format传统的实现方式是用String.replace(regex, func)，在pattern包含n个占位符（包括重复的）时，自定义函数func就被调用n次。而这个高性能实现中，每次format调用所作的只是一次Array.join然后一次String.replace(regex, string)的操作，两者都是引擎内建方法，而不会有任何自定义函数调用。两次内建方法调用和n次的自定义方法调用，这就是性能上的差别。</p><p>同样是内建特性，性能上也还是有差别的。例如在JScript中对于arguments的访问性能就很差，几乎赶上一次函数调用了。因此如果一个 可变参数的简单函数成为性能瓶颈的时候，可以将其内部做一些改变，不要访问arguments，而是通过对参数的显式判断来处理，比如：</p></li><li><p>\n<br><blockquote>function sum() {<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;var r = 0;<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; arguments.length; i++) {<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r += arguments[i];<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;return r;<br>  \n}\n</blockquote>这个sum通常调用的时候个数是较少的，我们希望改进它在参数较少时的性能。如果改成：\n<br>\n<br><blockquote>function sum() {<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;switch (arguments.length) {<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: return arguments[0];<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: return arguments[0] + arguments[1];<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: return arguments[0] + arguments[1] + arguments[2];<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: return arguments[0] + arguments[1] + arguments[2] + arguments[3];<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br>  \n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var r = 0;<br>  \n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; arguments.length; i++) {<br>  \n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r += arguments[i];<br>  \n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>  \n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return r;<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>  \n}\n</blockquote>其实并不会有多少提高，但是如果改成：\n<br>\n<br><blockquote>function sum(a, b, c, d, e, f, g) {<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;var r = a ? b ? c ? d ? e ? f ? a + b + c + d + e + f : a + b + c + d + e : a + b + c + d : a + b + c : a + b : a : 0;<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;if (g === undefined) return r;<br>  \n&nbsp; &nbsp; for (var i = 6; i &lt; arguments.length; i++) {<br>  \n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r += arguments[i];<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>  \n    &nbsp;&nbsp;&nbsp;&nbsp;return r;<br>  \n}\n</blockquote>就会提高很多（至少快1倍）。</p></li></ul>"}}
{"sta":1,"data":{"subTitle":"内存专题","content":"<ul><li><p><code>JAVASCRIPT</code>的内存回收机制</p><ul><li>以Google的<code>V8</code>引擎为例，在<code>V8</code>引擎中所有的<code>JAVASCRIPT</code>对象都是通过<code>堆</code>来进行内存分配的。当我们在代码中<code>声明变量</code>并<code>赋值</code>时，<code>V8</code>引擎就会在<code>堆内存</code>中分配一部分给这个<code>变量</code>。如果已申请的<code>内存</code>不足以存储这个<code>变量</code>时，<code>V8</code>引擎就会继续申请<code>内存</code>，直到<code>堆</code>的大小达到了<code>V8</code>引擎的内存上限为止（默认情况下，<code>V8</code>引擎的<code>堆内存</code>的大小上限在<code>64位系统</code>中为<code>1464MB</code>，在<code>32位系统</code>中则为<code>732MB</code>）。</li><li>另外，<code>V8</code>引擎对<code>堆内存</code>中的<code>JAVASCRIPT</code>对象进行<code>分代管理</code>。<ul><li>新生代。<ul><li>新生代即存活周期较短的<code>JAVASCRIPT</code>对象，如临时变量、字符串等</li></ul></li><li>老生代。<ul><li>老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul></li></ul></li></ul></li><li><p>垃圾回收算法。</p><ul><li>垃圾回收算法一直是编程语言的研发中是否重要的​​一环，而<code>V8</code>引擎所使用的垃圾回收算法主要有以下几种。<ul><li><code>Scavange</code>算法：通过复制的方式进行内存空间管理，主要用于新生代的内存空间；</li><li><code>Mark-Sweep</code>算法和<code>Mark-Compact</code>算法：通过标记来对堆内存进行整理和回收，主要用于老生代对象的检查和回收。</li></ul></li></ul></li><li><p>对象进行回收。</p><ul><li><p><code>引用</code>。</p><ul><li><p>当函数执行完毕时，在函数内部所声明的对象<code>不一定</code>就会被销毁。</p></li><li><p>引用(<code>Reference</code>)是<code>JAVASCRIPT</code>编程中十分重要的一个机制。</p><ul><li><p>是指<code>代码对对象的访问</code>这一抽象关系，它与<code>C/C++</code>的指针有点相似，但并非同物。引用同时也是<code>JAVASCRIPT</code>引擎在进行<code>垃圾回收</code>中最关键的一个机制。</p><pre><code><span>var</span> val = <span>'hello world'</span>;\n<span><span>function</span> <span>foo</span><span>()</span> </span>{\n  <span>return</span> <span><span>function</span><span>()</span> </span>{\n    <span>return</span> val;\n  };\n}\n<span>global</span>.bar = foo();\n</code></pre></li><li><p>当代码执行完毕时，对象<code>val</code>和<code>bar()</code>并没有被回收释放，<code>JAVASCRIPT</code>代码中，每个<code>变量</code>作为单独一行而不做任何操作，<code>JAVASCRIPT</code>引擎都会认为这是对<code>对象</code>的访问行为，存在了对<code>对象的引用</code>。为了保证<code>垃圾回收</code>的行为不影响程序逻辑的运行，<code>JAVASCRIPT</code>引擎不会把正在使用的<code>对象</code>进行回收。所以判断<code>对象</code>是否正在使用中的标准，就是是否仍然存在对该<code>对象</code>的<code>引用</code>。</p></li><li><p><code>JAVASCRIPT</code>的<code>引用</code>是可以进行<code>转移</code>的，那么就有可能出现某些引用被带到了全局作用域，但事实上在业务逻辑里已经不需要对其进行访问了，这个时候就应该被回收，但是<code>JAVASCRIPT</code>引擎仍会认为程序仍然需要它。</p></li></ul></li></ul></li></ul></li><li><p><code>IE</code>下闭包引起跨页面内存泄露。</p></li><li><p><code>JAVASCRIPT</code>的内存泄露处理</p><ul><li><p>给<code>DOM</code>对象添加的属性是一个对象的引用。</p><pre><code><span>var</span> MyObject = {};\n<span>document</span>.getElementByIdx_x(<span>'myDiv'</span>).myProp = MyObject;\n</code></pre><p>解决方法：在window.onunload事件中写上:</p><pre><code><span>document</span>.getElementByIdx_x(<span>'myDiv'</span>).myProp = <span>null</span>;\n</code></pre></li><li><p>DOM对象与JS对象相互引用。</p><pre><code><span><span>function</span> <span>Encapsulator</span>(<span>element</span>) </span>{\n   <span>this</span>.elementReference = element;\n   element.myProp = <span>this</span>;\n}\n<span>new</span> Encapsulator(<span>document</span>.getElementByIdx_x(<span>'myDiv'</span>));\n</code></pre><p>解决方法：在onunload事件中写上:</p><pre><code><span>document</span>.getElementByIdx_x(<span>'myDiv'</span>).myProp = <span>null</span>;\n</code></pre></li><li><p>给DOM对象用attachEvent绑定事件。</p><pre><code><span><span>function</span> <span>doClick</span><span>()</span> </span>{}\nelement.attachEvent(<span>\"onclick\"</span>, doClick);\n</code></pre><p>解决方法：在onunload事件中写上:</p><pre><code>element.detachEvent(<span>'onclick'</span>, <span>do</span>Click);\n</code></pre></li><li><p>从外到内执行appendChild。这时即使调用removeChild也无法释放。</p><pre><code><span>var</span> parentDiv =   <span>document</span>.createElement_x(<span>\"div\"</span>);\n<span>var</span> childDiv = <span>document</span>.createElement_x(<span>\"div\"</span>);\n<span>document</span>.body.appendChild(parentDiv);\nparentDiv.appendChild(childDiv);\n</code></pre><p>解决方法：从内到外执行appendChild:</p><pre><code><span>var</span> parentDiv =   <span>document</span>.createElement_x(<span>\"div\"</span>);\n<span>var</span> childDiv = <span>document</span>.createElement_x(<span>\"div\"</span>);\nparentDiv.appendChild(childDiv);\n<span>document</span>.body.appendChild(parentDiv);\n</code></pre></li><li><p>反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。</p><pre><code><span>for</span>(<span>i</span> = <span>0</span>; <span>i</span> &lt; <span>5000</span>; <span>i</span>++) {\n   hostElement.text = \"asdfasdfasdf\";\n}\n</code></pre><p>这种方式相当于定义了5000个属性，解决方法：无。</p></li></ul></li><li><p><code>内存</code>不是<code>缓存</code>。</p><ul><li>不要轻易将<code>内存</code>当作<code>缓存</code>使用。</li><li>如果是很重要的资源，请不要直接放在<code>内存</code>中，或者制定<code>过期机制</code>，自动销毁<code>过期缓存</code>。</li></ul></li><li><p><code>CollectGarbage</code>。</p><ul><li><code>CollectGarbage</code>是<code>IE</code>的一个特有属性,用于释放内存的使用方法,将该变量或引用对象设置为<code>null</code>或<code>delete</code>然后在进行释放动作，在做<code>CollectGarbage</code>前,要必需清楚的两个必备条件:（引用）。<ul><li>一个对象在其生存的上下文环境之外，即会失效。</li><li>一个全局的对象在没有被执用(引用)的情况下，即会失效</li></ul></li></ul></li></ul>"}}
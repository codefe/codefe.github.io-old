{"sta":1,"data":{"subTitle":"DOM优化","content":"<p><!--StartFragment--><!--EndFragment--></p><ul><li><p>优化节点修改。</p><ul><li><p>使用<code>cloneNode</code>在外部更新节点然后再通过<code>replace</code>与原始节点互换。</p><pre><code><span>var</span> orig = document.getElementById(<span>'container'</span>);\n<span>var</span> <span>clone</span> = orig.cloneNode(<span>true</span>);\n<span>var</span> <span>list</span> = [<span>'foo'</span>, <span>'bar'</span>, <span>'baz'</span>];\n<span>var</span> content;\n<span>for</span> (<span>var</span> i = <span>0</span>; i &lt; <span>list</span>.length; i++) {\n   content = document.createTextNode(<span>list</span>[i]);\n   <span>clone</span>.appendChild(content);\n}\norig.parentNode.replaceChild(<span>clone</span>, orig);\n</code></pre></li></ul></li><li><p>优化节点添加</p><blockquote><p>多个节点插入操作，即使在外面设置节点的元素和风格再插入，由于多个节点还是会引发多次reflow。</p></blockquote><ul><li><p>优化的方法是创建<code>DocumentFragment</code>，在其中插入节点后再添加到页面。</p><ul><li><p>如<code>JQuery</code>中所有的添加节点的操作如<code>append</code>，都是最终调用<code>DocumentFragment</code>来实现的，</p><pre><code>createSafeFragment(<span>document</span>) {\n     <span>var</span> <span>list</span> = nodeNames.split( <span>\"|\"</span> ),\n         safeFrag = <span>document</span>.createDocumentFragment();\n\n     <span>if</span> (safeFrag.createElement) {\n         <span>while</span> (<span>list</span>.length) {\n             safeFrag.createElement(\n                 <span>list</span>.pop();\n             );\n         };\n     };\n     <span>return</span> safeFrag;\n};\n</code></pre></li></ul></li></ul></li><li><p>优化<code>CSS</code>样式转换。</p><blockquote><p>如果需要动态更改CSS样式，尽量采用触发reflow次数较少的方式。</p></blockquote><ul><li><p>如以下代码逐条更改元素的几何属性，理论上会触发多次<code>reflow</code>。</p><pre><code><span>element</span>.style.fontWeight = <span>'bold'</span> ;\n<span>element</span>.style.marginLeft= <span>'30px'</span> ;\n<span>element</span>.style.marginRight = <span>'30px'</span> ;\n</code></pre></li><li><p>可以通过直接设置元素的<code>className</code>直接设置，只会触发一次<code>reflow</code>。</p><pre><code>element.<span>className</span> = <span>'selectedAnchor'</span> ;\n</code></pre></li></ul></li><li><p>减少<code>DOM</code>元素数量</p><ul><li><p>在<code>console</code>中执行命令查看<code>DOM</code>元素数量。</p><pre><code>`document.getElementsByTagName( <span>'*'</span> ).length`\n</code></pre></li><li><p>正常页面的<code>DOM</code>元素数量一般不应该超过<code>1000</code>。</p></li><li><p><code>DOM</code>元素过多会使<code>DOM</code>元素查询效率，样式表匹配效率降低，是页面性能最主要的瓶颈之一。</p></li></ul></li><li><p><code>DOM</code>操作优化。</p><ul><li><code>DOM</code>操作性能问题主要有以下原因。<ul><li><code>DOM</code>元素过多导致元素定位缓慢。</li><li>大量的<code>DOM</code>接口调用。<ul><li><code>JAVASCRIPT</code>和<code>DOM</code>之间的交互需要通过函数<code>API</code>接口来完成，造成延时，尤其是在循环语句中。</li></ul></li><li><code>DOM</code>操作触发频繁的<code>reflow(layout)</code>和<code>repaint</code>。</li><li><code>layout</code>发生在<code>repaint</code>之前，所以layout相对来说会造成更多性能损耗。<ul><li><code>reflow(layout)</code>就是计算页面元素的几何信息。</li><li><code>repaint</code>就是绘制页面元素。</li></ul></li><li>对<code>DOM</code>进行操作会导致浏览器执行回流<code>reflow</code>。</li></ul></li><li>解决方案。<ul><li>纯<code>JAVASCRIPT</code>执行时间是很短的。</li><li>最小化<code>DOM</code>访问次数，尽可能在js端执行。</li><li>如果需要多次访问某个<code>DOM</code>节点，请使用局部变量存储对它的引用。</li><li>谨慎处理<code>HTML</code>集合（<code>HTML</code>集合实时连系底层文档），把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中。</li><li>如果可能的话，使用速度更快的API，比如<code>querySelectorAll</code>和<code>firstElementChild</code>。</li><li>要留意重绘和重排。</li><li>批量修改样式时，<code>离线</code>操作<code>DOM</code>树。</li><li>使用缓存，并减少访问布局的次数。</li><li>动画中使用绝对定位，使用拖放代理。</li><li>使用事件委托来减少事件处理器的数量。</li></ul></li></ul></li><li><p>优化<code>DOM</code>交互 &gt;在<code>JAVASCRIPT</code>中，<code>DOM</code>操作和交互要消耗大量时间，因为它们往往需要重新渲染整个页面或者某一个部分。</p><ul><li>最小化<code>现场更新</code>。<ul><li>当需要访问的<code>DOM</code>部分已经已经被渲染为页面中的一部分，那么<code>DOM</code>操作和交互的过程就是再进行一次<code>现场更新</code>。<ul><li><code>现场更新</code>是需要针对<code>现场</code>（相关显示页面的部分结构）立即进行更新，每一个更改（不管是插入单个字符还是移除整个片段），都有一个性能损耗。</li><li>现场更新进行的越多，代码完成执行所花的时间也越长。</li></ul></li></ul></li><li>多使用<code>innerHTML</code>。<ul><li>有两种在页面上创建<code>DOM</code>节点的方法：<ul><li>使用诸如<code>createElement()</code>和<code>appendChild()</code>之类的<code>DOM</code>方法。</li><li>使用<code>innerHTML</code>。<ul><li>当使用<code>innerHTML</code>设置为某个值时，后台会创建一个<code>HTML</code>解释器，然后使用内部的<code>DOM</code>调用来创建<code>DOM</code>结构，而非基于<code>JAVASCRIPT</code>的<code>DOM</code>调用。由于内部方法是编译好的而非解释执行，故执行的更快。 &gt;对于小的<code>DOM</code>更改，两者效率差不多，但对于大的<code>DOM</code>更改，<code>innerHTML</code>要比标准的<code>DOM</code>方法创建同样的<code>DOM</code>结构快得多。</li></ul></li></ul></li></ul></li></ul></li><li><p>回流<code>reflow</code>。</p><ul><li><p>发生场景。</p><ul><li><p>改变窗体大小。</p></li><li><p>更改字体。</p></li><li><p>添加移除stylesheet块。</p></li><li><p>内容改变哪怕是输入框输入文字。</p></li><li><p>CSS虚类被触发如 :hover。</p></li><li><p>更改元素的className。</p></li><li><p>当对DOM节点执行新增或者删除操作或内容更改时。</p></li><li><p>动态设置一个style样式时（比如element.style.width=“10px”）。</p></li><li><p>当获取一个必须经过计算的尺寸值时，比如访问offsetWidth、clientHeight或者其他需要经过计算的CSS值。</p></li></ul></li><li><p>解决问题的关键，就是限制通过DOM操作所引发回流的次数。</p><ul><li><p>在对当前DOM进行操作之前，尽可能多的做一些准备工作，保证N次创建，1次写入。</p></li><li><p>在对DOM操作之前，把要操作的元素，先从当前DOM结构中删除：</p><ul><li><p>通过removeChild()或者replaceChild()实现真正意义上的删除。</p></li><li><p>设置该元素的display样式为“none”。</p></li></ul></li><li><p>每次修改元素的style属性都会触发回流操作。</p><pre><code>element.style.<span>backgroundColor </span>= <span>\"blue\"</span><span>;</span>\n</code></pre><ul><li><p>使用更改<code>className</code>的方式替换<code>style.xxx=xxx</code>的方式。</p></li><li><p>使用<code>style.cssText = '';</code>一次写入样式。</p></li><li><p>避免设置过多的行内样式。</p></li><li><p>添加的结构外元素尽量设置它们的位置为<code>fixed</code>或<code>absolute</code>。</p></li><li><p>避免使用表格来布局。</p></li><li><p>避免在<code>CSS</code>中使用<code>JavaScript expressions(IE only)</code>。</p></li></ul></li><li><p>将获取的<code>DOM</code>数据缓存起来。这种方法，对获取那些会触发回流操作的属性（比如<code>offsetWidth</code>等）尤为重要。</p></li><li><p>当对HTMLCollection对象进行操作时，应该将访问的次数尽可能的降至最低，最简单的，你可以将length属性缓存在一个本地变量中，这样就能大幅度的提高循环的效率。</p></li></ul></li></ul></li></ul>"}}
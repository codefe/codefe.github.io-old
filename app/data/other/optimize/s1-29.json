{"sta":1,"data":{"subTitle":"作用域链和闭包优化","content":"<ul><li><p>作用域。</p><ul><li><p>作用域(<code>scope</code>)是<code>JAVASCRIPT</code>编程中一个重要的<code>运行机制</code>，在<code>JAVASCRIPT</code>同步和异步编程以及<code>JAVASCRIPT</code>内存管理中起着至关重要的作用。</p></li><li><p>在<code>JAVASCRIPT</code>中，能形成作用域的有如下几点。</p><ul><li>函数的调用</li><li>with语句<ul><li><code>with</code>会创建自已的作用域，因此会增加其中执行代码的作用域的长度。</li></ul></li><li>全局作用域。</li></ul><p>以下代码为例：</p><pre><code>var foo = <span><span>function</span><span>()</span></span> {\n  var <span>local</span> = {};\n};\nfoo();\nconsole.<span>log</span>(<span>local</span>); //=&gt; undefined\n\nvar bar = <span><span>function</span><span>()</span></span> {\n  <span>local</span> = {};\n};\nbar();\nconsole.<span>log</span>(<span>local</span>); //=&gt; {}\n\n/**这里我们定义了foo()函数和bar()函数，他们的意图都是为了定义一个名为<span>local</span>的变量。在foo()函数中，我们使用var语句来声明定义了一个<span>local</span>变量，而因为函数体内部会形成一个作用域，所以这个变量便被定义到该作用域中。而且foo()函数体内并没有做任何作用域延伸的处理，所以在该函数执行完毕后，这个<span>local</span>变量也随之被销毁。而在外层作用域中则无法访问到该变量。而在bar()函数内，<span>local</span>变量并没有使用var语句进行声明，取而代之的是直接把<span>local</span>作为全局变量来定义。故外层作用域可以访问到这个变量。**/\n\n<span>local</span> = {};\n// 这里的定义等效于\nglobal.<span>local</span> = {};\n</code></pre></li></ul></li><li><p>作用域链</p><ul><li><p>在<code>JAVASCRIPT</code>编程中，会遇到多层函数嵌套的场景，这就是典型的作用域链的表示。</p><pre><code><span><span>function</span> <span>foo</span>(<span></span>) </span>{\n  <span>var</span> val = <span>'hello'</span>;\n  <span><span>function</span> <span>bar</span>(<span></span>) </span>{\n    <span><span>function</span> <span>baz</span>(<span></span>) </span>{\n      global.val = <span>'world;'</span>\n    };\n    baz();\n    <span>console</span>.log(val); <span>//=&gt; hello</span>\n  };\n  bar();\n};\nfoo();\n\n<span>/**在`JAVASCRIPT`中，变量标识符的查找是从当前作用域开始向外查找，直到全局作用域为止。所以`JAVASCRIPT`代码中对变量的访问只能向外进行，而不能逆而行之。baz()函数的执行在全局作用域中定义了一个全局变量val。而在bar()函数中，对val这一标识符进行访问时，按照从内到外的查找原则：在bar函数的作用域中没有找到，便到上一层，即foo()函数的作用域中查找。然而，使大家产生疑惑的关键就在这里：本次标识符访问在foo()函数的作用域中找到了符合的变量，便不会继续向外查找，故在baz()函数中定义的全局变量val并没有在本次变量访问中产生影响。**/</span>\n</code></pre></li></ul></li><li><p>减少作用域链上的查找次数</p><ul><li><p><code>JAVASCRIPT</code>代码在执行的时候，如果需要访问一个变量或者一个函数的时候，它需要遍历当前执行环境的作用域链，而遍历是从这个作用域链的前端一级一级的向后遍历，直到全局执行环境。</p><pre><code><span><span>/<span>**效率低**</span>/</span></span>\n<span>for</span>(<span>var</span> i = <span>0</span>; i &lt; <span>10000</span>; i++){\n    <span>var</span> but1 = <span>document</span>.getElementById(<span>\"but1\"</span>);\n}\n<span><span>/<span>**效率高**</span>/</span></span>\n<span><span>/<span>**避免全局查找**</span>/</span></span>\n<span>var</span> doc = <span>document</span>;\n<span>for</span>(<span>var</span> i = <span>0</span>; i &lt; <span>10000</span>; i++){\n    <span>var</span> but1 = doc.getElementById(<span>\"but1\"</span>);\n}\n<span><span>/<span>**上面代码中，第二种情况是先把全局对象的变量放到函数里面先保存下来，然后直接访问这个变量，而第一种情况是每次都遍历作用域链，直到全局环境，我们看到第二种情况实际上只遍历了一次，而第一种情况却是每次都遍历了，而且这种差别在多级作用域链和多个全局变量的情况下还会表现的非常明显。在作用域链查找的次数是`O(n)`。通过创建一个指向`document`的局部变量，就可以通过限制一次全局查找来改进这个函数的性能。**</span>/</span></span>\n</code></pre></li></ul></li><li><p>闭包</p><ul><li><p><code>JAVASCRIPT</code>中的标识符查找遵循从内到外的原则。</p><pre><code><span><span>function</span> <span>foo</span><span>()</span></span> {\n  var <span>local</span> = <span>'Hello'</span>;\n  <span>return</span> <span><span>function</span><span>()</span></span> {\n    <span>return</span> <span>local</span>;\n  };\n}\nvar bar = foo();\nconsole.<span>log</span>(bar()); //=&gt; Hello\n\n/**这里所展示的让外层作用域访问内层作用域的技术便是闭包(Closure)。得益于高阶函数的应用，使foo()函数的作用域得到`延伸`。foo()函数返回了一个匿名函数，该函数存在于foo()函数的作用域内，所以可以访问到foo()函数作用域内的<span>local</span>变量，并保存其引用。而因这个函数直接返回了<span>local</span>变量，所以在外层作用域中便可直接执行bar()函数以获得<span>local</span>变量。**/\n</code></pre></li><li><p>闭包是<code>JAVASCRIPT</code>的高级特性，因为把带有​​内部变量引用的函数带出了函数外部，所以该作用域内的变量在函数执行完毕后的并不一定会被销毁，直到内部变量的引用被全部解除。所以闭包的应用很容易造成内存无法释放的情况。</p></li><li><p>良好的闭包管理。</p><ul><li><p>循环事件绑定、私有属性、含参回调等一定要使用闭包时，并谨慎对待其中的细节。</p><ul><li><p>循环绑定事件，我们假设一个场景：有六个按钮，分别对应六种事件，当用户点击按钮时，在指定的地方输出相应的事件。</p><pre><code><span>var</span> btns = <span>document</span>.querySelectorAll(<span>'.btn'</span>); <span>// 6 elements</span>\n<span>var</span> output = <span>document</span>.querySelector(<span>'#output'</span>);\n<span>var</span> events = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>];\n<span>// Case 1</span>\n<span>for</span> (<span>var</span> i = <span>0</span>; i &lt; btns.length; i++) {\n  btns[i].onclick = <span><span>function</span>(<span>evt</span>) </span>{\n    output.innerText += <span>'Clicked '</span> + events[i];\n  };\n}\n<span>/**这里第一个解决方案显然是典型的循环绑定事件错误，这里不细说，详细可以参照我给一个网友的回答；而第二和第三个方案的区别就在于闭包传入的参数。**/</span>\n<span>// Case 2</span>\n<span>for</span> (<span>var</span> i = <span>0</span>; i &lt; btns.length; i++) {\n  btns[i].onclick = (<span><span>function</span>(<span>index</span>) </span>{\n    <span>return</span> <span><span>function</span>(<span>evt</span>) </span>{\n      output.innerText += <span>'Clicked '</span> + events[index];\n    };\n  })(i);\n}\n<span>/**第二个方案传入的参数是当前循环下标，而后者是直接传入相应的事件对象。事实上，后者更适合在大量数据应用的时候，因为在JavaScript的函数式编程中，函数调用时传入的参数是基本类型对象，那么在函数体内得到的形参会是一个复制值，这样这个值就被当作一个局部变量定义在函数体的作用域内，在完成事件绑定之后就可以对events变量进行手工解除引用，以减轻外层作用域中的内存占用了。而且当某个元素被删除时，相应的事件监听函数、事件对象、闭包函数也随之被销毁回收。**/</span>\n<span>// Case 3</span>\n<span>for</span> (<span>var</span> i = <span>0</span>; i &lt; btns.length; i++) {\n  btns[i].onclick = (<span><span>function</span>(<span>event</span>) </span>{\n    <span>return</span> <span><span>function</span>(<span>evt</span>) </span>{\n      output.innerText += <span>'Clicked '</span> + event;\n    };\n  })(events[i]);\n}\n</code></pre></li></ul></li></ul></li></ul></li><li><p>避开闭包陷阱</p><ul><li>闭包是个强大的工具，但同时也是性能问题的主要诱因之一。不合理的使用闭包会导致内存泄漏。</li><li>闭包的性能不如使用内部方法，更不如重用外部方法。<ul><li>由于<code>IE 9</code>浏览器的<code>DOM</code>节点作为<code>COM</code>对象来实现，<code>COM</code>的<code>内存管理</code>是通过引用计数的方式，引用计数有个难题就是循环引用，一旦<code>DOM</code>引用了闭包(例如<code>event handler</code>)，闭包的上层元素又引用了这个<code>DOM</code>，就会造成循环引用从而导致内存泄漏。</li></ul></li></ul></li><li><p>善用函数</p><ul><li><p>使用一个匿名函数在代码的最外层进行包裹。</p><p>;(function() { // 主业务代码 })();</p></li></ul><p>有的甚至更高级一点：</p><pre><code>;(<span><span>function</span>(<span>win, doc, $, undefined</span>) </span>{\n  <span>// 主业务代码</span>\n})(<span>window</span>, <span>document</span>, jQuery);\n</code></pre><p>甚至连如RequireJS, SeaJS, OzJS 等前端模块化加载解决方案，都是采用类似的形式：</p><pre><code><span>/**RequireJS**/</span>\ndefine([<span>'jquery'</span>], <span><span>function</span><span>($)</span> </span>{\n  <span>// 主业务代码</span>\n});\n<span>/**SeaJS**/</span>\ndefine(<span>'m​​odule'</span>, [<span>'dep'</span>, <span>'underscore'</span>], <span><span>function</span><span>($, _)</span> </span>{\n  <span>// 主业务代码</span>\n});\n</code></pre><p>被定义在全局作用域的对象，可能是会一直存活到进程退出的，如果是一个很大的对象，那就麻烦了。比如有的人喜欢在JavaScript中做模版渲染：</p><pre><code><span><span><span>&lt;?php</span>\n  $db = mysqli_connect(server, user, password, <span>'myapp'</span>);\n  $topics = mysqli_query($db, <span>\"SELECT * FROM topics;\"</span>);\n<span>?&gt;</span></span>\n<span>&lt;!doctype html&gt;</span>\n<span>&lt;<span>html</span> <span>lang</span>=<span>\"en\"</span>&gt;</span>\n<span>&lt;<span>head</span>&gt;</span>\n  <span>&lt;<span>meta</span> <span>charset</span>=<span>\"UTF-8\"</span>&gt;</span>\n  <span>&lt;<span>title</span>&gt;</span>你是猴子请来的逗比么？<span>&lt;/<span>title</span>&gt;</span>\n<span>&lt;/<span>head</span>&gt;</span>\n<span>&lt;<span>body</span>&gt;</span>\n  <span>&lt;<span>ul</span> <span>id</span>=<span>\"topics\"</span>&gt;</span><span>&lt;/<span>ul</span>&gt;</span>\n  <span>&lt;<span>script</span> <span>type</span>=<span>\"text/tmpl\"</span> <span>id</span>=<span>\"topic-tmpl\"</span>&gt;</span><span>\n    &lt;li <span><span>class</span></span>=<span>\"topic\"</span>&gt;\n      <span><span>&lt;<span>h1</span>&gt;</span></span></span></span><span>&lt;%=title%&gt;</span><span><span><span><span>&lt;/<span>h1</span>&gt;</span>\n      <span>&lt;<span>p</span>&gt;</span></span></span></span><span>&lt;%=content%&gt;</span><span><span><span><span>&lt;/<span>p</span>&gt;</span>\n    <span>&lt;/<span>li</span>&gt;</span>\n  </span></span><span>&lt;/<span>script</span>&gt;</span>\n  <span>&lt;<span>script</span> <span>type</span>=<span>\"text/javascript\"</span>&gt;</span><span>\n    <span>var</span> data = &lt;?php echo json_encode($topics); ?&gt;;\n    <span>var</span> topicTmpl = document.querySelector(<span>'#topic-tmpl'</span>).innerHTML;\n    <span>var</span> render = <span><span>function</span><span>(tmlp, view)</span> </span>{\n      <span>var</span> complied = tmlp\n        .replace(/\\n/g, <span>'\\\\n'</span>)\n        .replace(/</span></span><span>&lt;%=([\\s\\S]+?)%&gt;</span><span><span>/g, <span><span>function</span>(<span>match, code</span>) </span>{\n          <span>return</span> <span>'\" + escape('</span> + code + <span>') + \"'</span>;\n        });\n\n      complied = [\n        <span>'var res = \"\";'</span>,\n        <span>'with (view || {}) {'</span>,\n          <span>'res = \"'</span> + complied + <span>'\";'</span>,\n        <span>'}'</span>,\n        <span>'return res;'</span>\n      ].join(<span>'\\n'</span>);\n\n      <span>var</span> fn = <span>new</span> <span>Function</span>(<span>'view'</span>, complied);\n      <span>return</span> fn(view);\n    };\n\n    <span>var</span> topics = <span>document</span>.querySelector(<span>'#topics'</span>);\n    <span><span>function</span> <span>init</span>(<span></span>)\n      <span>data</span>.<span>forEach</span>(<span>function(topic</span>) </span>{\n        topics.innerHTML += render(topicTmpl, topic);\n      });\n    }\n    init();\n  </span><span>&lt;/<span>script</span>&gt;</span>\n<span>&lt;/<span>body</span>&gt;</span>\n<span>&lt;/<span>html</span>&gt;</span>\n</span></code></pre><p>在从数据库中获取到的数据的量是非常大的话，前端完成模板渲染以后，data变量便被闲置在一边。可因为这个变量是被定义在全局作用域中的，所以<code>JAVASCRIPT</code>引擎不会将其回收销毁。如此该变量就会一直存在于老生代堆内存中，直到页面被关闭。可是如果我们作出一些很简单的修改，在逻辑代码外包装一层函数，这样效果就大不同了。当UI渲染完成之后，代码对data的引用也就随之解除，而在最外层函数执行完毕时，<code>JAVASCRIPT</code>引擎就开始对其中的对象进行检查，data也就可以随之被回收。</p></li></ul>"}}
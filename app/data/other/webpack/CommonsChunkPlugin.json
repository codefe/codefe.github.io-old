{"sta":1,"data":{"subTitle":"CommonsChunkPlugin","content":"<h3 id=\"commonschunkplugin\">CommonsChunkPlugin</h3><pre><code><span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span>options<span>)</span>\n</code></pre><p><code>CommonsChunkPlugin</code><span>&nbsp;</span>插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口<span>&nbsp;</span><code>chunk</code><span>&nbsp;</span>的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p><h3 id=\"配置\">配置</h3><pre><code><span>{</span>\n  name<span>:</span> string<span>,</span> <span spellcheck=\"true\">// or</span>\n  names<span>:</span> string<span>[</span><span>]</span><span>,</span>\n  <span spellcheck=\"true\">// 这是 common chunk 的名称。已经存在的 chunk 可以通过传入一个已存在的 chunk 名称而被选择。</span>\n  <span spellcheck=\"true\">// 如果一个字符串数组被传入，这相当于插件针对每个 chunk 名被多次调用</span>\n  <span spellcheck=\"true\">// 如果该选项被忽略，同时 `options.async` 或者 `options.children` 被设置，所有的 chunk 都会被使用，否则 `options.filename` 会用于作为 chunk 名。</span>\n\n  filename<span>:</span> string<span>,</span>\n  <span spellcheck=\"true\">// common chunk 的文件名模板。可以包含与 `output.filename` 相同的占位符。</span>\n  <span spellcheck=\"true\">// 如果被忽略，原本的文件名不会被修改(通常是 `output.filename` 或者 `output.chunkFilename`)</span>\n\n  minChunks<span>:</span> number<span>|</span><span>Infinity</span><span>|</span><span>function</span><span>(</span>module<span>,</span> count<span>)</span> <span>-</span><span>&gt;</span> boolean<span>,</span>\n  <span spellcheck=\"true\">// 在传入  公共chunk(commons chunk) 之前所需要包含的最少数量的 chunks 。</span>\n  <span spellcheck=\"true\">// 数量必须大于等于2，或者少于等于 chunks的数量</span>\n  <span spellcheck=\"true\">// 传入 `Infinity` 会马上生成 公共chunk，但里面没有模块。</span>\n  <span spellcheck=\"true\">// 你可以传入一个 `function` ，以添加定制的逻辑（默认是 chunk 的数量）</span>\n\n  chunks<span>:</span> string<span>[</span><span>]</span><span>,</span>\n  <span spellcheck=\"true\">// 通过 chunk name 去选择 chunks 的来源。chunk 必须是  公共chunk 的子模块。</span>\n  <span spellcheck=\"true\">// 如果被忽略，所有的，所有的 入口chunk (entry chunk) 都会被选择。</span>\n\n\n  children<span>:</span> boolean<span>,</span>\n  <span spellcheck=\"true\">// 如果设置为 `true`，所有  公共chunk 的子模块都会被选择</span>\n\n  <span>async</span><span>:</span> boolean<span>|</span>string<span>,</span>\n  <span spellcheck=\"true\">// 如果设置为 `true`，一个异步的  公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。</span>\n  <span spellcheck=\"true\">// 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。</span>\n\n  minSize<span>:</span> number<span>,</span>\n  <span spellcheck=\"true\">// 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。</span>\n<span>}</span>\n</code></pre><p>T&gt; webpack1 构造函数<span>&nbsp;</span><code>new webpack.optimize.CommonsChunkPlugin(options, filenameTemplate, selectedChunks, minChunks)</code><span>&nbsp;</span>不再被支持。请使用相应的选项对象。</p><h3 id=\"例子\">例子</h3><h3 id=\"公共chunk-用于-入口chunk-entry-chunk\">公共chunk 用于 入口chunk (entry chunk)</h3><p>生成一个额外的 chunk 包含入口chunk 的公共模块。</p><pre><code><span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n  name<span>:</span> <span>\"commons\"</span><span>,</span>\n  <span spellcheck=\"true\">// ( 公共chunk(commnons chunk) 的名称)</span>\n\n  filename<span>:</span> <span>\"commons.js\"</span><span>,</span>\n  <span spellcheck=\"true\">// ( 公共chunk 的文件名)</span>\n\n  <span spellcheck=\"true\">// minChunks: 3,</span>\n  <span spellcheck=\"true\">// (模块必须被3个 入口chunk 共享)</span>\n\n  <span spellcheck=\"true\">// chunks: [\"pageA\", \"pageB\"],</span>\n  <span spellcheck=\"true\">// (只使用这些 入口chunk)</span>\n<span>}</span><span>)</span>\n</code></pre><p>你必须在 入口chunk 之前加载生成的这个 公共chunk:</p><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>commons.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>entry.bundle.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>\n</code></pre><h3 id=\"明确第三方库-chunk\">明确第三方库 chunk</h3><p>将你的代码拆分成公共代码和应用代码。</p><pre><code>entry<span>:</span> <span>{</span>\n  vendor<span>:</span> <span>[</span><span>\"jquery\"</span><span>,</span> <span>\"other-lib\"</span><span>]</span><span>,</span>\n  app<span>:</span> <span>\"./entry\"</span>\n<span>}</span>\n<span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n  name<span>:</span> <span>\"vendor\"</span><span>,</span>\n\n  <span spellcheck=\"true\">// filename: \"vendor.js\"</span>\n  <span spellcheck=\"true\">// (给 chunk 一个不同的名字)</span>\n\n  minChunks<span>:</span> <span>Infinity</span><span>,</span>\n  <span spellcheck=\"true\">// 随着 入口chunk 越来越多，这个配置保证没其它的模块会打包进 公共chunk</span>\n<span>}</span><span>)</span>\n</code></pre><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>vendor.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>app.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>\n</code></pre><p>提示：结合长期缓存，你可能需要使用这个<a href=\"https://github.com/diurnalist/chunk-manifest-webpack-plugin\" target=\"_blank\">插件</a>去避免 公共chunk 改变。 你也需要使用<span>&nbsp;</span><code>records</code><span>&nbsp;</span>去保持稳定的模块 id。</p><h3 id=\"将公共模块打包进父-chunk\">将公共模块打包进父 chunk</h3><p>使用代码拆分功能，一个 chunk 的多个子 chunk 会有公共的模块。你可以将这些公共模块移入父 chunk (这个会减少总体的大小，但会对首次加载时间产生不良影响。如果预期用户需要下载许多兄弟 chunks，那这将非常有用)。</p><pre><code><span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n  <span spellcheck=\"true\">// names: [\"app\", \"subPageA\"]</span>\n  <span spellcheck=\"true\">// (选择 chunks，或者忽略该项设置以选择全部 chunks)</span>\n\n  children<span>:</span> <span>true</span><span>,</span>\n  <span spellcheck=\"true\">// (选择所有被选 chunks 的子 chunks)</span>\n\n  <span spellcheck=\"true\">// minChunks: 3,</span>\n  <span spellcheck=\"true\">// (在提取之前需要至少三个子 chunk 共享这个模块)</span>\n<span>}</span><span>)</span>\n</code></pre><h3 id=\"额外的异步-公共chunk\">额外的异步 公共chunk</h3><p>与上面的类似，但是并非将公共模块移动到父 chunk（增加初始加载时间），而是使用新的异步加载的额外公共chunk。当下载额外的 chunk 时，它将自动并行下载。</p><pre><code><span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n  <span spellcheck=\"true\">// names: [\"app\", \"subPageA\"]</span>\n <span spellcheck=\"true\">// (选择 chunks，或者忽略该项设置以选择全部 chunks)</span>\n\n  children<span>:</span> <span>true</span><span>,</span>\n  <span spellcheck=\"true\">// (选择所有被选 chunks 的子 chunks)</span>\n\n  <span>async</span><span>:</span> <span>true</span><span>,</span>\n  <span spellcheck=\"true\">// (创建一个异步 公共chunk)</span>\n\n  <span spellcheck=\"true\">// minChunks: 3,</span>\n  <span spellcheck=\"true\">// (在提取之前需要至少三个子 chunk 共享这个模块)</span>\n<span>}</span><span>)</span>\n</code></pre><h3 id=\"给-minchunks-配置传入函数\">给<span>&nbsp;</span><code>minChunks</code><span>&nbsp;</span>配置传入函数</h3><p>你也可以给<span>&nbsp;</span><code>minChunks</code><span>&nbsp;</span>传入一个函数。这个函数会被<span>&nbsp;</span><code>CommonsChunkPlugin</code><span>&nbsp;</span>插件回调，并且调用函数时会传入<span>&nbsp;</span><code>module</code><span>&nbsp;</span>和<span>&nbsp;</span><code>count</code><span>&nbsp;</span>参数。</p><p><code>module</code><span>&nbsp;</span>参数代表每个 chunks 里的模块，这些 chunks是你通过<span>&nbsp;</span><code>name</code><span>&nbsp;</span>参数传入的。</p><p><code>count</code><span>&nbsp;</span>参数表示<span>&nbsp;</span><code>module</code><span>&nbsp;</span>被使用的 chunk 数量。</p><p>当你想要对<span>&nbsp;</span><code>CommonsChunk</code><span>&nbsp;</span>如何决定模块被打包到哪里的算法有更为细致的控制， 这个配置就会非常有用。</p><pre><code><span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n  name<span>:</span> <span>\"my-single-lib-chunk\"</span><span>,</span>\n  filename<span>:</span> <span>\"my-single-lib-chunk.js\"</span><span>,</span>\n  minChunks<span>:</span> <span>function</span><span>(</span>module<span>,</span> countOfHowManyTimesThisModuleIsUsedAcrossAllChunks<span>)</span> <span>{</span>\n    <span spellcheck=\"true\">// 如果模块是一个路径，而且在路径中有 \"somelib\" 这个名字出现，</span>\n    <span spellcheck=\"true\">// 而且它还被三个不同的 chunks/入口chunk 所使用，那请将它拆分到</span>\n    <span spellcheck=\"true\">// 另一个分开的 chunk 中，chunk 的 keyname 是 \"my-single-lib-chunk\"， 而文件名是</span>\n    <span spellcheck=\"true\">// \"my-single-lib-chunk.js\"</span>\n    <span>return</span> module<span>.</span>resource <span>&amp;&amp;</span> <span>(</span><span>/somelib/</span><span>)</span><span>.</span><span>test</span><span>(</span>module<span>.</span>resource<span>)</span> <span>&amp;&amp;</span> count <span>===</span> <span>3</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><p>正如上面看到的，这个例子允许你只将其中一个库移到一个分开的文件当中，当而仅当函数中的所有条件都被满足了。</p>"}}
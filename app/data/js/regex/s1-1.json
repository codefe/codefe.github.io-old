{"sta":1,"data":{"subTitle":"test,exec,match,replace方法的区别","content":"<h3>用法介绍</h3><p>注：pattern 为RegExp的实例, str 为String的实例</p><table><thead><tr><th>用法</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>pattern.test(str)</td><td>判断str是否包含匹配结果</td><td>包含返回true，不包含返回false。</td></tr><tr><td>pattern.exec(str)</td><td>根据pattern对str进行正则匹配</td><td>返回匹配结果数组,如匹配不到返回null</td></tr><tr><td>str.match(pattern)</td><td>根据pattern对str进行正则匹配</td><td>返回匹配结果数组,如匹配不到返回null</td></tr><tr><td>str.replace(pattern, replacement)</td><td>根据pattern进行正则匹配,把匹配结果替换为replacement</td><td>一个新的字符串</td></tr></tbody></table><p></p><h3>RegExp对象方法</h3><h3>1. test()</h3><p>字符串的test方法，比较常用在判断语句中，最简单的RegExp方法了，用于检测一个字符串是否匹配某个模式：\n<br>\n<br>RegExpObject.test(string)\n<br>如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false：\n<br>\n<br>/\\d/.test('asdf2') // --true   检测字符串`'asdf2'`中是否函数数字</p><h3>2. exec()</h3><p>exec()方法功能非常强大，它是一个通用的方法方法，用于比较复杂的模式匹配或者是说你为你提供更多的信息：\n<br><blockquote>RegExpObject.exec(string)\n</blockquote>如果在string中找到了匹配的文本，则返回一个包含这些文本的数组，否侧返回null。这里有几个注意的地方：\n<br>\n<br>1. 返回的数组的第一个元素是与整个正则匹配的文本\n<br>然后数组的第二个元素是与整个正则的第一个子表达式(分组)相匹配的文本\n<br>数组的第三个元素整个正则的第二个子表达式(分组)相匹配的文本，以此类推。\n<br><blockquote>```<br>\nvar result = /(\\d+)-(\\w+)/.exec('12-ab');<br>\nconsole.log(result) // --&gt; [\"12-ab\", \"12\", \"ab\", index: 0, input: \"12-ab\"]<br> \n//为什么上面返回的“数组”是那么奇怪，按照[w3school][2]的说法就是：exec() 都会把完整的细节添加到它返回的数组中，这里的细节指的就是index和input<br>\n```<br>\n<br>整个正则表达式匹配的文本：`\"12-ab\"`<br>\n第一个子表达式匹配的文本：`\"12\"`<br>\n第二个子表达式匹配的文本：`\"ab\"`\n</blockquote>\n2. 从上面返回的数组结果可知，数组添加了两个额外的属性，分别是：index, input\n<br>index: 匹配文本的第一个字符的位置.\n<br>input: 顾名思义，就是指输入的整体的文本了.\n<br><blockquote>```<br>\nconsole.log(result.index) // --&gt; 0<br>\nconsole.log(result.input) // --&gt; '12-ab'<br>\n```\n</blockquote>3. 执行exec函数时，尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配，\n<br>获取字符串中第一个与正则表达式想匹配的内容，并且将匹配内容和子匹配的结果存储到返回的数组中,\n<br>例如：/\\d/g.exec('a22') ，返回的结果和上面的结果一样： [\"2\"]\n<br><blockquote>    /\\d/g.exec('a22') // --&gt;[\"2\"]</blockquote></p><p><h3>深入了解 exec()\n</h3>深入前看看RegExp的实例有哪些属性：\n<br>\n<img src=\"/app/data/js/regex/img/aaa\" style=\"max-width:100%;\">\n<img src=\"/app/data/js/regex/1.jpg\" style=\"max-width:100%;\"></p><p><img src=\"/app/data/js/regex/img/1.png\" style=\"max-width:100%;\" class=\"\">global: 布尔值，表示是否设置了 g 标志\n<br>ignoreCase: 布尔值，表示是否设置了 i 标志\n<br>lastIndex: 搜索下一个匹配项时开始的位置，从0开始\n<br>multiline: 布尔值，表示是否设置了 m 标志\n<br>source: 正则表达式的字符串表示\n<br>这里稍微陌生一点的就是lastIndex属性了，因为我们不会显示的需要用到它。但它还是挺重要的：\n<br>\n<br>例1：非全局匹配\n<br><img src=\"/app/data/js/regex/img/2.png\" style=\"max-width:100%;\"><br><blockquote>var reg = /\\d/;<br>\n//第一次匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\n[\"1\"]<br>\n  0<br>\n<br>第二次匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\n[\"1\"]<br>\n  0 \n</blockquote>  \n</p><p>结论：\n<br>\n<br>同一正则表达式，在非全局匹配模式下，每次实例的lastIndex属性的值总是不变的(为第一次找到匹配文本所在的位置，上面为0 )；\n<br>每次的匹配查找都是将lastIndex作为起始位置的\n<br>例2：全局匹配\n<br>\n<img src=\"/app/data/js/regex/img/3.png\" style=\"max-width:100%;\">\n<br><blockquote>var reg = /\\d/g;<br>\n//第一次匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\n[\"1\"]<br>\n  2<br>\n<br>第二次匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\n[\"2\"]<br>\n  3<br> \n<br>第三次匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\n[\"3\"]<br>\n  4<br> \n<br>第四匹配<br>\nconsole.log(reg.exec('a123'));<br>\nconsole.log(reg.lastIndex);<br>\n//输出<br>\nnull<br>\n  0\n</blockquote>  \n\n\n</p><p>结论：\n<br>\n<br>同一正则表达式，在全局匹配模式下，每次实例的lastIndex属性的值为匹配文本最后一个字符的下一个位置，上面例子中第一次匹配的时候最后一个字符位置为1，则下一个位置为：2\n<br>当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。\n<br>那当要获取全局匹配的全部匹配项时，可以通过循环来获取：\n<br>\n<br><blockquote>var reg = /\\d/g,<br>\n    result = [],<br>\n    crt;<br>\nwhile((crt = reg.exec('a123')) !== null){<br>\n    result = result.concat(crt)<br>\n};<br>\nresult; //[\"1\", \"2\", \"3\"]\n</blockquote><p><br></p><h3>String对象方法</h3></p><p><h3>1. match()\n</h3>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。在一定程度上它与上面的exec()有些相似，看一下吧：\n<br>\n<br>例1：非全局匹配\n<br><blockquote>var a = 'aaaa'.match(/\\w/);<br>\nconsole.log(a); // [\"a\", index: 0, input: \"aaaa\"]\n</blockquote>可以看到，和exec()一样，在数组中返回了index 和 input属性。\n<br>\n<br>例2：全局匹配\n<br><blockquote>var a = 'aaaa'.match(/\\w/g);<br>\nconsole.log(a); // [\"a\", \"a\", \"a\", \"a\"]\n</blockquote>全局匹配就和exec方法有很大的不同了，他直接返回了所有符合匹配的子字符串的数组，另外，index和input属性也不在其中了，所以这个方法效率可能会高一些，但是如果你需要更多的信息，则用exec()吧</p><p><h3>2. replace()\n</h3>这也是一个比较灵活常用的方法，它用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n<br>\n<br>这个方法接收两个必须的参数：\n<br>\n<br>pattern: 这个参数可以是字符串或是RegExp对象\n<br>replacement： 替换匹配项的字符串或处理函数的返回值\n<br>返回结果：\n<br>\n<br>1. 当未找到匹配项的时候，返回原始字符串。\n<br><blockquote>    'aaaa'.replace('bbb', 'b')     //\"aaaa\"\n</blockquote>   \n<br>2. 当pattern为字符串或者为非全局的RegExp对象的时候，只替换找到的第一项匹配项。\n<br><blockquote>    'aaaa'.replace('a', 'b')     //\"baaa\"<br>\n    'aaaa'.replace(/\\w/, 'b')    //\"baaa\"\n</blockquote>3. 当pattern为全局的RegExp对象的时候，替换每一项匹配项。\n<br><blockquote>    'aaaa'.replace(/\\w/g, 'b')    //\"bbbb\"\n</blockquote><h4>replacement：为函数时：</h4><blockquote>'aaaa'.replace(/\\w/g, function() {<br>\n    return 'b';<br>\n}); // \"bbbb\"<br>\n<br>'aaaa'.replace(/\\w/g, function(value) {<br>\n    return value.toUpperCase();<br>\n}); // \"AAAA\"\n</blockquote>\n结论：\n<br>\n<br>函数的返回值将作为替换字符串\n<br>函数的第一个参数的值是每一个匹配项,当然还有第二个参数，它的值是每个匹配项在原始字符串的中位置，从0开始\n<br>特殊的 $:\n<br>\n<br>replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。\n<br>\n<br><blockquote>字符&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;替换文本<br>\n1、2、...、$99&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。<br>\n$&amp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;与 regexp 相匹配的子串<br>\n$`&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;位于匹配子串左侧的文本<br>\n$'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 位于匹配子串右侧的文本<br>\n$$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;直接量符号&nbsp;</blockquote></p><p><br>来一发：\n<br>\n<br><blockquote>//第一种情况：<br>\n'aa11AA'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$1'); // \"aa\"<br>\n'aa11AA'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$2'); // \"11\"<br>\n'aa11AA'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$3'); // \"AA\"<br>\n    //猜想 如果是 $4 回事什么呢？ undefined ?<br> \n    'aa11AA'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$4'); // \"$4\"<br>\n    //所以，要是没有该子项，则当成普通字符串处理了<br>\n<br>//第二种情况：<br>\n'aa11AA'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$&amp;'); //\"aa11AA\"<br>\n<br>//第三种情况：<br>\n'aa11AA'.replace(/(\\d+)/g, '$`'); //\"aaaaAA\"<br>\n<br>//第四种情况：<br>\n'aa11AA'.replace(/(\\d+)/g, \"$'\"); //\"aaAAAA\"<br>\n<br>//第五种情况：<br>\n'aa11AA'.replace(/(\\d+)/g, '$$'); //\"aa$AA\"\n</blockquote>    \n\n\n\n先这样吧，有问题再补充了，( ╯□╰ )</p><p><br></p>"}}
{"sta":1,"data":{"subTitle":"深拷贝","content":"<pre><code>function extendDeeply(p, c){\n  var c = c || {};\n  for (var prop in p){\n    if(typeof p[prop] === \"object\"){\n      c[prop] = (p[prop].constructor === Array)?[]:{};\n      extendDeeply(p[prop], c[prop]);\n    }else{\n      c[prop] = p[prop];\n    }\n  }\n}</code></pre><p><!--StartFragment-->利用递归进行深拷贝，这样子对象的修改就不会影响到父对象。<!--EndFragment-->&nbsp;</p><pre><code>extendDeeply(Person, programer);\nprogramer.address.home = 'allin';\nPerson.address.home; // home\n利用call和apply继承\nfunction Parent(){\n  this.name = \"abc\";\n  this.address = {home: \"home\"};\n}\nfunction Child(){\n  Parent.call(this);\n  this.language = \"js\"; \n}\nES5中的Object.create()\nvar p = { name : 'allin'};\nvar obj = Object.create(o);\nobj.name; // allin</code></pre><p>Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法：&nbsp;<br></p><pre><code>//模拟Object.create()方法\nfunction myCreate(o){\n  function F(){};\n  F.prototype = o;\n  o = new F();\n  return o;\n}\nvar p = { name : 'allin'};\nvar obj = myCreate(o);\nobj.name; // allin</code></pre><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署。</p><pre><code>if (!Object.create) {\n　　Object.create = function (o) {\n　　　　 function F() {}\n　　　　F.prototype = o;\n　　　　return new F();\n　　};\n}</code></pre><p><br></p>"}}
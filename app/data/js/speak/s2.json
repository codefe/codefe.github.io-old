{"sta":1,"data":{"subTitle":"网页中文本朗读功能开发实现","content":"<p>前几天完成了一个需求，在网页中完成鼠标指向哪里，就用语音读出所指的文本。如果是按钮、链接、文本输入框，则还还要给出是什么的提醒。同时针对大段的文本，不能整段的去读，要按照标点符号进行断句处理。</p><p>重点当然就是先获取到当前标签上的文本，再把文本转化成语音即可。</p><h3>标签朗读</h3><p>这个很简单了，只用根据当前是什么标签，给出提示即可。</p><pre><code>// 标签朗读文本\nvar tagTextConfig = {\n    'a': '链接',\n    'input[text]': '文本输入框',\n    'input[password]': '密码输入框',\n    'button': '按钮',\n    'img': '图片'\n};</code></pre><p>还有需要朗读的标签，继续再添加即可。\n<br>然后根据标签，返回前缀文本即可。</p><pre><code>/**\n * 获取标签朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n */\nfunction getTagText(el) {\n    if (!el) return '';\n    var tagName = el.tagName.toLowerCase();\n    // 处理input等多属性元素\n    switch (tagName) {\n        case 'input':\n            tagName += '[' + el.type + ']';\n            break;\n        default:\n            break;\n    }\n    // 标签的功能提醒和作用应该有间隔，因此在最后加入一个空格\n    return (tagTextConfig[tagName] || '') + ' ';\n}</code></pre><p>获取完整的朗读文本就更简单了，先取标签的功能提醒，再取标签的文本即可。\n<br>文本内容优先取 title 其次 alt 最后 innerText。</p><pre><code>/**\n * 获取完整朗读文本\n * @param {HTMLElement} el 要处理的HTMLElement\n * @returns {String}   朗读文本\n */\nfunction getText(el) {\n    if (!el) return '';\n    return getTagText(el) + (el.title || el.alt || el.innerText || '');\n}</code></pre><p>这样就可以获取到一个标签的功能提醒和内容的全部带朗读文本了。\n<br><h3>正文分隔</h3>接下来要处理的就是正文分隔了，在这个过程中，踩了不少坑，走了不少弯路，好好记录一下。\n<br>首先准备了正文分隔的配置：</p><pre><code>// 正文拆分配置\nvar splitConfig = {\n    // 内容分段标签名称\n    unitTag: 'p',\n    // 正文中分隔正则表达式\n    splitReg: /[,;，；。]/g,\n    // 包裹标签名\n    wrapTag: 'label',\n    // 包裹标签类名\n    wrapCls: 'speak-lable',\n    // 高亮样式名和样式\n    hightlightCls: 'speak-help-hightlight',\n    hightStyle: 'background: #000!important; color: #fff!important'\n};</code></pre><p>最开始想的就是直接按照正文中的分隔标点符号进行分隔就好了呀。\n<br>\n<br>想法如下：\n<br>\n<br>获取段落全部文本\n<br>使用 split(分隔正则表达式) 方法将正文按照标点符号分隔成小段\n<br>每个小段用标签包裹放回去即可\n<br>然而理想很丰满，现实很骨感。\n<br><h4>两个大坑如下：</h4>split 方法进行分隔，分隔后分隔字符就丢了，也就是说把原文的一些标点符号给弄丢了。\n<br>如果段落内还存在其他标签，而这个标签内部也正好存在待分隔的标点符号，那包裹分段标签时直接破换了原标签的完整性。\n<br>关于第一个问题，丢失标点的符号，考虑过逐个标点来进行和替换 split 分隔方法为逐个字符循环来做。\n<br>\n<br>前者问题是原本一次完成的工作分成了多次，效率太低。第二种感觉效率更低了，分隔本来是很稀疏的，但是却要变成逐个字符出判断处理，更关键的是，分隔标点的位置要插入包裹标签，会导致字符串长度变化，还要处理下标索引。代码是机器跑的，或许不会觉得烦，但是我真的觉得好烦。如果这么干，或许以后哪个 AI 或者同事看到这样的代码，说不定会说 “这真是个傻 xxxx”。\n<br>\n<br>第二个问题想过很多办法来补救，如先使用正则匹配捕获内容中成对的标签，对标签内部的分隔先处理一遍，然后再处理整个的。\n<br>\n<br>想不明白问题二的，可参考一下待分隔的段落:</p><pre><code>&lt;p&gt;这是一段测试文本，这里有个链接。&lt;a&gt;您好，可以点击此处进行跳转&lt;/a&gt;还有其他内容其他内容容其他内容容其他内容，容其他内容。&lt;/p&gt;</code></pre><p>如先使用 /&lt;((\\w+?)&gt;)(.+?)&lt;\\/\\2(?=&gt;)/g 正则，依次捕获段落内被标签包裹的内容，对标签内部的内容先处理。\n<br>\n<br>但是问题又来了，这么处理的都是字符串，在 js 中都是基本类型，这些操作进行的时候都是在复制的基础上进行的，要修改到原字符串里去，还得记录下原本的开始结束位置，再将新的插进去。繁，还是繁，但是已经比之前逐个字符去遍历的好，正则捕获中本来就有了匹配的索引，直接用即可，还能接受。\n<br>\n<br>但是这只是处理了段落内部标签的问题，段落内肯定还有很多文本是没有处理呢，怎么办？\n<br>\n<br>正则匹配到了只是段落内标签的结果啊，外面的没有啊。哦，对，有匹配到的索引，上次匹配到的位置加上上次处理的长度，就是一段直接文本的开始。下一次匹配到的索引 - 1 就是这段直接文本的结束。这只是匹配过程中的，还有首尾要单独处理。又回到烦的老路上去了。。。\n<br>\n<br>这么烦，一个段落分隔能这么繁琐，我不信！\n<br>\n<br>突然想到了，有文本节点这么个东西，删繁就简嘛，正则先到边上去，直接处理段落的所有节点不就行了。\n<br>\n<br>文本节点则分隔直接包裹，标签节点则对内容进行包裹，这种情况下处理的直接是 dom，更省事。\n<br>\n<br>文本节点里放标签？这是在开玩笑么，是也不是。文本节点里确实只能放文本，但是我把标签直接放进去，它会自动转义，那最后再替换出来不就行了。\n<br>\n<br>好了，方案终于有了，而且这个方案逻辑多简单，代码逻辑自然也不会烦。</p><pre><code>/**\n * 正文内容分段处理\n * @param {jQueryObject/HTMLElement/String}  $content 要处理的正文jQ对象或HTMLElement或其对应选择器\n */\nfunction splitConent($content) {\n    $content = $($content);\n    $content.find(splitConfig.unitTag).each(function (index, item) {\n        var $item = $(item),\n            text = $.trim($item.text());\n        if (!text) return;\n        var nodes = $item[0].childNodes;\n        $.each(nodes, function (i, node) {\n            switch (node.nodeType) {\n                case 3:\n                    // text 节点\n                    // 由于是文本节点，标签被转义了，后续再转回来\n                    node.data = '&lt;' + splitConfig.wrapTag + '&gt;' +\n                        node.data.replace(splitConfig.splitReg, '&lt;/' + splitConfig.wrapTag + '&gt;$&amp;&lt;' + splitConfig.wrapTag + '&gt;') +\n                        '&lt;/' + splitConfig.wrapTag + '&gt;';\n                    break;\n                case 1:\n                    // 元素节点\n                    var innerHtml = node.innerHTML,\n                        start = '',\n                        end = '';\n                    // 如果内部还有直接标签，先去掉\n                    var startResult = /^&lt;\\w+?&gt;/.exec(innerHtml);\n                    if (startResult) {\n                        start = startResult[0];\n                        innerHtml = innerHtml.substr(start.length);\n                    }\n                    var endResult = /&lt;\\/\\w+?&gt;$/.exec(innerHtml);\n                    if (endResult) {\n                        end = endResult[0];\n                        innerHtml = innerHtml.substring(0, endResult.index);\n                    }\n                    // 更新内部内容\n                    node.innerHTML = start +\n                        '&lt;' + splitConfig.wrapTag + '&gt;' +\n                        innerHtml.replace(splitConfig.splitReg, '&lt;/' + splitConfig.wrapTag + '&gt;$&amp;&lt;' + splitConfig.wrapTag + '&gt;') +\n                        '&lt;/' + splitConfig.wrapTag + '&gt;' +\n                        end;\n                    break;\n                default:\n                    break;\n            }\n        });\n        // 处理文本节点中被转义的html标签\n        $item[0].innerHTML = $item[0].innerHTML\n            .replace(new RegExp('&lt;' + splitConfig.wrapTag + '&gt;', 'g'), '&lt;' + splitConfig.wrapTag + '&gt;')\n            .replace(new RegExp('&lt;/' + splitConfig.wrapTag + '&gt;', 'g'), '&lt;/' + splitConfig.wrapTag + '&gt;');\n        $item.find(splitConfig.wrapTag).addClass(splitConfig.wrapCls);\n    });\n}</code></pre><p>上面代码中最后对文本节点中被转义的包裹标签替换似乎有点麻烦，但是没办法，ES5 之前 JavaScript 并不支持正则的后行断言（也就是正则表达式中 “后顾”）。所以没办法对包裹标签前后的 &lt; 和 &gt; 进行精准替换，只能连同标签名一起替换。\n<br><h3>事件处理</h3>在上面完成了文本获取和段落分隔，下面要做的就是鼠标移动上去时获取文本触发朗读即可，移开时停止朗读即可。\n<br>\n<br>鼠标移动，只读一次，基于这两点原因，使用 mouseenter 和 mouseleave 事件来完成。\n<br>\n<br>原因：\n<br>\n<br>不冒泡，不会触发父元素的再次朗读\n<br>不重复触发，一个元素内移动时不会重复触发。</p><pre><code>/**\n * 在页面上写入高亮样式\n */\nfunction createStyle() {\n    if (document.getElementById('speak-light-style')) return;\n    var style = document.createElement('style');\n    style.id = 'speak-light-style';\n    style.innerText = '.' + splitConfig.hightlightCls + '{' + splitConfig.hightStyle + '}';\n    document.getElementsByTagName('head')[0].appendChild(style);\n}\n// 非正文需要朗读的标签 逗号分隔\nvar speakTags = 'a, p, span, h1, h2, h3, h4, h5, h6, img, input, button';\n$(document).on('mouseenter.speak-help', speakTags, function (e) {\n    var $target = $(e.target);\n    // 排除段落内的\n    if ($target.parents('.' + splitConfig.wrapCls).length || $target.find('.' + splitConfig.wrapCls).length) {\n        return;\n    }\n    // 图片样式单独处理 其他样式统一处理\n    if (e.target.nodeName.toLowerCase() === 'img') {\n        $target.css({\n            border: '2px solid #000'\n        });\n    } else {\n        $target.addClass(splitConfig.hightlightCls);\n    }\n    // 开始朗读\n    speakText(getText(e.target));\n}).on('mouseleave.speak-help', speakTags, function (e) {\n    var $target = $(e.target);\n    if ($target.find('.' + splitConfig.wrapCls).length) {\n        return;\n    }\n    // 图片样式\n    if (e.target.nodeName.toLowerCase() === 'img') {\n        $target.css({\n            border: 'none'\n        });\n    } else {\n        $target.removeClass(splitConfig.hightlightCls);\n    }\n    // 停止语音\n    stopSpeak();\n});\n// 段落内文本朗读\n$(document).on('mouseenter.speak-help', '.' + splitConfig.wrapCls, function (e) {\n    $(this).addClass(splitConfig.hightlightCls);\n    // 开始朗读\n    speakText(getText(this));\n}).on('mouseleave.speak-help', '.' + splitConfig.wrapCls, function (e) {\n    $(this).removeClass(splitConfig.hightlightCls);\n    // 停止语音\n    stopSpeak();\n});</code></pre><p>注意要把针对段落的语音处理和其他地方的分开。为什么？ 因为段落是个块级元素，鼠标移入段落中的空白时，如：段落前后空白、首行缩进、末行剩余空白等，是不应该触发朗读的，如果不阻止掉，进行这些区域将直接触发整段文字的朗读，失去了我们对段落文本内分隔的意义，而且，无论什么方式转化语音都是要时间的，大段内容可能需要较长时间，影响语音输出的体验。</p>"}}
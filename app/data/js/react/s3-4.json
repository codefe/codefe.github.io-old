{"sta":1,"data":{"subTitle":"多个react组件性能优化，key的优化","content":"<p><code>react</code>组件在装载过程中，<code>react</code>通过在<code>render</code>方法在内存中产生一个树形结构，树上的节点代表一个<code>react</code>组件或者原生的<code>Dom</code>元素，这个树形结构就是我们所谓的<code>Vitural Dom</code>，react根据这个来渲染产生浏览器的<code>Dom</code>树。</p>\n<p><code>react</code>在更新阶段对比原有的<code>Vitural Dom</code>和新生成的<code>Vitural Dom</code>，找出不同之处，在根据不同来渲染Dom树。</p>\n<p>react为了追求高性能，采用了时间复杂度为<code>O(N)</code>来比较两个属性结构的区别，因为要确切比较两个树形结构，需要通过<code>O(N^3)</code>，这会降低性能。</p>\n<p>我们举几个情况，大家就会马上理解：</p>\n<ul>\n<li>\n<p><strong>节点类型不同</strong></p>\n<pre><code>// A组件\n\n&lt;div&gt;\n  &lt;Todos /&gt;\n&lt;/div&gt;\n\n// B组件\n&lt;span&gt;\n  &lt;Todos /&gt;\n&lt;/span&gt;\n</code></pre>\n<p>我们想把<code>A</code>组件更新成<code>B</code>组件，<code>react</code>在做比较的时候，发现最外面的根结点不一样，直接就废掉了之前的<code>&lt;div&gt;</code>节点，包括里面的子节点，这是一个巨大的浪费，但是为了避免<code>O(N^3)</code>的时间复杂度，只能采用这种方式</p>\n<p>所以在开发过程中，我们应该尽量避免上面的情况，不要将包裹节点的类型随意改变。</p>\n</li>\n<li>\n<p><strong>两个节点类型一样</strong></p>\n<p>这里包括两种情况，一种是节点是<code>Dom</code>类型，还有一种<code>react</code>组件。</p>\n<p>对于<code>dom</code>类型，我们举个例子：</p>\n<pre><code>// A组件\n&lt;div style={{color: 'red',fontSize:15}} className=\"welcome\"&gt;\n  Hello World!!!\n&lt;/div&gt;\n\n// B组件\n&lt;div style={{color: 'green',fontSize:15}} className=\"react\"&gt;\n  Good Bye!!!\n&lt;/div&gt;\n</code></pre>\n<p>上述A和B组件的区别是文字、<code>className</code>、<code>style</code>中的<code>color</code>发生改变，因为<code>Dom</code>元素没变，<code>React</code>只会修改他变化的部分。</p>\n<p>针对<code>react</code>组件类型，渲染无非就是在走一遍组件实例的更新过程，最主要的就是定制<code>shouldComponentUpdate</code>，我们上面也有讲到，就不细讲了。</p>\n</li>\n<li><div><br></div></li><li><div><br></div></li><li>\n<p><strong>多个子组件情况</strong></p>\n<p>我们看两个例子就能明白</p>\n<p>例子一：</p>\n<pre><code>// A\n&lt;ul&gt;\n  &lt;TodoItem text=\"First\" complete={false} /&gt;\n  &lt;TodoItem text=\"Second\" complete={false} /&gt;\n&lt;/ul&gt;\n\n// B\n&lt;ul&gt;\n  &lt;TodoItem text=\"First\" complete={false} /&gt;\n  &lt;TodoItem text=\"Second\" complete={false} /&gt;\n  &lt;TodoItem text=\"Third\" complete={false} /&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>从A变到B，如果<code>shouldComponentUpdate</code>处理得当，我们只需要更新装载<code>third</code>的那<strong>一次</strong>就行。</p>\n<p>我们来看看下一个例子：</p>\n<pre><code>// A\n&lt;ul&gt;\n  &lt;TodoItem text=\"First\" complete={false} /&gt;\n  &lt;TodoItem text=\"Second\" complete={false} /&gt;\n&lt;/ul&gt;\n\n// B\n&lt;ul&gt;\n  &lt;TodoItem text=\"Zero\" complete={false} /&gt;\n  &lt;TodoItem text=\"First\" complete={false} /&gt;\n  &lt;TodoItem text=\"Second\" complete={false} /&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>这里因为react是采用O(n)的时间复杂度，所以会依次将text为First的改为Zero，text为Second改为First，在最后再加上一个组件，text为Second。现存的两个的text的属性都被改变了，所以会依次渲染。</p>\n<p>如果我们这里有1000个实例，那么就会发生1000次更新。</p>\n<p><strong>这里我们就要用到<code>Key</code>了</strong></p>\n<p>简单来说，其实这一个Key就是react组件的身份证号。</p>\n<p>我们将上一个例子改成如下，就可以避免上面的问题了,react就能够知道其实B里面的第二个和第三个组件其实就是A中的第一个和第二个实例。</p>\n<pre><code>// A\n&lt;ul&gt;\n  &lt;TodoItem key={1} text=\"First\" complete={false} /&gt;\n  &lt;TodoItem key={2} text=\"Second\" complete={false} /&gt;\n&lt;/ul&gt;\n\n// B\n&lt;ul&gt;\n  &lt;TodoItem key={0} text=\"Zero\" complete={false} /&gt;\n  &lt;TodoItem key={1} text=\"First\" complete={false} /&gt;\n  &lt;TodoItem key={2} text=\"Second\" complete={false} /&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>不过现在，react也会提醒我们不要忘记使用<code>key</code>，如果没有加，在浏览器中会报错。</p><div>\n<div>react_key​</div></div>\n<p>关于<code>key</code>的使用我们要注意的是，这个key值要稳定不变的，就如同<strong>身份证号</strong>之于我们是稳定不变的一样。</p>\n<p><strong>一个常见的错误就是，拿数组的的下标值去当做key，这个是很危险的，代码如下，我们一定要避免。</strong></p>\n<pre><code>&lt;ul&gt;\n  {\n        todos.map((item, index) =&gt; {\n            &lt;TodoItem\n              key={index}\n              text={item.text}\n              completed={item.completed}\n        })\n  }\n&lt;/ul&gt;\n</code></pre>\n<p>​</p></li><li><p><br></p></li><li><p><br></p></li></ul>"}}
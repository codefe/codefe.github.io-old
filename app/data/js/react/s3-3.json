{"sta":1,"data":{"subTitle":"Immutable.js","content":"<div><p>先配上一张经典的图和经典的一句话：</p>\n<div>\n<div>\n<div></div>\n<div data-width=\"613\" data-height=\"575\"><img src=\"/app/data/js/react/img/6.webp\" style=\"max-width:100%;\"><br></div>\n</div>\n<div>Immutable</div>\n</div>\n<blockquote>\n<p>Shared mutable state is the root of all evil（共享的可变状态是万恶之源）</p>\n<p>-- Pete Hunt</p>\n</blockquote>\n<p><code>javascript</code>中的对象一般都是可变的，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新对象将影响到原始对象。</p>\n<p>举个例子：</p>\n<pre><code>foo = { a : 1 };\nbar = foo;\nbar.a = 2;\n</code></pre>\n<p>当我们给<code>bar.a</code>赋值后，会发现<code>foo.a</code>也变成了2，虽然我们可以通过深拷贝与浅拷贝解决这个问题，但是这样做非常的昂贵，对<code>cpu</code>和内存会造成浪费。</p>\n<p>这里就需要用到<code>Immutable</code>，通过<code>Immutable</code>创建的<code>Immutable Data</code>一旦被创建，就不能再更改。对<code>Immutable</code>对象进行修改、添加或删除操作，都会返回一个新的<code>Immutable</code>对象。</p>\n<p>这里我们将一下其中三个比较重要的数据结构</p>\n<ul>\n<li><strong>Map：键值对集合，对应<code>Object</code>，<code>Es6</code>种也有专门的<code>Map</code>对象</strong></li>\n<li><strong>List：有序可重复列表，对应于<code>Array</code></strong></li>\n<li><strong>ArraySet：有序且不可重复的列表</strong></li>\n</ul>\n<p>我们可以看两个例子：</p>\n<p>使用<code>Map</code>生成一个<code>immutable</code>对象</p>\n<pre><code>import { Map , is } from 'immutable';\n\nlet obj = Map({\n  'name': 'react study',\n  'course': Map({name: 'react+redux'})\n})\n\nlet obj1 = obj.set('name','darrell');\n\nconsole.log(obj.get('course') === obj1.get('course')); // 返回true\nconsole.log(obj === obj1); // 返回false\n</code></pre>\n<p><code>Immutable.is</code> 比较的是两个对象的 <code>hashCode</code> 或 <code>valueOf</code>（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 <code>hashCode</code> 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p>\n<pre><code>let obj = Map({name:1,title:'react'});\nlet obj1 = Map({name:1,title:'react'});\nconsole.log(is(obj,obj1)); // 返回true\n\nlet obj2 = {name:1,title:'react'};\nlet obj3 = {name:1,title:'react'};\nconsole.log(is(obj2,obj3)); // 返回false\n</code></pre>\n<p><strong><code>Immutable</code>优点</strong>：</p>\n<ul>\n<li>减少内存的使用</li>\n<li>并发安全</li>\n<li>降低项目的复杂度</li>\n<li>便于比较复杂数据，定制shouldComponentUpdate方便</li>\n<li>时间旅行功能</li>\n<li>函数式编程</li>\n</ul>\n<p><strong><code>Immutable</code>缺点</strong>：</p>\n<ul>\n<li>学习成本</li>\n<li>库的大小（建议使用seamless-immutable）</li>\n<li>对现有项目入侵严重</li>\n<li>容易与原生的对象进行混淆</li></ul></div><br>"}}
{"sta":1,"data":{"subTitle":"在生产中部署ES2015 +代码","content":"<p>最近谈论的大多数网络开发人员都喜欢用所有最新的语言功能编写JavaScript - 异步/等待，类，箭头功能等。但是，尽管所有现代浏览器都可以运行ES2015 +代码并且原生支持我刚提到的功能大多数开发人员仍然将他们的代码转换为ES5并将其与polyfill捆绑在一起，以适应仍在旧浏览器上的小部分用户。</p><p>这有点糟透了。在理想的世界中，我们不会发送不必要的代码。</p><p>使用新的JavaScript和DOM API，我们可以<a href=\"https://philipwalton.com/articles/loading-polyfills-only-when-needed/\">有条件地加载polyfill，</a>因为我们可以在运行时检测它们的支持。但是使用新的JavaScript&nbsp;<em>语法</em>，这是非常棘手的，因为任何未知的语法都会导致解析错误，然后没有任何代码会运行。</p><p>虽然我们目前没有针对功能检测新语法的良好解决方案，但我们<em>现在</em>有一种方法可以检测基本的ES2015语法支持。</p><p>解决方案是<code>&lt;script type=\"module\"&gt;</code>。</p><p>大多数开发人员都认为是<code>&lt;script type=\"module\"&gt;</code>加载ES模块的方式（当然这是真的），但<code>&lt;script type=\"module\"&gt;</code>也有一个更直接和实用的用例加载常规JavaScript文件与ES2015 +功能，并知道浏览器可以处理它！</p><p>换句话说，每个支持的浏览器<code>&lt;script type=\"module\"&gt;</code>也支持您熟悉和喜爱的大多数ES2015 +功能。例如：</p><ul><li>每个支持的浏览器<code>&lt;script type=\"module\"&gt;</code>也支持<strong>async / await</strong></li><li>每个支持的浏览器<code>&lt;script type=\"module\"&gt;</code>也支持<strong>类</strong>。</li><li>每个支持的浏览器<code>&lt;script type=\"module\"&gt;</code>也支持<strong>箭头功能</strong>。</li><li>每个支持的浏览器<code>&lt;script type=\"module\"&gt;</code>也支持<strong>fetch</strong>，<strong>Promises</strong>，<strong>Map</strong>和<strong>Set</strong>等等！</li></ul><p>剩下要做的唯一事情是为不支持的浏览器提供后备<code>&lt;script type=\"module\"&gt;</code>。幸运的是，如果您当前正在生成代码的ES5版本，那么您已经完成了这项工作。您现在需要的只是生成ES2015 +版本！</p><p>本文的其余部分将介绍如何实现此技术，并讨论如何发布ES2015 +代码的能力将如何改变我们编写模块的方式。</p><h2 id=\"implementation\">履行</h2><p>如果您现在已经使用webpack或汇总等模块捆绑器来生成JavaScript，那么您应该继续这样做。</p><p>接下来，除了当前的捆绑包，您将生成第二个捆绑包，就像第一个捆绑包一样;&nbsp;唯一的区别是你不会一直向下转到ES5，你不需要包括传统的polyfill。</p><p>如果您已经在使用<a href=\"https://github.com/babel/babel-preset-env\"><code>babel-preset-env</code></a>（您应该使用），那么第二步非常简单。您所要做的就是将浏览器列表更改为仅支持的浏览器，<code>&lt;script type=\"module\"&gt;</code>并且Babel将自动不应用它不具有的转换。</p><p>换句话说，它将输出ES2015 +代码而不是ES5。</p><p>例如，如果您正在使用webpack并且您的主脚本入口点是<code>./path/to/main.mjs</code>，那么您当前的ES5版本的配置可能如下所示（注意，我正在调用此捆绑包，<code>main.es5.js</code>因为它是ES5）：</p><pre><code>module.exports = {\n  entry: './path/to/main.mjs',\n  output: {\n    filename: <mark>'main.es5.js'</mark>,\n    path: path.resolve(__dirname, 'public'),\n  },\n  module: {\n    rules: [{\n      test: /\\.m?js$/,\n      use: {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            ['env', {\n              modules: false,\n              useBuiltIns: true,\n              targets: {\n                browsers: [\n                  <mark>'&gt; 1%',</mark>\n                  <mark>'last 2 versions',</mark>\n                  <mark>'Firefox ESR',</mark>\n                ],\n              },\n            }],\n          ],\n        },\n      },\n    }],\n  },\n};\n</code></pre><p>要制作一个现代的ES2015 +版本，您只需进行第二次配置并将目标环境设置为仅包含支持的浏览器<code>&lt;script type=\"module\"&gt;</code>。它可能看起来像这样（注意，这里我使用的是<code>.mjs</code>扩展，因为它是一个模块）：</p><pre><code>module.exports = {\n  entry: './path/to/main.mjs',\n  output: {\n    filename: <mark>'main.mjs'</mark>,\n    path: path.resolve(__dirname, 'public'),\n  },\n  module: {\n    rules: [{\n      test: /\\.m?js$/,\n      use: {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            ['env', {\n              modules: false,\n              useBuiltIns: true,\n              targets: {\n                browsers: [\n                  <mark>'Chrome &gt;= 60',</mark>\n                  <mark>'Safari &gt;= 10.1',</mark>\n                  <mark>'iOS &gt;= 10.3',</mark>\n                  <mark>'Firefox &gt;= 54',</mark>\n                  <mark>'Edge &gt;= 15',</mark>\n                ],\n              },\n            }],\n          ],\n        },\n      },\n    }],\n  },\n};\n</code></pre><p>运行时，这两个配置将输出两个生产就绪的JavaScript文件：</p><ul><li><code>main.mjs</code>&nbsp;（语法为ES2015 +）</li><li><code>main.es5.js</code>&nbsp;（语法为ES5）</li></ul><p>下一步是更新HTML以在支持模块的浏览器中有条件地加载ES2015 +软件包。你可以用组合做到这一点<code>&lt;script type=\"module\"&gt;</code>和<code>&lt;script nomodule&gt;</code>：</p><pre><code>&lt;!-- Browsers with ES module support load this file. --&gt;\n&lt;script type=\"module\" src=\"main.mjs\"&gt;&lt;/script&gt;\n\n&lt;!-- Older browsers load this file (and module-supporting --&gt;\n&lt;!-- browsers know *not* to load this file). --&gt;\n&lt;script nomodule src=\"main.es5.js\"&gt;&lt;/script&gt;\n</code></pre><aside id=\"mjs-warnings\"><p><strong>注意：</strong>我已经更新了本文中的示例，以使用<code>.mjs</code>我作为模块加载的任何文件的文件扩展名。由于<a href=\"https://developers.google.com/web/fundamentals/primers/modules#mjs\">这种做法</a>相对较新，如果我没有指出使用它时可能会遇到的一些问题，我会失职：</p><ul><li>您的Web服务器需要配置为<code>.mjs</code>使用<code>Content-Type</code>标头提供文件<code>text/javascript</code>。如果您的浏览器无法加载<code>.mjs</code>文件，那可能就是原因。</li><li>如果您使用Webpack和<a href=\"https://github.com/babel/babel-loader\">babel-loader</a>捆绑您的JavaScript，您可能会复制/粘贴<a href=\"https://github.com/babel/babel-loader/blob/8f240b498bb24ef89f7b306f5ac806e84b813b0d/README.md#usage\">一些</a>仅转换<code>.js</code>文件的<a href=\"https://github.com/babel/babel-loader/blob/8f240b498bb24ef89f7b306f5ac806e84b813b0d/README.md#usage\">配置代码</a>。从你的配置更改正则表达式<code>/\\.js$/</code>来<code>/\\.m?js$/</code>应该解决您的问题。</li><li>较旧的webpack版本<a href=\"https://github.com/webpack/webpack/issues/7927\">不会</a>为<code>.mjs</code>文件<a href=\"https://github.com/webpack/webpack/issues/7927\">创建源图</a>，但是<a href=\"https://github.com/webpack/webpack/releases/tag/v4.19.1\">自webpack 4.19.1以来，</a>这已得到修复。</li></ul></aside><h3 id=\"important-considerations\">重要考虑因素</h3><p>在大多数情况下，这种技术“只是起作用”，但在实现此策略之前，有一些关于如何加载模块的详细信息：</p><ol><li>模块加载就好<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer\"><code>&lt;script defer&gt;</code></a>，这意味着它们在文档解析之后才会执行。如果您的某些代码需要在此之前运行，则最好将该代码拆分并单独加载。</li><li>模块总是以<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\">严格模式</a>运行代码，因此如果出于任何原因需要在严格模式之外运行任何代码，则必须单独加载。</li><li>模块以不同于脚本的方式处理顶级<code>var</code>和<code>function</code>声明。例如，在一个脚本<code>var foo = 'bar'</code>并且<code>function foo() {…}</code>可以从被访问<code>window.foo</code>，但在模块中不是这种情况。确保您的代码中不依赖于此行为。</li></ol><aside><p><strong>警告！</strong>Safari 10不支持该<code>nomodule</code>属性，但您可以通过在使用任何标记之前在HTML中<a href=\"https://gist.github.com/samthor/64b114e4a4f539915a95b91ffd340acc\">内联JavaScript代码段</a>来解决此问题<code>&lt;script nomodule&gt;</code>。<em>（注意：这已在Safari 11中修复）。</em></p></aside><h2 id=\"a-working-example\">一个工作的例子</h2><p>我创建了<a href=\"https://github.com/philipwalton/webpack-esnext-boilerplate\">webpack-esnext-boilerplate，</a>因此开发人员可以看到这种技术的真正实现。</p><p>有了这个样板，我有意包含了几个先进的webpack功能，因为我想证明这种技术已经可以生产并可以在真实场景中使用。这些包括众所周知的捆绑最佳实践，例如：</p><ul><li><a href=\"https://webpack.js.org/guides/code-splitting/\">代码拆分</a></li><li><a href=\"https://webpack.js.org/guides/code-splitting/#dynamic-imports\">动态导入</a>（在运行时有条件地加载其他代码）</li><li><a href=\"https://webpack.js.org/guides/caching/\">资产指纹识别</a>（用于有效的长期缓存）</li></ul><p>因为我永远不会推荐我不会使用的东西，所以我已经更新了这个博客以使用该技术。如果您想了解更多信息，可以查看<a href=\"https://github.com/philipwalton/blog\">源代码</a>。</p><p>如果您使用webpack之外的工具来生成生产包，则该过程或多或少相同。我选择在这里使用webpack演示这个，因为它是目前最受欢迎的捆绑器，而且它也是最复杂的。我想如果该技术可以与webpack一起使用，它可以适用于任何事情。</p><h2 id=\"is-this-really-worth-the-extra-effort%3F\">这真的值得额外的努力吗？</h2><p>在我看来，绝对！节省的费用可能很大。例如，以下是此博客中实际生成的代码的两个版本的总文件大小的比较：</p><table><tbody><tr><th>版</th><th>尺寸（缩小）</th><th><strong>大小（缩小+ gzipped）</strong></th></tr><tr><td>ES2015 +（main.mjs）</td><td>80K</td><td><strong>21K</strong></td></tr><tr><td>ES5（main.es5.js）</td><td>175K</td><td><strong>43K</strong></td></tr></tbody></table><p>传统的ES5版本是ES2015 +版本大小（甚至是gzip）的两倍多。</p><p>较大的文件需要更长的下载时间，但它们也需要更长的时间来解析和评估。在比较我的站点中的两个版本时，解析/评估时间也一直是旧版本的两倍（这些测试是使用<a href=\"https://webpagetest.org/\">webpagetest.org</a>在Moto G4上运行的）：</p><table><tbody><tr><th>版</th><th>解析/评估时间（个别运行）</th><th><strong>解析/平均时间（平均）</strong></th></tr><tr><td>ES2015 +（main.mjs）</td><td>184ms，164ms，166ms</td><td><strong>172ms</strong></td></tr><tr><td>ES5（main.es5.js）</td><td>389毫秒，351毫秒，360毫秒</td><td><strong>367ms</strong></td></tr></tbody></table><p>虽然这些绝对文件大小和解析/评估时间不是特别长，但要意识到这是一个博客，我不加载大量脚本。但对于那里的大多数网站来说情况并非如此。您拥有的脚本越多，您通过发送ES2015 +就会看到的收益越大。</p><p>如果您仍然持怀疑态度，并且您认为文件大小和执行时间的差异主要是由于需要更多的polyfill来支持传统环境，那么您并不完全错误。但是，无论好坏，这在今天的网络上是一种非常普遍的做法。</p><p><a href=\"https://bigquery.cloud.google.com/savedquery/438218511550:2cee796ae27f472fbfd517606a4bafc3\">对HTTPArchive数据集的</a>快速<a href=\"https://bigquery.cloud.google.com/savedquery/438218511550:2cee796ae27f472fbfd517606a4bafc3\">查询</a>显示，排名最高的Alexa排名网站中有85,181个在其生产包中包含<a href=\"https://babeljs.io/docs/usage/polyfill/\">babel-polyfill</a>，<a href=\"https://github.com/zloirock/core-js\">core-js</a>或<a href=\"https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js\">regenerator-runtime</a>。六个月前，这个数字是34,588！</p><p>现实正在转变，包括polyfills正在迅速成为新的常态。不幸的是，这意味着数十亿用户通过线路不必要地将数万亿个字节发送到完全能够本机运行未传输代码的浏览器。</p><h2 id=\"it%E2%80%99s-time-we-start-publishing-our-modules-as-es2015\">是时候我们开始将模块发布为ES2015</h2><p>目前这种技术的主要问题是大多数模块作者不发布其源代码的ES2015 +版本，他们发布了转换后的ES5版本。</p><p>既然可以部署ES2015 +代码，我们就应该改变它了。</p><p>我完全明白，这对眼前的未来提出了很多挑战。大多数生成工具今天发布的文件<a href=\"https://github.com/babel/babel-loader/blob/v7.1.2/README.md#usage\">建议配置</a>该<a href=\"https://rollupjs.org/#babel\">承担所有的模块都ES5</a>。这意味着如果模块作者开始向npm发布ES2015 +源代码，他们可能会<a href=\"https://github.com/googleanalytics/autotrack/issues/137\">破坏一些用户的构建，</a>并且通常会引起混淆。</p><p>问题是大多数使用Babel的开发人员将其配置为不转换任何内容<code>node_modules</code>，但如果使用ES2015 +源代码发布模块，则这是一个问题。幸运的是，修复很容易。您只需<code>node_modules</code>从构建配置中删除排除项：</p><pre><code>rules: [\n  {\n    test: /\\.m?js$/,\n    <mark>exclude: /node_modules/, // Remove this line</mark>\n    use: {\n      loader: 'babel-loader',\n      options: {\n        presets: ['env']\n      }\n    }\n  }\n]\n</code></pre><p>缺点是，如果<code>node_modules</code>除了本地依赖项之外，像Babel这样的工具必须开始转换依赖关系，那么构建将会变慢。幸运的是，这是一个可以<a href=\"https://github.com/babel/babel-loader/blob/v7.1.2/README.md#babel-loader-is-slow\">通过持久的本地缓存在工具级别</a>解决的问题。</p><p>无论在ES2015 +作为新模块发布标准的道路上我们可能面临的困境如何，我认为这是一场值得拥有的战斗。如果我们作为模块作者，只将代码的ES5版本发布到npm，那么我们会强制用户使用膨胀且代码较慢的代码。</p><p>通过发布ES2015，我们为开发人员提供了一个选择，并最终使每个人受益。</p><h2 id=\"conclusion\">结论</h2><p>虽然<code>&lt;script type=\"module\"&gt;</code>旨在成为在浏览器中加载ES模块（及其依赖项）的机制，但它不必<em>仅用</em>于此目的。</p><p><code>&lt;script type=\"module\"&gt;</code>&nbsp;将很乐意加载一个JavaScript文件，这为开发人员提供了一种急需的方法，可以在支持它的浏览器中有条件地加载现代功能。</p><p>这个以及<code>nomodule</code>属性为我们提供了一种在生产中使用ES2015 +代码的方法，我们终于可以停止向不需要它的浏览器发送这么多转换代码。</p><p>编写ES2015代码对开发人员来说是一个胜利，部署ES2015代码对用户来说是一个胜利。</p>"}}
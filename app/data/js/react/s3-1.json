{"sta":1,"data":{"subTitle":"render里面尽量减少新建变量和bind函数","content":"<h4>1，<code>render</code>里面尽量减少新建变量和<code>bind</code>函数，传递参数是尽量减少传递参数的数量。</h4><p>首先我们先思考一个问题，比如我要实现一个点击按钮使相应的<code>num</code>增加1，我们有哪一些方法。</p><p>大家应该都能想到，无非就是三种:</p><p><img src=\"/app/data/js/react/img/1505342-0f40ca09681a5f14.webp\" style=\"max-width:100%;\"><br></p><div><div><p><font color=\"#c24f4a\">第一种是在构造函数中绑定<code>this</code>，第二种是在<code>render()</code>函数里面绑定<code>this</code>，第三种就是使用箭头函数，都能实现上述方法；</font></p>\n<p>但是哪一种方法的性能最好，是我们要考虑的问题。应该大家都知道答案：<strong><font color=\"#c24f4a\">第一种的性能最好</font></strong>。</p>\n<p><strong><font color=\"#c24f4a\">因为第一种，构造函数每一次渲染的时候只会执行一遍；</font></strong></p>\n<p><strong>而第二种方法，在每次<code>render()</code>的时候都会重新执行一遍函数；</strong></p>\n<p><strong>第三种方法的话，每一次<code>render()</code>的时候，都会生成一个新的箭头函数，即使两个箭头函数的内容是一样的。</strong></p>\n<p>第三种方法我们可以举一个例子，因为<code>react</code>判断是否需要进行<code>render</code>是<strong>浅层比较</strong>，简单来说就是通过<code>===</code>来判断的，如果<code>state</code>或者<code>prop</code>的类型是字符串或者数字，只要值相同，那么浅层比较就会认为其相同；</p>\n<p><strong>但是如果前者的类型是复杂的对象的时候，我们知道对象是引用类型，浅层比较只会认为这两个<code>prop</code>是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的<code>prop</code>。</strong></p>\n<p>举个例子：</p>\n<p>当我们给组件<code>Foo</code>给名为<code>style</code>的<code>prop</code>赋值；</p>\n<pre><code>&lt;Foo style={{ color:\"red\" }}\n</code></pre>\n<p>使用这种方法，每一次渲染都会被认为是一个<code>style</code>这个<code>prop</code>发生了变化，因为每一次都会产生一个对象给<code>style</code>。</p>\n<p>那么我们应该如何改进，如果想要让<code>react</code>渲染的时候认为前后对象类型<code>prop</code>相同，则必须要保证<code>prop</code>指向同一个<code>javascript</code>对象，如下：</p>\n<pre><code>const fooStyle = { color: \"red\" }; //取保这个初始化只执行一次，不要放在render中，可以放在构造函数中\n\n&lt;Foo style={fooStyle} /&gt;\n</code></pre>\n<p>这个问题是我们在平时的编码中可以避免的。</p></div><br><br></div>"}}
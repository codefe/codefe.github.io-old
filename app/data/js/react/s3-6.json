{"sta":1,"data":{"subTitle":"首屏加载优化","content":"<h3>1. 在 root 节点中写一些东西</h3><p>我们完全可以把首屏渲染的时间点提前，比如在你的 root 节点中写一点东西：</p><div><pre onclick=\"hljs.signin(event)\"><code>&lt;div class=\"root\"&gt;Loading...&lt;/div&gt;\n</code></pre></div><p>就是这么简单，就可以把你应用的首屏时间提前到 html、css 加载完毕</p><p>此时：</p><div><pre><code>首屏体积 = html + css\n</code></pre></div><p>当然一行没有样式的 \"Loading...\" 文本可能会让设计师想揍你一顿，为了避免被揍，我们可以在把 root 节点内的内容画得好看一些.</p><h3>2. 使用 html-webpack-plugin 自动插入 loading</h3><p>实际业务中肯定是有很多很多页面的，每个页面都要我们手动地复制粘贴这么一个 loading 态显然太不优雅了，这时我们可以考虑使用 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/jantimon/html-webpack-plugin\" rel=\"nofollow\" target=\"_blank\">html-webpack-plugin</a> 来帮助我们自动插入 loading。</p><div><pre onclick=\"hljs.signin(event)\"><code><ol><li><div><div data-line-number=\"1\"></div></div><div><div>var HtmlWebpackPlugin = require('html-webpack-plugin');</div></div></li><li><div><div data-line-number=\"2\"></div></div><div><div>var path = require('path');</div></div></li><li><div><div data-line-number=\"3\"></div></div><div><div> </div></div></li><li><div><div data-line-number=\"4\"></div></div><div><div>// 读取写好的 loading 态的 html 和 css</div></div></li><li><div><div data-line-number=\"5\"></div></div><div><div>var loading = {</div></div></li><li><div><div data-line-number=\"6\"></div></div><div><div>    html: fs.readFileSync(path.join(__dirname, './loading.html')),</div></div></li><li><div><div data-line-number=\"7\"></div></div><div><div>    css: '&lt;style&gt;' + fs.readFileSync(path.join(__dirname, './loading.css')) + '&lt;/style&gt;'</div></div></li><li><div><div data-line-number=\"8\"></div></div><div><div>}</div></div></li><li><div><div data-line-number=\"9\"></div></div><div><div> </div></div></li><li><div><div data-line-number=\"10\"></div></div><div><div>var webpackConfig = {</div></div></li><li><div><div data-line-number=\"11\"></div></div><div><div>  entry: 'index.js',</div></div></li><li><div><div data-line-number=\"12\"></div></div><div><div>  output: {</div></div></li><li><div><div data-line-number=\"13\"></div></div><div><div>    path: path.resolve(__dirname, './dist'),</div></div></li><li><div><div data-line-number=\"14\"></div></div><div><div>    filename: 'index_bundle.js'</div></div></li><li><div><div data-line-number=\"15\"></div></div><div><div>  },</div></div></li><li><div><div data-line-number=\"16\"></div></div><div><div>  plugins: [</div></div></li><li><div><div data-line-number=\"17\"></div></div><div><div>    new HtmlWebpackPlugin({</div></div></li><li><div><div data-line-number=\"18\"></div></div><div><div>      filename: 'xxxx.html',</div></div></li><li><div><div data-line-number=\"19\"></div></div><div><div>      template: 'template.html',</div></div></li><li><div><div data-line-number=\"20\"></div></div><div><div>      loading: loading</div></div></li><li><div><div data-line-number=\"21\"></div></div><div><div>    })</div></div></li><li><div><div data-line-number=\"22\"></div></div><div><div>  ]</div></div></li><li><div><div data-line-number=\"23\"></div></div><div><div>};</div></div></li></ol></code><div data-title=\"登录后复制\"></div></pre></div><p>然后在模板中引用即可：</p><div><pre onclick=\"hljs.signin(event)\"><code><ol><li><div><div>&lt;!DOCTYPE html&gt;</div></div></li><li><div><div data-line-number=\"2\"></div></div><div><div>&lt;html lang=\"en\"&gt;</div></div></li><li><div><div data-line-number=\"3\"></div></div><div><div>    &lt;head&gt;</div></div></li><li><div><div data-line-number=\"4\"></div></div><div><div>        &lt;%= htmlWebpackPlugin.options.loading.css %&gt;</div></div></li><li><div><div data-line-number=\"5\"></div></div><div><div>    &lt;/head&gt;</div></div></li><li><div><div data-line-number=\"6\"></div></div><div><div> </div></div></li><li><div><div data-line-number=\"7\"></div></div><div><div>    &lt;body&gt;</div></div></li><li><div><div data-line-number=\"8\"></div></div><div><div>        &lt;div id=\"root\"&gt;</div></div></li><li><div><div data-line-number=\"9\"></div></div><div><div>            &lt;%= htmlWebpackPlugin.options.loading.html %&gt;</div></div></li><li><div><div data-line-number=\"10\"></div></div><div><div>        &lt;/div&gt;</div></div></li><li><div><div data-line-number=\"11\"></div></div><div><div>    &lt;/body&gt;</div></div></li><li><div><div data-line-number=\"12\"></div></div><div><div>&lt;/html&gt;</div></div></li></ol></code></pre></div><hr><h3><span style=\"font-weight: normal;\">3. 使用 prerender-spa-plugin 渲染首屏</span></h3><h2><a name=\"t4\"></a></h2><p>在一些比较大型的项目中，Loading 可能本身就是一个 React/Vue 组件，在不做服务器端渲染的情况下，想把一个已经组件化的 Loading 直接写入 html 文件中会很复杂，不过依然有解决办法。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/chrisvfritz/prerender-spa-plugin\" rel=\"nofollow\" target=\"_blank\">prerender-spa-plugin</a> 是一个可以帮你在构建时就生成页面首屏 html 的一个 webpack 插件，原理大致如下：</p><ol><li>指定 dist 目录和要渲染的路径</li><li>插件在 dist 目录中开启一个静态服务器，并且使用无头浏览器（<a href=\"https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer\" rel=\"nofollow\" target=\"_blank\">puppeteer</a>）访问对应的路径，执行 JS，抓取对应路径的 html。</li><li>把抓到的内容写入 html，这样即使没有做服务器端渲染，也能达到跟服务器端渲染几乎相同的作用（不考虑动态数据的话）</li></ol><p>具体如何使用，可以参考<a href=\"https://zhuanlan.zhihu.com/p/31954853\" rel=\"nofollow\" target=\"_blank\">这一篇文章</a></p><div><pre onclick=\"hljs.signin(event)\"><code><ol><li><div><div data-line-number=\"1\"></div></div><div><div>plugins: [</div></div></li><li><div><div data-line-number=\"2\"></div></div><div><div>  new PrerenderSpaPlugin(</div></div></li><li><div><div data-line-number=\"3\"></div></div><div><div>    path.join(__dirname, 'dist'),</div></div></li><li><div><div data-line-number=\"4\"></div></div><div><div>    [ '/', '/products/1', '/products/2', '/products/3']</div></div></li><li><div><div data-line-number=\"5\"></div></div><div><div>  )</div></div></li><li><div><div data-line-number=\"6\"></div></div><div><div>]</div></div></li></ol></code></pre></div><h2><a name=\"t5\"></a>4. 除掉外链 css</h2><p>截止到目前，我们的首屏体积 = html + css，依然有优化的空间，那就是把外链的 css 去掉，让浏览器在加载完 html 时，即可渲染首屏。</p><p>实际上，webpack 默认就是没有外链 css 的，你什么都不需要做就可以了。当然如果你的项目之前配置了 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/extract-text-webpack-plugin\" rel=\"nofollow\" target=\"_blank\">extract-text-webpack-plugin</a> 或者 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/mini-css-extract-plugin\" rel=\"nofollow\" target=\"_blank\">mini-css-extract-plugin</a> 来生成独立的 css 文件，直接去掉即可。</p><p>有人可能要质疑，把 css 打入 js 包里，会丢失浏览器很多缓存的好处（比如你只改了 js 代码，导致构建出的 js 内容变化，但连带 css 都要一起重新加载一次），这样做真的值得吗？</p><p>确实这么做会让 css 无法缓存，但实际上对于现在成熟的前端应用来说，缓存不应该在 js/css 这个维度上区分，而是应该按照“组件”区分，即配合动态 import 缓存组件。</p><p>接下来你会看到，css in js 的模式带来的好处远大于这么一丁点缺点。</p><p><br></p>"}}
{"sta":1,"data":{"subTitle":"ES6 中的 Promise","content":"<h3>第一部分，Promise 加入 ES6 标准</h3><p>从 jquery v1.5 发布经过若干时间之后，Promise 终于出现在了 ES6 的标准中，而当下 ES6 也正在被大规模使用。</p><h4>本节内容概述</h4><ul><li>写一段传统的异步操作</li><li>用<code>Promise</code>进行封装</li></ul><h4>写一段传统的异步操作</h4><p>还是拿之前讲 jquery&nbsp;<code>deferred</code>对象时的那段<code>setTimeout</code>程序</p><div><div><br></div><pre><span>var</span> wait = <span>function</span><span> () {\n    </span><span>var</span> task = <span>function</span><span> () {\n        console.log(</span>'执行完成'<span>)\n    }\n    setTimeout(task, </span>2000<span>)\n}\nwait()</span></pre><div><br></div></div><p>之前我们使用 jquery 封装的，接下来将使用 ES6 的<code>Promise</code>进行封装，大家注意看有何不同。</p><h4>用<code>Promise</code>进行封装</h4><div><pre>const wait =  <span>function</span><span>) {\n    </span><span>//</span><span> 定义一个 promise 对象</span>\n    const promise = <span>new</span> Promise((resolve, reject) =&gt;<span> {\n        </span><span>//</span><span> 将之前的异步操作，包括到这个 new Promise 函数之内</span>\n        const task = <span>function</span><span> () {\n            console.log(</span>'执行完成'<span>)\n            resolve()  </span><span>//</span><span> callback 中去执行 resolve 或者 reject</span>\n<span>        }\n        setTimeout(task, </span>2000<span>)\n    })\n    </span><span>//</span><span> 返回 promise 对象</span>\n    <span>return</span><span> promise\n}</span></pre></div><p>注意看看程序中的注释，那都是重点部分。从整体看来，感觉这次比用 jquery 那次简单一些，逻辑上也更加清晰一些。</p><ul><li>将之前的异步操作那几行程序，用<code>new Promise((resolve,reject) =&gt; {.....})</code>包装起来，最后<code>return</code>即可</li><li>异步操作的内部，在<code>callback</code>中执行<code>resolve()</code>（表明成功了，失败的话执行<code>reject</code>）</li></ul><p>接着上面的程序继续往下写。<code>wait()</code>返回的肯定是一个<code>promise</code>对象，而<code>promise</code>对象有<code>then</code>属性。</p><div><pre>const w =<span> wait()\nw.then(() </span>=&gt;<span> {\n    console.log(</span>'ok 1'<span>)\n}, () </span>=&gt;<span> {\n    console.log(</span>'err 1'<span>)\n}).then(() </span>=&gt;<span> {\n    console.log(</span>'ok 2'<span>)\n}, () </span>=&gt;<span> {\n    console.log(</span>'err 2'<span>)\n})</span></pre></div><p><code>then</code>还是和之前一样，接收两个参数（函数），第一个在成功时（触发<code>resolve</code>）执行，第二个在失败时(触发<code>reject</code>)时执行。而且，<code>then</code>还可以进行链式操作。</p><p>以上就是 ES6 的<code>Promise</code>的基本使用演示。看完你可能会觉得，这跟之前讲述 jquery 的不差不多吗 ———— 对了，这就是我要在之前先讲 jquery 的原因，让你感觉一篇一篇看起来如丝般顺滑！</p><p>接下来，将详细说一下 ES6&nbsp;<code>Promise</code>&nbsp;的一些比较常见的用法，敬请期待吧！</p><p>&nbsp;</p><h3>第二部分，Promise 在 ES6 中的具体应用</h3><p>上一节对 ES6 的 Promise 有了一个最简单的介绍，这一节详细说一下 Promise 那些最常见的功能</p><h4>本节课程概述</h4><ul><li>准备工作</li><li>参数传递</li><li>异常捕获</li><li>串联多个异步操作</li><li><code>Promise.all</code>和<code>Promise.race</code>的应用</li><li><code>Promise.resolve</code>的应用</li><li>其他</li></ul><h4>准备工作</h4><p>因为以下所有的代码都会用到<code>Promise</code>，因此干脆在所有介绍之前，先封装一个<code>Promise</code>，封装一次，为下面多次应用。</p><div><pre>const fs = require('fs'<span>)\nconst path </span>= require('path')  <span>//</span><span> 后面获取文件路径时候会用到</span>\nconst readFilePromise = <span>function</span><span> (fileName) {\n    </span><span>return</span> <span>new</span> Promise((resolve, reject) =&gt;<span> {\n        fs.readFile(fileName, (err, data) </span>=&gt;<span> {\n            </span><span>if</span><span> (err) {\n                reject(err)  </span><span>//</span><span> 注意，这里执行 reject 是传递了参数，后面会有地方接收到这个参数</span>\n            } <span>else</span><span> {\n                resolve(data.toString())  </span><span>//</span><span> 注意，这里执行 resolve 时传递了参数，后面会有地方接收到这个参数</span>\n<span>            }\n        })\n    })\n}</span></pre></div><p>以上代码一个一段 nodejs 代码，将读取文件的函数<code>fs.readFile</code>封装为一个<code>Promise</code>。经过上一节的学习，我想大家肯定都能看明白代码的含义，要是看不明白，你就需要回炉重造了！</p><h4>参数传递</h4><p>我们要使用上面封装的<code>readFilePromise</code>读取一个 json 文件<code>../data/data2.json</code>，这个文件内容非常简单：<code>{\"a\":100, \"b\":200}</code></p><p>先将文件内容打印出来，代码如下。大家需要注意，<code>readFilePromise</code>函数中，执行<code>resolve(data.toString())</code>传递的参数内容，会被下面代码中的<code>data</code>参数所接收到。</p><div><div><pre>const fullFileName = path.resolve(__dirname, '../data/data2.json'<span>)\nconst result </span>=<span> readFilePromise(fullFileName)\nresult.then(data </span>=&gt;<span> {\n    console.log(data)\n})</span></pre></div></div><p>再加一个需求，在打印出文件内容之后，我还想看看<code>a</code>属性的值，代码如下。之前我们已经知道<code>then</code>可以执行链式操作，如果<code>then</code>有多步骤的操作，那么前面步骤<code>return</code>的值会被当做参数传递给后面步骤的函数，如下面代码中的<code>a</code>就接收到了<code>return JSON.parse(data).a</code>的值</p><div><pre>const fullFileName = path.resolve(__dirname, '../data/data2.json'<span>)\nconst result </span>=<span> readFilePromise(fullFileName)\nresult.then(data </span>=&gt;<span> {\n    </span><span>//</span><span> 第一步操作</span>\n<span>    console.log(data)\n    </span><span>return</span> JSON.parse(data).a  <span>//</span><span> 这里将 a 属性的值 return</span>\n}).then(a =&gt;<span> {\n    </span><span>//</span><span> 第二步操作</span>\n    console.log(a)  <span>//</span><span> 这里可以获取上一步 return 过来的值</span>\n})</pre></div><p>总结一下，这一段内容提到的“参数传递”其实有两个方面：</p><ul><li>执行<code>resolve</code>传递的值，会被第一个<code>then</code>处理时接收到</li><li>如果<code>then</code>有链式操作，前面步骤返回的值，会被后面的步骤获取到</li></ul><h4>异常捕获</h4><p>我们知道<code>then</code>会接收两个参数（函数），第一个参数会在执行<code>resolve</code>之后触发（还能传递参数），第二个参数会在执行<code>reject</code>之后触发（其实也可以传递参数，和<code>resolve</code>传递参数一样），但是上面的例子中，我们没有用到<code>then</code>的第二个参数。这是为何呢 ———— 因为不建议这么用。</p><p>对于<code>Promise</code>中的异常处理，我们建议用<code>catch</code>方法，而不是<code>then</code>的第二个参数。请看下面的代码，以及注释。</p><div><pre>const fullFileName = path.resolve(__dirname, '../data/data2.json'<span>)\nconst result </span>=<span> readFilePromise(fullFileName)\nresult.then(data </span>=&gt;<span> {\n    console.log(data)\n    </span><span>return</span><span> JSON.parse(data).a\n}).then(a </span>=&gt;<span> {\n    console.log(a)\n}).</span><span>catch</span>(err =&gt;<span> {\n    console.log(err.stack)  </span><span>//</span><span> 这里的 catch 就能捕获 readFilePromise 中触发的 reject ，而且能接收 reject 传递的参数</span>\n})</pre></div><p>在若干个<code>then</code>串联之后，我们一般会在最后跟一个<code>.catch</code>来捕获异常，而且执行<code>reject</code>时传递的参数也会在<code>catch</code>中获取到。这样做的好处是：</p><ul><li>让程序看起来更加简洁，是一个串联的关系，没有分支（如果用<code>then</code>的两个参数，就会出现分支，影响阅读）</li><li>看起来更像是<code>try - catch</code>的样子，更易理解</li></ul><h4>串联多个异步操作</h4><p>如果现在有一个需求：先读取<code>data2.json</code>的内容，当成功之后，再去读取<code>data1.json</code>。这样的需求，如果用传统的<code>callback</code>去实现，会变得很麻烦。而且，现在只是两个文件，如果是十几个文件这样做，写出来的代码就没法看了（臭名昭著的<code>callback-hell</code>）。但是用刚刚学到的<code>Promise</code>就可以轻松胜任这项工作</p><div><pre>const fullFileName2 = path.resolve(__dirname, '../data/data2.json'<span>)\nconst result2 </span>=<span> readFilePromise(fullFileName2)\nconst fullFileName1 </span>= path.resolve(__dirname, '../data/data1.json'<span>)\nconst result1 </span>=<span> readFilePromise(fullFileName1)\n\nresult2.then(data </span>=&gt;<span> {\n    console.log(</span>'data2.json'<span>, data)\n    </span><span>return</span> result1  <span>//</span><span> 此处只需返回读取 data1.json 的 Promise 即可</span>\n}).then(data =&gt;<span> {\n    console.log(</span>'data1.json', data) <span>//</span><span> data 即可接收到 data1.json 的内容</span>\n})</pre></div><p>上文“参数传递”提到过，如果<code>then</code>有链式操作，前面步骤返回的值，会被后面的步骤获取到。但是，如果前面步骤返回值是一个<code>Promise</code>的话，情况就不一样了 ———— 如果前面返回的是<code>Promise</code>对象，后面的<code>then</code>将会被当做这个返回的<code>Promise</code>的第一个<code>then</code>来对待&nbsp;———— 如果你这句话看不懂，你需要将“参数传递”的示例代码和这里的示例代码联合起来对比着看，然后体会这句话的意思。</p><h4><code>Promise.all</code>和<code>Promise.race</code>的应用</h4><p>我还得继续提出更加奇葩的需求，以演示<code>Promise</code>的各个常用功能。如下需求：</p><p>读取两个文件<code>data1.json</code>和<code>data2.json</code>，现在我需要一起读取这两个文件，等待它们全部都被读取完，再做下一步的操作。此时需要用到<code>Promise.all</code></p><div><div><pre><span>//</span><span> Promise.all 接收一个包含多个 promise 对象的数组</span>\nPromise.all([result1, result2]).then(datas =&gt;<span> {\n    </span><span>//</span><span> 接收到的 datas 是一个数组，依次包含了多个 promise 返回的内容</span>\n    console.log(datas[0<span>])\n    console.log(datas[</span>1<span>])\n})</span></pre></div></div><p>读取两个文件<code>data1.json</code>和<code>data2.json</code>，现在我需要一起读取这两个文件，但是只要有一个已经读取了，就可以进行下一步的操作。此时需要用到<code>Promise.race</code></p><div><div><pre><span>//</span><span> Promise.race 接收一个包含多个 promise 对象的数组</span>\nPromise.race([result1, result2]).then(data =&gt;<span> {\n    </span><span>//</span><span> data 即最先执行完成的 promise 的返回值</span>\n<span>    console.log(data)\n})</span></pre></div></div><h4><code>Promise.resolve</code>的应用</h4><p>从 jquery 引出，到此即将介绍完 ES6 的<code>Promise</code>，现在我们再回归到 jquery 。</p><p>大家都是到 jquery v1.5 之后<code>$.ajax()</code>返回的是一个<code>deferred</code>对象，而这个<code>deferred</code>对象和我们现在正在学习的<code>Promise</code>对象已经很接近了，但是还不一样。那么 ————&nbsp;<code>deferred</code>对象能否转换成 ES6 的<code>Promise</code>对象来使用？？</p><p>答案是能！需要使用<code>Promise.resolve</code>来实现这一功能，请看以下代码：</p><div><div><pre><span>//</span><span> 在浏览器环境下运行，而非 node 环境</span>\ncosnt jsPromise = Promise.resolve($.ajax('/whatever.json'<span>))\njsPromise.then(data </span>=&gt;<span> {\n    </span><span>//</span><span> ...</span>\n})</pre></div></div><p>注意：这里的<code>Promise.resolve</code>和文章最初<code>readFilePromise</code>函数内部的<code>resolve</code>函数可千万不要混了，完全是两码事儿。JS 基础好的同学一看就明白，而这里看不明白的同学，要特别注意。</p><p>实际上，并不是<code>Promise.resolve</code>对 jquery 的<code>deferred</code>对象做了特殊处理，而是<code>Promise.resolve</code>能够将<code>thenable</code>对象转换为<code>Promise</code>对象。什么是<code>thenable</code>对象？———— 看个例子</p><div><pre><span>//</span><span> 定义一个 thenable 对象</span>\nconst thenable =<span> {\n    </span><span>//</span><span> 所谓 thenable 对象，就是具有 then 属性，而且属性值是如下格式函数的对象</span>\n    then: (resolve, reject) =&gt;<span> {\n        resolve(</span>200<span>)\n    }\n}\n\n</span><span>//</span><span> thenable 对象可以转换为 Promise 对象</span>\nconst promise =<span> Promise.resolve(thenable)\npromise.then(data </span>=&gt;<span> {\n    </span><span>//</span><span> ...</span>\n})</pre></div><p>上面的代码就将一个<code>thenalbe</code>对象转换为一个<code>Promise</code>对象，只不过这里没有异步操作，所有的都会同步执行，但是不会报错的。</p><p>其实，在我们的日常开发中，这种将<code>thenable</code>转换为<code>Promise</code>的需求并不多。真正需要的是，将一些异步操作函数（如<code>fs.readFile</code>）转换为<code>Promise</code>（就像文章一开始<code>readFilePromise</code>做的那样）。这块，我们后面会在介绍<code>Q.js</code>库时，告诉大家一个简单的方法。</p><h4>其他</h4><p>以上都是一些日常开发中非常常用的功能，其他详细的介绍，请参考阮一峰老师的&nbsp;<a target=\"_blank\" href=\"http://es6.ruanyifeng.com/#docs/promise\">ES6 教程 Promise 篇</a></p><p>最后，本节我们只是介绍了<code>Promise</code>的一些应用，通俗易懂拿来就用的东西，但是没有提升到理论和标准的高度。有人可能会不屑 ———— 我会用就行了，要那么空谈的理论干嘛？————&nbsp;你只会使用却上升不到理论高度，永远都是个搬砖的，搬一块砖挣一毛钱，不搬就不挣钱！&nbsp;在我看来，所有的知识应该都需要上升到理论高度，将实际应用和标准对接，知道真正的出处，才能走的长远。</p><p>下一节我们介绍 Promise/A+ 规范</p><p>&nbsp;</p><h3>第三部分，对标一下 Promise/A+ 规范</h3><p>Promise/A 是由 CommonJS 组织制定的异步模式编程规范，后来又经过一些升级，就是当前的 Promise/A+ 规范。上一节讲述的<code>Promise</code>的一些功能实现，就是根据这个规范来的。</p><h4>本节内容概述</h4><ul><li>介绍规范的核心内容</li><li>状态变化</li><li><code>then</code>方法</li><li>接下来...</li></ul><h4>介绍规范的核心内容</h4><p>网上有很多介绍 Promise/A+ 规范的文章，大家可以搜索来看，但是它的核心要点有以下几个，我也是从看了之后自己总结的</p><p>关于状态</p><ul><li>promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）</li><li>promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换</li></ul><p>关于<code>then</code>方法</p><ul><li>promise 必须实现<code>then</code>方法，而且<code>then</code>必须返回一个 promise ，同一个 promise 的<code>then</code>可以调用多次（链式），并且回调的执行顺序跟它们被定义时的顺序一致</li><li><code>then</code>方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用</li></ul><p>下面挨个介绍这些规范在上一节代码中的实现，所谓理论与实践相结合。在阅读以下内容时，你要时刻准备参考上一节的代码。</p><h4>状态变化</h4><blockquote><p><strong>promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）</strong></p></blockquote><p>拿到上一节的<code>readFilePromise</code>函数，然后执行<code>const result = readFilePromise(someFileName)</code>会得到一个<code>Promise</code>对象。</p><ul><li>刚刚创建时，就是 等待（pending）状态</li><li>如果读取文件成功了，<code>readFilePromise</code>函数内部的<code>callback</code>中会自定调用<code>resolve()</code>，这样就变为 已完成（fulfilled）状态</li><li>如果很不幸读取文件失败了（例如文件名写错了，找不到文件），<code>readFilePromise</code>函数内部的<code>callback</code>中会自定调用<code>reject()</code>，这样就变为 已拒绝（rejeced）状态</li></ul><blockquote><p><strong>promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换</strong></p></blockquote><p>这个规则还是可以参考读取文件的这个例子。从一开始准备读取，到最后无论是读取成功或是读取失败，都是不可逆的。另外，读取成功和读取失败之间，也是不能互换的。这个逻辑没有任何问题，很好理解。</p><h4><code>then</code>方法</h4><blockquote><p><strong>promise 必须实现<code>then</code>方法，而且<code>then</code>必须返回一个 promise ，同一个 promise 的<code>then</code>可以调用多次（链式），并且回调的执行顺序跟它们被定义时的顺序一致</strong></p></blockquote><ul><li><code>promise</code>对象必须实现<code>then</code>方法这个无需解释，没有<code>then</code>那就不叫<code>promise</code></li><li>“而且<code>then</code>必须返回一个<code>promise</code>，同一个 promise 的<code>then</code>可以调用多次（链式）” ———— 这两句话说明了一个意思 ————&nbsp;<code>then</code>肯定要再返回一个<code>promise</code>，要不然<code>then</code>后面怎么能再链式的跟一个<code>then</code>呢？</li></ul><blockquote><p><strong><code>then</code>方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用</strong></p></blockquote><p>这句话比较好理解了，我们从一开始就在 demo 中演示。</p><h4>接下来...</h4><p><code>Promise</code>的应用、规范都介绍完了，看起来挺牛的，也解决了异步操作中使用<code>callback</code>带来的很多问题。但是<code>Promise</code>本质上到底是一种什么样的存在，它是真的把<code>callback</code>弃而不用了吗，还是两者有什么合作关系？它到底是真的神通广大，还是使用了障眼法？</p><p>这些问题，大家学完<code>Promise</code>之后应该去思考，不能光学会怎么用就停止了。下一节我们一起来探讨~</p><p>&nbsp;</p><h3>第四部分，Promise 真的取代 callback 了吗</h3><p>Promise 虽然改变了 JS 工程师对于异步操作的写法，但是却改变不了 JS 单线程、异步的执行模式。</p><h4>本节概述</h4><ul><li>JS 异步的本质</li><li>Promise 只是表面的写法上的改变</li><li>Promise 中不能缺少 callback</li><li>接下来...</li></ul><h4>JS 异步的本质</h4><p>从最初的 ES3、4 到 ES5 再到现在的 ES6 和即将到来的 ES7，语法标准上更新很多，但是 JS 这种单线程、异步的本质是没有改变的。nodejs 中读取文件的代码一直都可以这样写</p><div><div><pre>fs.readFile('some.json', (err, data) =&gt;<span> {\n})</span></pre></div></div><p>既然异步这个本质不能改变，伴随异步在一起的永远都会有<code>callback</code>，因为没有<code>callback</code>就无法实现异步。因此<code>callback</code>永远存在。</p><h4>Promise 只是表面的写法上的改变</h4><p>JS 工程师不会讨厌 JS 异步的本质，但是很讨厌 JS 异步操作中<code>callback</code>的书写方式，特别是遇到万恶的<code>callback-hell</code>（嵌套<code>callback</code>）时。</p><p>计算机的抽象思维和人的具象思维是完全不一样的，人永远喜欢看起来更加符合逻辑、更加易于阅读的程序，因此现在特别强调代码可读性。而<code>Promise</code>就是一种代码可读性的变化。大家感受一下这两种不同（这其中还包括异常处理，加上异常处理会更加复杂）</p><p>第一种，传统的<code>callback</code>方式</p><div><pre>fs.readFile('some1.json', (err, data) =&gt;<span> {\n    fs.readFile(</span>'some2.json', (err, data) =&gt;<span> {\n        fs.readFile(</span>'some3.json', (err, data) =&gt;<span> {\n            fs.readFile(</span>'some4.json', (err, data) =&gt;<span> {\n\n            })\n        })\n    })\n})</span></pre></div><p>第二种，<code>Promise</code>方式</p><div><pre>readFilePromise('some1.json').then(data =&gt;<span> {\n    </span><span>return</span> readFilePromise('some2.json'<span>)\n}).then(data </span>=&gt;<span> {\n    </span><span>return</span> readFilePromise('some3.json'<span>)\n}).then(data </span>=&gt;<span> {\n    </span><span>return</span> readFilePromise('some4.json'<span>)\n})</span></pre></div><p>这两种方式对于代码可读性的对比，非常明显。但是最后再次强调，<code>Promise</code>只是对于异步操作代码可读性的一种变化，它并没有改变 JS 异步执行的本质，也没有改变 JS 中存在<code>callback</code>的现象。</p><h4>Promise 中不能缺少 callback</h4><p>上文已经基本给出了上一节提问的答案，但是这里还需要再加一个补充：<code>Promise</code>不仅仅是没有取代<code>callback</code>或者弃而不用，反而<code>Promise</code>中要使用到<code>callback</code>。因为，JS 异步执行的本质，必须有<code>callback</code>存在，否则无法实现。</p><p>再次粘贴处之前章节的封装好的一个<code>Promise</code>函数（进行了一点点简化）</p><div><pre>const readFilePromise = <span>function</span><span> (fileName) {\n    </span><span>return</span> <span>new</span> Promise((resolve, reject) =&gt;<span> {\n        fs.readFile(fileName, (err, data) </span>=&gt;<span> {\n            resolve(data.toString())\n        })\n    })\n}</span></pre></div><p>上面的代码中，<code>promise</code>对象的状态要从<code>pending</code>变化为<code>fulfilled</code>，就需要去执行<code>resolve()</code>函数。那么是从哪里执行的 ————&nbsp;还得从<code>callback</code>中执行<code>resolve</code>函数 ———— 这就是<code>Promise</code>也需要<code>callback</code>的最直接体现。</p><h4>接下来...</h4><p>一块技术“火”的程度和第三方开源软件的数量、质量以及使用情况有很大的正比关系。例如为了简化 DOM 操作，jquery 风靡全世界。Promise 用的比较多，第三方库当然就必不可少，它们极大程度的简化了 Promise 的代码。</p><p>接下来我们一起看看<code>Q.js</code>这个库的使用，学会了它，将极大程度提高你写 Promise 的效率。</p><p>&nbsp;</p><h3>第五部分，使用 Q.js 库</h3><p>如果实际项目中使用<code>Promise</code>，还是强烈建议使用比较靠谱的第三方插件，会极大增加你的开发效率。除了将要介绍的<code>Q.js</code>，还有<code>bluebird</code>也推荐使用，去 github 自行搜索吧。</p><p>另外，使用第三方库不仅仅是提高效率，它还让你在浏览器端（不支持<code>Promise</code>的环境中）使用<code>promise</code>。</p><h4>本节内容概述</h4><ul><li>下载和安装</li><li>使用<code>Q.nfcall</code>和<code>Q.nfapply</code></li><li>使用<code>Q.defer</code></li><li>使用<code>Q.denodeify</code></li><li>使用<code>Q.all</code>和<code>Q.any</code></li><li>使用<code>Q.delay</code></li><li>其他</li></ul><h4>下载和安装</h4><p>可以直接去它的&nbsp;<a target=\"_blank\" href=\"https://github.com/kriskowal/q\">github 地址</a>&nbsp;（近 1.3W 的 star 数量说明其用户群很大）查看文档。</p><p>如果项目使用 CommonJS 规范直接&nbsp;<code>npm i q --save</code>，如果是网页外链可寻找可用的 cdn 地址，或者干脆下载到本地。</p><p>以下我将要演示的代码，都是使用 CommonJS 规范的，因此我要演示代码之前加上引用，以后的代码演示就不重复加了。</p><div><div><pre>const Q = require('q')</pre></div></div><h4>使用<code>Q.nfcall</code>和<code>Q.nfapply</code></h4><p>要使用这两个函数，你得首先了解 JS 的<code>call</code>和<code>apply</code>，如果不了解，先去看看。熟悉了这两个函数之后，再回来看。</p><p><code>Q.nfcall</code>就是使用<code>call</code>的语法来返回一个<code>promise</code>对象，例如</p><div><pre>const fullFileName = path.resolve(__dirname, '../data/data1.json'<span>)\nconst result </span>= Q.nfcall(fs.readFile, fullFileName, 'utf-8')  <span>//</span><span> 使用 Q.nfcall 返回一个 promise</span>\nresult.then(data =&gt;<span> {\n    console.log(data)\n}).</span><span>catch</span>(err =&gt;<span> {\n    console.log(err.stack)\n})</span></pre></div><p><code>Q.nfapply</code>就是使用<code>apply</code>的语法返回一个<code>promise</code>对象，例如</p><div><pre>const fullFileName = path.resolve(__dirname, '../data/data1.json'<span>)\nconst result </span>= Q.nfapply(fs.readFile, [fullFileName, 'utf-8'])  <span>//</span><span> 使用 Q.nfapply 返回一个 promise</span>\nresult.then(data =&gt;<span> {\n    console.log(data)\n}).</span><span>catch</span>(err =&gt;<span> {\n    console.log(err.stack)\n})</span></pre></div><p>怎么样，体验了一把，是不是比直接自己写<code>Promise</code>简单多了？</p><h4>使用<code>Q.defer</code></h4><p><code>Q.defer</code>算是一个比较偏底层一点的 API ，用于自己定义一个<code>promise</code>生成器，如果你需要在浏览器端编写，而且浏览器不支持<code>Promise</code>，这个就有用处了。</p><div><pre><span>function</span><span> readFile(fileName) {\n    const defer </span>=<span> Q.defer()\n    fs.readFile(fileName, (err, data) </span>=&gt;<span> {\n        </span><span>if</span><span> (err) {\n            defer.reject(err)\n        } </span><span>else</span><span> {\n            defer.resolve(data.toString())\n        }\n    })\n    </span><span>return</span><span> defer.promise\n}\nreadFile(</span>'data1.json'<span>)\n    .then(data </span>=&gt;<span> {\n        console.log(data)\n    })\n    .</span><span>catch</span>(err =&gt;<span> {\n        console.log(err.stack)\n    })</span></pre></div><h4>使用<code>Q.denodeify</code></h4><p>我们在很早之前的一节中自己封装了一个<code>fs.readFile</code>的<code>promise</code>生成器，这里再次回顾一下</p><div><pre>const readFilePromise = <span>function</span><span> (fileName) {\n    </span><span>return</span> <span>new</span> Promise((resolve, reject) =&gt;<span> {\n        fs.readFile(fileName, (err, data) </span>=&gt;<span> {\n            </span><span>if</span><span> (err) {\n                reject(err)\n            } </span><span>else</span><span> {\n                resolve(data.toString())\n            }\n        })\n    })\n}</span></pre></div><p>虽然看着不麻烦，但是还是需要很多行代码来实现，如果使用<code>Q.denodeify</code>，一行代码就搞定了！</p><div><div><pre>const readFilePromise = Q.denodeify(fs.readFile)</pre></div></div><p><code>Q.denodeif</code>就是一键将<code>fs.readFile</code>这种有回调函数作为参数的异步操作封装成一个<code>promise</code>生成器，非常方便！</p><h4>使用<code>Q.all</code>和<code>Q.any</code></h4><p>这两个其实就是对应了之前讲过的<code>Promise.all</code>和<code>Promise.race</code>，而且应用起来一模一样，不多赘述。</p><div><pre>const r1 = Q.nfcall(fs.readFile, 'data1.json', 'utf-8'<span>)\nconst r2 </span>= Q.nfcall(fs.readFile, 'data2.json', 'utf-8'<span>)\nQ.all([r1, r2]).then(arr </span>=&gt;<span> {\n    console.log(arr)\n}).</span><span>catch</span>(err =&gt;<span> {\n    console.log(err)\n})</span></pre></div><h4>使用<code>Q.delay</code></h4><p><code>Q.delay</code>，顾名思义，就是延迟的意思。例如，读取一个文件成功之后，再过五秒钟之后，再去做xxxx。这个如果是自己写的话，也挺费劲的，但是<code>Q.delay</code>就直接给我们分装好了。</p><div><pre>const result = Q.nfcall(fs.readFile, 'data1.json', 'utf-8'<span>)\nresult.delay(</span>5000).then(data =&gt;<span> {\n    </span><span>//</span><span> 得到结果</span>\n<span>    console.log(data.toString())\n}).</span><span>catch</span>(err =&gt;<span> {\n    </span><span>//</span><span> 捕获错误</span>\n<span>    console.log(err.stack)\n})</span></pre></div><h4>其他</h4><p>以上就是<code>Q.js</code>一些最常用的操作，其他的一些非常用技巧，大家可以去搜索或者去官网查看文档。</p><p>至此，ES6&nbsp;<code>Promise</code>的所有内容就已经讲完了。但是异步操作的优化到这里没有结束，更加精彩的内容还在后面 ————&nbsp;<code>Generator</code></p>"}}
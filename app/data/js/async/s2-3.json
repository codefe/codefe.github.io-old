{"sta":1,"data":{"subTitle":"ES6 中的 Generator","content":"<h3>第一部分，ES6 中的 Generator</h3><p>在 ES6 出现之前，基本都是各式各样类似<code>Promise</code>的解决方案来处理异步操作的代码逻辑，但是 ES6 的<code>Generator</code>却给异步操作又提供了新的思路，马上就有人给出了如何用<code>Generator</code>来更加优雅的处理异步操作。</p><h4>本节内容概述</h4><ul><li><code>Generator</code>简介</li><li><code>Generator</code>最终如何处理异步操作</li><li>接下来...</li></ul><h4><code>Generator</code>简介</h4><p>先来一段最基础的<code>Generator</code>代码</p><div><pre><span>function</span>*<span> Hello() {\n    yield </span>100<span>\n    yield (</span><span>function</span> () {<span>return</span> 200<span>})()\n    </span><span>return</span> 300<span>\n}\n\n</span><span>var</span> h =<span> Hello()\nconsole.log(</span><span>typeof</span> h)  <span>//</span><span> object</span>\n<span>\nconsole.log(h.next())  </span><span>//</span><span> { value: 100, done: false }</span>\nconsole.log(h.next())  <span>//</span><span> { value: 200, done: false }</span>\nconsole.log(h.next())  <span>//</span><span> { value: 300, done: true }</span>\nconsole.log(h.next())  <span>//</span><span> { value: undefined, done: true }</span></pre></div><p>在 nodejs 环境执行这段代码，打印出来的数据都在代码注释中了，也可以自己去试试。将这段代码简单分析一下吧</p><ul><li>定义<code>Generator</code>时，需要使用<code>function*</code>，其他的和定义函数一样。内部使用<code>yield</code>，至于<code>yield</code>的用处以后再说</li><li>执行<code>var h = Hello()</code>生成一个<code>Generator</code>对象，经验验证<code>typeof h</code>发现不是普通的函数</li><li>执行<code>Hello()</code>之后，<code>Hello</code>内部的代码不会立即执行，而是出于一个暂停状态</li><li>执行第一个<code>h.next()</code>时，会激活刚才的暂停状态，开始执行<code>Hello</code>内部的语句，但是，直到遇到<code>yield</code>语句。一旦遇到<code>yield</code>语句时，它就会将<code>yield</code>后面的表达式执行，并返回执行的结果，然后又立即进入暂停状态。</li><li>因此第一个<code>console.log(h.next())</code>打印出来的是<code>{ value: 100, done: false }</code>，<code>value</code>是第一个<code>yield</code>返回的值，<code>done: false</code>表示目前处于暂停状态，尚未执行结束，还可以再继续往下执行。</li><li>执行第二个<code>h.next()</code>和第一个一样，不在赘述。此时会执行完第二个<code>yield</code>后面的表达式并返回结果，然后再次进入暂停状态</li><li>执行第三个<code>h.next()</code>时，程序会打破暂停状态，继续往下执行，但是遇到的不是<code>yield</code>而是<code>return</code>。这就预示着，即将执行结束了。因此最后返回的是<code>{ value: 300, done: true }</code>，<code>done: true</code>表示执行结束，无法再继续往下执行了。</li><li>再去执行第四次<code>h.next()</code>时，就只能得到<code>{ value: undefined, done: true }</code>，因为已经结束，没有返回值了。</li></ul><p>一口气分析下来，发现并不是那么简单，虽然这只是一个最最简单的<code>Generator</code>入门代码 ———— 可见<code>Generator</code>的学习成本多高 ———— 但是一旦学会，那将受用无穷！别着急，跟着我的节奏慢慢来，一行一行代码看，你会很快深入了解<code>Genarator</code></p><p>但是，你要详细看一下上面的所有步骤，争取把我写的每一步都搞明白。如果搞不明白细节，至少要明白以下几个要点：</p><ul><li><code>Generator</code>不是函数，不是函数，不是函数</li><li><code>Hello()</code>不会立即出发执行，而是一上来就暂停</li><li>每次<code>h.next()</code>都会打破暂停状态去执行，直到遇到下一个<code>yield</code>或者<code>return</code></li><li>遇到<code>yield</code>时，会执行<code>yeild</code>后面的表达式，并返回执行之后的值，然后再次进入暂停状态，此时<code>done: false</code>。</li><li>遇到<code>return</code>时，会返回值，执行结束，即<code>done: true</code></li><li>每次<code>h.next()</code>的返回值永远都是<code>{value: ... , done: ...}</code>的形式</li></ul><h4><code>Generator</code>最终如何处理异步操作</h4><p>上面只是一个最基本最简单的介绍，但是我们看不到任何与异步操作相关的事情，那我们接下来就先展示一下最终我们将使用<code>Generator</code>如何做异步操作。</p><p>之前讲解<code>Promise</code>时候，依次读取多个文件，我们是这么操作的（看不明白的需要回炉重造哈），主要是使用<code>then</code>做链式操作。</p><div><pre>readFilePromise('some1.json').then(data =&gt;<span> {\n    console.log(data)  </span><span>//</span><span> 打印第 1 个文件内容</span>\n    <span>return</span> readFilePromise('some2.json'<span>)\n}).then(data </span>=&gt;<span> {\n    console.log(data)  </span><span>//</span><span> 打印第 2 个文件内容</span>\n    <span>return</span> readFilePromise('some3.json'<span>)\n}).then(data </span>=&gt;<span> {\n    console.log(data)  </span><span>//</span><span> 打印第 3 个文件内容</span>\n    <span>return</span> readFilePromise('some4.json'<span>)\n}).then(data</span>=&gt;<span> {\n    console.log(data)  </span><span>//</span><span> 打印第 4 个文件内容</span>\n})</pre></div><p>而如果学会<code>Generator</code>那么读取多个文件就是如下这样写。先不要管如何实现的，光看一看代码，你就能比较出哪个更加简洁、更加易读、更加所谓的优雅！</p><div><pre>co(<span>function</span>*<span> () {\n    const r1 </span>= yield readFilePromise('some1.json'<span>)\n    console.log(r1)  </span><span>//</span><span> 打印第 1 个文件内容</span>\n    const r2 = yield readFilePromise('some2.json'<span>)\n    console.log(r2)  </span><span>//</span><span> 打印第 2 个文件内容</span>\n    const r3 = yield readFilePromise('some3.json'<span>)\n    console.log(r3)  </span><span>//</span><span> 打印第 3 个文件内容</span>\n    const r4 = yield readFilePromise('some4.json'<span>)\n    console.log(r4)  </span><span>//</span><span> 打印第 4 个文件内容</span>\n})</pre></div><p>不过，要学到这一步，还需要很长的路要走。不过不要惊慌，也不要请如来佛祖，跟着我的节奏来，认真看，一天包教包会是没问题的！</p><h4>接下来...</h4><p>接下来我们不会立刻讲解如何使用<code>Generator</code>做异步操作，而是看一看<code>Generator</code>是一个什么东西！说来话长，这要从 ES6 的另一个概念<code>Iterator</code>说起。</p><h1>第二部分，Iterator 遍历器</h1><p>ES6 中引入了很多此前没有但是却非常重要的概念，<code>Iterator</code>就是其中一个。<code>Iterator</code>对象是一个指针对象，实现类似于单项链表的数据结构，通过<code>next()</code>将指针指向下一个节点 ———— 这里也就是先简单做一个概念性的介绍，后面将通过实例为大家演示。</p><h4>本节内容概述</h4><ul><li>简介<code>Symbol</code>数据类型</li><li>具有<code>[Symbol.iterator]</code>属性的数据类型</li><li>生成<code>Iterator</code>对象</li><li><code>Generator</code>返回的也是<code>Iterator</code>对象</li><li>接下来...</li></ul><h4>简介<code>Symbol</code>数据类型</h4><p><code>Symbol</code>是一个特殊的数据类型，和<code>number</code>&nbsp;<code>string</code>等并列，详细的教程可参考<a target=\"_blank\" href=\"http://es6.ruanyifeng.com/#docs/symbol\">阮一峰老师 ES6 入门的 Symbol 篇</a>。先看两句程序</p><div><div><pre>console.log(Array.prototype.slice)  <span>//</span><span> [Function: slice]</span>\nconsole.log(Array.prototype[Symbol.iterator])  <span>//</span><span> [Function: values]</span></pre></div></div><p>数组的<code>slice</code>属性大家都比较熟悉了，就是一个函数，可以通过<code>Array.prototype.slice</code>得到。这里的<code>slice</code>是一个字符串，但是我们获取<code>Array.prototype[Symbol.iterator]</code>可以得到一个函数，只不过这里的<code>[Symbol.iterator]</code>是<code>Symbol</code>数据类型，不是字符串。但是没关系，<code>Symbol</code>数据类型也可以作为对象属性的<code>key</code>。如下：</p><div><div><pre><span>var</span> obj =<span> {}\nobj.a </span>= 100<span>\nobj[Symbol.iterator] </span>= 200<span>\nconsole.log(obj)  </span><span>//</span><span> {a: 100, Symbol(Symbol.iterator): 200}</span></pre></div></div><p>在此小节中，你只需要知道<code>[Symbol.iterator]</code>是一个特殊的数据类型<code>Symbol</code>类型，但是也可以像<code>number</code>&nbsp;<code>string</code>类型一样，作为对象的属性<code>key</code>来使用</p><h4>原生具有<code>[Symbol.iterator]</code>属性的数据类型</h4><p>在 ES6 中，原生具有<code>[Symbol.iterator]</code>属性数据类型有：数组、某些类似数组的对象（如<code>arguments</code>、<code>NodeList</code>）、<code>Set</code>和<code>Map</code>。其中，<code>Set</code>和<code>Map</code>也是 ES6 中新增的数据类型。</p><div><div><pre><span>//</span><span> 数组</span>\nconsole.log([1, 2, 3][Symbol.iterator])  <span>//</span><span> function values() { [native code] }</span><span>\n//</span><span> 某些类似数组的对象，NoeList</span>\nconsole.log(document.getElementsByTagName('div')[Symbol.iterator])  <span>//</span><span> function values() { [native code] }</span></pre></div></div><p>原生具有<code>[Symbol.iterator]</code>属性数据类型有一个特点，就是可以使用<code>for...of</code>来取值，例如</p><div><div><pre><span>var</span><span> item\n</span><span>for</span> (item of [100, 200, 300<span>]) {\n    console.log(item)\n}\n</span><span>//</span><span> 打印出：100 200 300 </span><span>\n//</span><span> 注意，这里每次获取的 item 是数组的 value，而不是 index ，这一点和 传统 for 循环以及 for...in 完全不一样</span></pre></div></div><p>而具有<code>[Symbol.iterator]</code>属性的对象，都可以一键生成一个<code>Iterator</code>对象。如何生成以及生成之后什么样子，还有生成之后的作用，下文分解。</p><p>不要着急，也不要跳过本文的任何步骤，一步一步跟着我的节奏来看。</p><h4>生成<code>Iterator</code>对象</h4><p>定义一个数组，然后生成数组的<code>Iterator</code>对象</p><div><div><pre>const arr = [100, 200, 300<span>]\nconst iterator </span>= arr[Symbol.iterator]()  <span>//</span><span> 通过执行 [Symbol.iterator] 的属性值（函数）来返回一个 iterator 对象</span></pre></div></div><p>好，现在生成了<code>iterator</code>，那么该如何使用它呢 ———— 有两种方式：<code>next</code>和<code>for...of</code>。</p><p>先说第一种，<code>next</code></p><div><div><pre>console.log(iterator.next())  <span>//</span><span> { value: 100, done: false }</span>\nconsole.log(iterator.next())  <span>//</span><span> { value: 200, done: false }</span>\nconsole.log(iterator.next())  <span>//</span><span> { value: 300, done: false }</span>\nconsole.log(iterator.next())  <span>//</span><span> { value: undefined, done: true }</span></pre></div></div><p>看到这里，再结合上一节内容，是不是似曾相识的感觉？(额，没有的话，那你就回去重新看上一节的内容吧)&nbsp;<code>iterator</code>对象可以通过<code>next()</code>方法逐步获取每个元素的值，以<code>{ value: ..., done: ... }</code>形式返回，<code>value</code>就是值，<code>done</code>表示是否到已经获取完成。</p><p>再说第二种，<code>for...of</code></p><div><div><pre><span>let i\n</span><span>for</span><span> (i of iterator) {\n    console.log(i)\n}\n</span><span>//</span><span> 打印：100 200 300 </span></pre></div></div><p>上面使用<code>for...of</code>遍历<code>iterator</code>对象，可以直接将其值获取出来。这里的“值”就对应着上面<code>next()</code>返回的结果的<code>value</code>属性</p><h4><code>Generator</code>返回的也是<code>Iterator</code>对象</h4><p>看到这里，你大体也应该明白了，上一节演示的<code>Generator</code>，就是生成一个<code>Iterator</code>对象。因此才会有<code>next()</code>，也可以通过<code>for...of</code>来遍历。拿出上一节的例子再做一次演示：</p><div><pre><span>function</span>*<span> Hello() {\n    yield </span>100<span>\n    yield (</span><span>function</span> () {<span>return</span> 200<span>})()\n    </span><span>return</span> 300<span> \n}\nconst h </span>=<span> Hello()\nconsole.log(h[Symbol.iterator])  </span><span>//</span><span> [Function: [Symbol.iterator]]</span></pre></div><p>执行<code>const h = Hello()</code>得到的就是一个<code>iterator</code>对象，因为<code>h[Symbol.iterator]</code>是有值的。既然是<code>iterator</code>对象，那么就可以使用<code>next()</code>和<code>for...of</code>进行操作</p><div><pre>console.log(h.next())  <span>//</span><span> { value: 100, done: false }</span>\nconsole.log(h.next())  <span>//</span><span> { value: 200, done: false }</span>\nconsole.log(h.next())  <span>//</span><span> { value: 300, done: false }</span>\nconsole.log(h.next())  <span>//</span><span> { value: undefined, done: true }</span>\n<span>\nlet i\n</span><span>for</span><span> (i of h) {\n    console.log(i)\n}</span></pre></div><h4>接下来...</h4><p>这一节我们花费很大力气，从<code>Iterator</code>又回归到了<code>Generator</code>，目的就是为了看看<code>Generator</code>到底是一个什么东西。了解其本质，才能更好的使用它，否则总有一种抓瞎的感觉。</p><p>接下来我们就<code>Generator</code>具体有哪些使用场景。</p><p>&nbsp;</p><h1>第三部分，Generator 的具体应用</h1><p>前面用两节的内容介绍了<code>Generator</code>可以让执行处于暂停状态，并且知道了<code>Generator</code>返回的是一个<code>Iterator</code>对象，这一节就详细介绍一下<code>Generator</code>的一些基本用法。</p><p>本节演示的代码可参考<a target=\"_blank\" href=\"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/test.js\">这里</a></p><h4>本节内容概述</h4><ul><li><code>next</code>和<code>yield</code>参数传递</li><li><code>for...of</code>的应用示例</li><li><code>yield*</code>语句</li><li><code>Generator</code>中的<code>this</code></li><li>接下来...</li></ul><h4><code>next</code>和<code>yield</code>参数传递</h4><p>我们之前已经知道，<code>yield</code>具有返回数据的功能，如下代码。<code>yield</code>后面的数据被返回，存放到返回结果中的<code>value</code>属性中。这算是一个方向的参数传递。</p><div><div><pre><span>function</span>*<span> G() {\n    yield </span>100<span>\n}\nconst g </span>=<span> G()\nconsole.log( g.next() ) </span><span>//</span><span> {value: 100, done: false}</span></pre></div></div><p>还有另外一个方向的参数传递，就是<code>next</code>向<code>yield</code>传递，如下代码。</p><div><pre><span>function</span>*<span> G() {\n    const a </span>= yield 100<span>\n    console.log(</span>'a', a)  <span>//</span><span> a aaa</span>\n    const b = yield 200<span>\n    console.log(</span>'b', b)  <span>//</span><span> b bbb</span>\n    const c = yield 300<span>\n    console.log(</span>'c', c)  <span>//</span><span> c ccc</span>\n<span>}\nconst g </span>=<span> G()\ng.next()    </span><span>//</span><span> value: 100, done: false</span>\ng.next('aaa') <span>//</span><span> value: 200, done: false</span>\ng.next('bbb') <span>//</span><span> value: 300, done: false</span>\ng.next('ccc') <span>//</span><span> value: undefined, done: true</span></pre></div><p>捋一捋上面代码的执行过程：</p><ul><li>执行第一个<code>g.next()</code>时，为传递任何参数，返回的<code>{value: 100, done: false}</code>，这个应该没有疑问</li><li>执行第二个<code>g.next('aaa')</code>时，传递的参数是<code>'aaa'</code>，这个<code>'aaa'</code>就会被赋值到<code>G</code>内部的<code>a</code>标量中，然后执行<code>console.log('a', a)</code>打印出来，最后返回<code>{value: 200, done: false}</code></li><li>执行第三个、第四个时，道理都是完全一样的，大家自己捋一捋。</li></ul><p>有一个要点需要注意，就<code>g.next('aaa')</code>是将<code>'aaa'</code>传递给上一个已经执行完了的<code>yield</code>语句前面的变量，而不是即将执行的<code>yield</code>前面的变量。这句话要能看明白，看不明白就说明刚才的代码你还没看懂，继续看。</p><h4><code>for...of</code>的应用示例</h4><p>针对<code>for...of</code>在<code>Iterator</code>对象的操作之前已经介绍过了，不过这里用一个非常好的例子来展示一下。用简单几行代码实现斐波那契数列。通过之前学过的<code>Generator</code>知识，应该不能解读这份代码。</p><div><pre><span>function</span>*<span> fibonacci() {\n    let [prev, curr] </span>= [0, 1<span>]\n    </span><span>for</span><span> (;;) {\n        [prev, curr] </span>= [curr, prev +<span> curr]\n        </span><span>//</span><span> 将中间值通过 yield 返回，并且保留函数执行的状态，因此可以非常简单的实现 fibonacci</span>\n<span>        yield curr\n    }\n}\n</span><span>for</span><span> (let n of fibonacci()) {\n    </span><span>if</span> (n &gt; 1000<span>) {\n        </span><span>break</span><span>\n    }\n    console.log(n)\n}</span></pre></div><h4><code>yield*</code>语句</h4><p>如果有两个<code>Generator</code>，想要在第一个中包含第二个，如下需求：</p><div><pre><span>function</span>*<span> G1() {\n    yield </span>'a'<span>\n    yield </span>'b'<span>\n}\n</span><span>function</span>*<span> G2() {\n    yield </span>'x'<span>\n    yield </span>'y'<span>\n}</span></pre></div><p>针对以上两个<code>Generator</code>，我的需求是：一次输出<code>a x y b</code>，该如何做？有同学看到这里想起了刚刚学到的<code>for..of</code>可以实现————不错，确实可以实现（大家也可以想想到底该如何实现）</p><p>但是，这要演示一个更加简洁的方式<code>yield*</code>表达式</p><div><pre><span>function</span>*<span> G1() {\n    yield </span>'a'<span>\n    yield</span>* G2()  <span>//</span><span> 使用 yield* 执行 G2()</span>\n    yield 'b'<span>\n}\n</span><span>function</span>*<span> G2() {\n    yield </span>'x'<span>\n    yield </span>'y'<span>\n}\n</span><span>for</span><span> (let item of G1()) {\n    console.log(item)\n}</span></pre></div><p>之前学过的<code>yield</code>后面会接一个普通的 JS 对象，而<code>yield*</code>后面会接一个<code>Generator</code>，而且会把它其中的<code>yield</code>按照规则来一步一步执行。如果有多个<code>Generator</code>串联使用的话（例如<code>Koa</code>源码中），用<code>yield*</code>来操作非常方便。</p><h4><code>Generator</code>中的<code>this</code></h4><p>对于以下这种写法，大家可能会和构造函数创建对象的写法产生混淆，这里一定要注意 ——&nbsp;Generator 不是函数，更不是构造函数</p><div><div><pre><span>function</span>*<span> G() {}\nconst g </span>= G()</pre></div></div><p>而以下这种写法，更加不会成功。只有构造函数才会这么用，构造函数返回的是<code>this</code>，而<code>Generator</code>返回的是一个<code>Iterator</code>对象。完全是两码事，千万不要搞混了。</p><div><div><pre><span>function</span>*<span> G() {\n    </span><span>this</span>.a = 10<span>\n}\nconst g </span>=<span> G()\nconsole.log(g.a) </span><span>//</span><span> 报错</span></pre></div></div><h4>接下来...</h4><p>本节基本介绍了<code>Generator</code>的最常见的用法，但是还是没有和咱们的最终目的————异步操作————沾上关系，而且现在看来有点八竿子打不着的关系。但是话说回来，这几节内容，你也学到了不少知识啊。</p><p>别急哈，即便是下一节，它们还不会有联系，再下一节就真相大白了。下一节我们又给出一个新概念————<code>Thunk</code>函数</p><p>&nbsp;</p><h1>第四部分，Thunk 函数</h1><p>要想让<code>Generator</code>和异步操作产生联系，就必须过<code>thunk</code>函数这一关。这一关过了之后，立即就可以着手异步操作的事情，因此大家再坚持坚持。至于<code>thunk</code>函数是什么，下文会详细演示。</p><p>本节演示的代码可参考<a  target=\"_blank\" href=\"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/test.js\">这里</a></p><h4>本节内容概述</h4><ul><li>一个普通的异步函数</li><li>封装成一个<code>thunk</code>函数</li><li><code>thunk</code>函数的特点</li><li>使用<code>thunkify</code>库</li><li>接下来...</li></ul><h4>一个普通的异步函数</h4><p>就用 nodejs 中读取文件的函数为例，通常都这么写</p><div><div><pre>fs.readFile('data1.json', 'utf-8', (err, data) =&gt;<span> {\n    </span><span>//</span><span> 获取文件内容</span>\n})</pre></div></div><p>其实这个写法就是将三个参数都传递给<code>fs.readFile</code>这个方法，其中最后一个参数是一个<code>callback</code>函数。这种函数叫做&nbsp;多参数函数，我们接下来做一个改造</p><h4>封装成一个<code>thunk</code>函数</h4><p>改造的代码如下所示。不过是不是感觉越改造越复杂了？不过请相信：你看到的复杂仅仅是表面的，这一点东西变的复杂，是为了让以后更加复杂的东西变得简单。对于个体而言，随性比较简单，遵守规则比较复杂；但是对于整体（包含很多个体）而言，大家都随性就不好控制了，而大家都遵守规则就很容易管理 ———— 就是这个道理!</p><div><pre>const thunk = <span>function</span><span> (fileName, codeType) {\n    </span><span>//</span><span> 返回一个只接受 callback 参数的函数</span>\n    <span>return</span> <span>function</span><span> (callback) {\n        fs.readFile(fileName, codeType, callback)\n    }\n}\nconst readFileThunk </span>= thunk('data1.json', 'utf-8'<span>)\nreadFileThunk((err, data) </span>=&gt;<span> {\n    </span><span>//</span><span> 获取文件内容</span>\n})</pre></div><p>先自己看一看以上代码，应该是能看懂的，但是你可能就是看懂了却不知道这么做的意义在哪里。意义先不管，先把它看懂，意义下一节就会看到。</p><ul><li>执行<code>const readFileThunk = thunk('data1.json', 'utf-8')</code>返回的其实是一个函数</li><li><code>readFileThunk</code>这个函数，只接受一个参数，而且这个参数是一个<code>callback</code>函数</li></ul><h4><code>thunk</code>函数的特点</h4><p>就上上面的代码，我们经过对传统的异步操作函数进行封装，得到一个只有一个参数的函数，而且这个参数是一个<code>callback</code>函数，那这就是一个<code>thunk</code>函数。就像上面代码中<code>readFileThunk</code>一样。</p><h4>使用<code>thunkify</code>库</h4><p>上面代码的封装，是我们手动来做的，但是没遇到一个情况就需要手动做吗？在这个开源的时代当让不会这样，直接使用第三方的<code>thunkify</code>就好了。</p><p>首先要安装<code>npm i thunkify --save</code>，然后在代码的最上方引用<code>const thunkify = require('thunkify')</code>。最后，上面我们手动写的代码，完全可以简化成这几行，非常简单！</p><div><div><pre>const thunk =<span> thunkify(fs.readFile)\nconst readFileThunk </span>= thunk('data1.json', 'utf-8'<span>)\nreadFileThunk((err, data) </span>=&gt;<span> {\n    </span><span>//</span><span> 获取文件内容</span>\n})</pre></div></div><h4>接下来...</h4><p>了解了<code>thunk</code>函数，我们立刻就将<code>Generator</code>和异步操作进行结合</p><p>&nbsp;</p><h1>第五部分，Generator 与异步操作</h1><p>这一节正式开始讲解<code>Generator</code>如何进行异步操作，以前我们花了好几节的时间各种打基础，现在估计大家也都等急了，好戏马上开始！</p><p>本节演示的代码可参考<a  target=\"_blank\" href=\"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/test.js\">这里</a></p><h4>本节内容概述</h4><ul><li>在<code>Genertor</code>中使用<code>thunk</code>函数</li><li>挨个读取两个文件的内容</li><li>自驱动流程</li><li>使用<code>co</code>库</li><li><code>co</code>库和<code>Promise</code></li><li>接下来...</li></ul><h4>在<code>Genertor</code>中使用<code>thunk</code>函数</h4><p>这个比较简单了，之前都讲过的，直接看代码即可。代码中表达的意思，是要依次读取两个文件的内容</p><div><pre>const readFileThunk =<span> thunkify(fs.readFile)\nconst gen </span>= <span>function</span>*<span> () {\n    const r1 </span>= yield readFileThunk('data1.json'<span>)\n    console.log(r1)\n    const r2 </span>= yield readFileThunk('data2.json'<span>)\n    console.log(r2)\n}</span></pre></div><h4>挨个读取两个文件的内容</h4><p>接着以上的代码继续写，注释写的非常详细，大家自己去看，看完自己写代码亲身体验。</p><div><pre>const g =<span> gen()\n\n</span><span>//</span><span> 试着打印 g.next() 这里一定要明白 value 是一个 thunk函数 ，否则下面的代码你都看不懂</span><span>\n//</span><span> console.log( g.next() )  // g.next() 返回 {{ value: thunk函数, done: false }} </span>\n\n<span>//</span><span> 下一行中，g.next().value 是一个 thunk 函数，它需要一个 callback 函数作为参数传递进去</span>\ng.next().value((err, data1) =&gt;<span> {\n    </span><span>//</span><span> 这里的 data1 获取的就是第一个文件的内容。下一行中，g.next(data1) 可以将数据传递给上面的 r1 变量，此前已经讲过这种参数传递的形式</span>\n    <span>//</span><span> 下一行中，g.next(data1).value 又是一个 thunk 函数，它又需要一个 callback 函数作为参数传递进去</span>\n    g.next(data1).value((err, data2) =&gt;<span> {\n        </span><span>//</span><span> 这里的 data2 获取的是第二个文件的内容，通过 g.next(data2) 将数据传递个上面的 r2 变量</span>\n<span>        g.next(data2)\n    })\n})</span></pre></div><p>上面 6 行左右的代码，却用了 6 行左右的注释来解释，可见代码的逻辑并不简单，不过你还是要去尽力理解，否则接下来的内容无法继续。再说，我已经写的那么详细了，你只要照着仔细看肯定能看明白的。</p><p>也许上面的代码给你带来的感觉并不好，第一它逻辑复杂，第二它也不是那么易读、简洁呀，用<code>Generator</code>实现异步操作就是这个样子的？———— 当然不是，继续往下看。</p><h4>自驱动流程</h4><p>以上代码中，读取两个文件的内容都是手动一行一行写的，而我们接下来要做一个自驱动的流程，定义好<code>Generator</code>的代码之后，就让它自动执行。完整的代码如下所示：</p><div><pre><span>//</span><span> 自动流程管理的函数</span>\n<span>function</span><span> run(generator) {\n    const g </span>=<span> generator()\n    </span><span>function</span><span> next(err, data) {\n        const result </span>= g.next(data)  <span>//</span><span> 返回 { value: thunk函数, done: ... }</span>\n        <span>if</span><span> (result.done) {\n            </span><span>//</span><span> result.done 表示是否结束，如果结束了那就 return 作罢</span>\n            <span>return</span><span>\n        }\n        result.value(next)  </span><span>//</span><span> result.value 是一个 thunk 函数，需要一个 callback 函数作为参数，而 next 就是一个 callback 形式的函数</span>\n<span>    }\n    next() </span><span>//</span><span> 手动执行以启动第一次 next</span>\n<span>}\n\n</span><span>//</span><span> 定义 Generator</span>\nconst readFileThunk =<span> thunkify(fs.readFile)\nconst gen </span>= <span>function</span>*<span> () {\n    const r1 </span>= yield readFileThunk('data1.json'<span>)\n    console.log(r1.toString())\n    const r2 </span>= yield readFileThunk('data2.json'<span>)\n    console.log(r2.toString())\n}\n\n</span><span>//</span><span> 启动执行</span>\nrun(gen)</pre></div><p>其实这段代码和上面的手动编写读取两个文件内容的代码，原理上是一模一样的，只不过这里把流程驱动给封装起来了。我们简单分析一下这段代码</p><ul><li>最后一行<code>run(gen)</code>之后，进入<code>run</code>函数内部执行</li><li>先<code>const g = generator()</code>创建<code>Generator</code>实例，然后定义一个<code>next</code>方法，并且立即执行<code>next()</code></li><li>注意这个<code>next</code>函数的参数是<code>err, data</code>两个，和我们<code>fs.readFile</code>用到的<code>callback</code>函数形式完全一样</li><li>第一次执行<code>next</code>时，会执行<code>const result = g.next(data)</code>，而<code>g.next(data)</code>返回的是<code>{ value: thunk函数, done: ... }</code>，<code>value</code>是一个<code>thunk</code>函数，<code>done</code>表示是否结束</li><li>如果<code>done: true</code>，那就直接<code>return</code>了，否则继续进行</li><li><code>result.value</code>是一个<code>thunk</code>函数，需要接受一个<code>callback</code>函数作为参数传递进去，因此正好把<code>next</code>给传递进去，让<code>next</code>一直被执行下去</li></ul><p>大家照着这个过程来捋一捋，不是特别麻烦，然后自己试着写完运行一下，基本就能了解了。</p><h4>使用<code>co</code>库</h4><p>刚才我们定义了一个<code>run</code>还是来做自助流程管理，是不是每次使用都得写一遍<code>run</code>函数呢？———— 肯定不是的，直接用大名鼎鼎的<code>co</code>就好了。用<code>Generator</code>的工程师，肯定需要用到<code>co</code>，两者天生一对，难舍难分。</p><p>使用之前请安装<code>npm i co --save</code>，然后在文件开头引用<code>const co = require('co')</code>。<code>co</code>到底有多好用，我们将刚才的代码用<code>co</code>重写，就变成了如下代码。非常简洁</p><div><pre><span>//</span><span> 定义 Generator</span>\nconst readFileThunk =<span> thunkify(fs.readFile)\nconst gen </span>= <span>function</span>*<span> () {\n    const r1 </span>= yield readFileThunk('data1.json'<span>)\n    console.log(r1.toString())\n    const r2 </span>= yield readFileThunk('data2.json'<span>)\n    console.log(r2.toString())\n}\nconst c </span>= co(gen)</pre></div><p>而且<code>const c = co(gen)</code>返回的是一个<code>Promise</code>对象，可以接着这么写</p><div><div><pre>c.then(data =&gt;<span> {\n    console.log(</span>'结束'<span>)\n})</span></pre></div></div><h4><code>co</code>库和<code>Promise</code></h4><p>刚才提到<code>co()</code>最终返回的是<code>Promise</code>对象，后知后觉，我们已经忘记<code>Promise</code>好久了，现在要重新把它拾起来。如果使用<code>co</code>来处理<code>Generator</code>的话，其实<code>yield</code>后面可以跟<code>thunk</code>函数，也可以跟<code>Promise</code>对象。</p><p><code>thunk</code>函数上文一直在演示，下面演示一下<code>Promise</code>对象的，也权当再回顾一下久别的<code>Promise</code>。其实从形式上和结果上，都跟<code>thunk</code>函数一样。</p><div><pre>const readFilePromise =<span> Q.denodeify(fs.readFile)\n\nconst gen </span>= <span>function</span>*<span> () {\n    const r1 </span>= yield readFilePromise('data1.json'<span>)\n    console.log(r1.toString())\n    const r2 </span>= yield readFilePromise('data2.json'<span>)\n    console.log(r2.toString())\n}\n\nco(gen)</span></pre></div><h4>接下来...</h4><p>经过了前几节的技术积累，我们用一节的时间就讲述了<code>Generator</code>如何进行异步操作。接下来要介绍一个开源社区中比较典型的使用<code>Generator</code>的框架 ———— Koa</p><p>&nbsp;</p><h1>第六部分，koa 中使用 Generator</h1><p><a target=\"_blank\" href=\"https://github.com/koajs/koa\">koa</a>&nbsp;是一个 nodejs 开发的 web 框架，所谓 web 框架就是处理 http 请求的。开源的 nodejs 开发的 web 框架最初是&nbsp;<a target=\"_blank\" href=\"https://github.com/expressjs/express\">express</a>。</p><p>我们此前说过，既然是处理 http 请求，是一种网络操作，肯定就会用到异步操作。express 使用的异步操作是传统的<code>callbck</code>，而 koa 用的是我们刚刚讲的<code>Generator</code>（koa&nbsp;<code>v1.x</code>用的是<code>Generator</code>，已经被广泛使用，而 koa&nbsp;<code>v2.x</code>用到了 ES7 中的<code>async-await</code>，不过因为 ES7 没有正式发布，所以 koa&nbsp;<code>v2.x</code>也没有正式发布，不过可以试用）</p><p>koa 是由 express 的原班开发人员开发的，比 express 更加简洁易用，因此 koa 是目前最为推荐的 nodejs web 框架。阿里前不久就依赖于 koa 开发了自己的 nodejs web 框架&nbsp;<a  target=\"_blank\" href=\"https://github.com/eggjs/egg\">egg</a></p><p>国内可以通过<a  target=\"_blank\" href=\"http://koa.bootcss.com/\">koa.bootcss.com</a>查阅文档，<em>不过这网站依赖了 Google 的服务，因此如果不科学上网，估计会访问会很慢</em>。</p><p>提醒：如果你是初学<code>Generator</code>而且从来没有用过 koa ，那么这一节你如果看不懂，没有问题。看不懂就不要强求，可以忽略，继续往下看！</p><p>本节演示的代码可参考<a  target=\"_blank\" href=\"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/test.js\">这里</a></p><h4>本节内容概述</h4><ul><li>koa 中如何应用<code>Generator</code></li><li>koa 的这种应用机制是如何实现的</li><li>接下来...</li></ul><h4>koa 中如何应用<code>Generator</code></h4><p>koa 是一个 web 框架，处理 http 请求，但是这里我们不去管它如何处理 http 请求，而是直接关注它使用<code>Genertor</code>的部分————中间件。</p><p>例如，我们现在要用 3 个<code>Generator</code>输出<code>12345</code>，我们如下代码这么写。应该能看明白吧？看不明白回炉重造！</p><div><pre>let info = ''\n<span>function</span>*<span> g1() {\n    info </span>+= '1'  <span>//</span><span> 拼接 1</span>\n    yield* g2()  <span>//</span><span> 拼接 234</span>\n    info += '5'  <span>//</span><span> 拼接 5</span>\n<span>}\n</span><span>function</span>*<span> g2() {\n    info </span>+= '2'  <span>//</span><span> 拼接 2</span>\n    yield* g3()  <span>//</span><span> 拼接 3</span>\n    info += '4'  <span>//</span><span> 拼接 4</span>\n<span>}\n</span><span>function</span>*<span> g3() {\n    info </span>+= '3'  <span>//</span><span> 拼接 3</span>\n<span>}\n\n</span><span>var</span> g =<span> g1()\ng.next()\nconsole.log(info)  </span><span>//</span><span> 12345</span></pre></div><p>但是如果用 koa 的&nbsp;中间件&nbsp;的思路来做，就需要如下这么写。</p><div><pre>app.use(<span>function</span> *<span>(next){\n    </span><span>this</span>.body = '1'<span>;\n    yield next;\n    </span><span>this</span>.body += '5'<span>;\n    console.log(</span><span>this</span><span>.body);\n});\napp.use(</span><span>function</span> *<span>(next){\n    </span><span>this</span>.body += '2'<span>;\n    yield next;\n    </span><span>this</span>.body += '4'<span>;\n});\napp.use(</span><span>function</span> *<span>(next){\n    </span><span>this</span>.body += '3'<span>;\n});</span></pre></div><p>解释几个关键点</p><ul><li><code>app.use()</code>中传入的每一个<code>Generator</code>就是一个&nbsp;中间件，中间件按照传入的顺序排列，顺序不能乱</li><li>每个中间件内部，<code>next</code>表示下一个中间件。<code>yield next</code>就是先将程序暂停，先去执行下一个中间件，等<code>next</code>被执行完之后，再回过头来执行当前代码的下一行。因此，koa 的中间件执行顺序是一种<a  target=\"_blank\" href=\"https://eggjs.org/zh-cn/intro/egg-and-koa.html#midlleware\">洋葱圈模型</a>，不过这里看不懂也没问题。</li><li>每个中间件内部，<code>this</code>可以共享变量。即第一个中间件改变了<code>this</code>的属性，在第二个中间件中可以看到效果。</li></ul><h4>koa 的这种应用机制是如何实现的</h4><p>前方高能————上面介绍 koa 的中间价估计有些新人就开始蒙圈了，不过接下来还有更加有挑战难度的，就是以上这种方式是如何实现的。你就尽量去看，看懂了更好，看不懂也没关系————当然，你完全可以选择跳过本教程直接去看下一篇，这都 OK</p><p>加入我们自己实现一个简单的 koa ———— MyKoa ，那么仅需要几十行代码就可以搞定上面的问题。直接写代码，注意看重点部分的注释</p><div><pre><span>class MyKoa extends Object {\n    constructor(props) {\n        super(props);\n\n        </span><span>//</span><span> 存储所有的中间件</span>\n        <span>this</span>.middlewares =<span> []\n    }\n\n    </span><span>//</span><span> 注入中间件</span>\n<span>    use (generator) {\n        </span><span>this</span><span>.middlewares.push(generator)\n    }\n\n    </span><span>//</span><span> 执行中间件</span>\n<span>    listen () {\n        </span><span>this</span><span>._run()\n    }\n\n    _run () {\n        const ctx </span>= <span>this</span><span>\n        const middlewares </span>=<span> ctx.middlewares\n        co(</span><span>function</span>*<span> () {\n            let prev </span>= <span>null</span><span>\n            let i </span>=<span> middlewares.length\n            </span><span>//</span><span>从最后一个中间件到第一个中间件的顺序开始遍历</span>\n            <span>while</span> (i--<span>) {\n                </span><span>//</span><span> ctx 作为函数执行时的 this 才能保证多个中间件中数据的共享</span>\n                <span>//</span><span>prev 将前面一个中间件传递给当前中间件，才使得中间件里面的 next 指向下一个中间件</span>\n                prev =<span> middlewares[i].call(ctx, prev);\n            }\n            </span><span>//</span><span>执行第一个中间件</span>\n<span>            yield prev;\n        })\n    }\n}</span></pre></div><p>最后我们执行代码实验一下效果</p><div><pre><span>var</span> app = <span>new</span><span> MyKoa();\napp.use(</span><span>function</span> *<span>(next){\n    </span><span>this</span>.body = '1'<span>;\n    yield next;\n    </span><span>this</span>.body += '5'<span>;\n    console.log(</span><span>this</span>.body);  <span>//</span><span> 12345</span>\n<span>});\napp.use(</span><span>function</span> *<span>(next){\n    </span><span>this</span>.body += '2'<span>;\n    yield next;\n    </span><span>this</span>.body += '4'<span>;\n});\napp.use(</span><span>function</span> *<span>(next){\n    </span><span>this</span>.body += '3'<span>;\n});\napp.listen();</span></pre></div><h4>接下来...</h4><p><code>Generator</code>的应用基本讲完，从一开始的基础到后面应用到异步操作，再到本节的高级应用 koa ，算是比较全面了。接下来，我们要再回到最初的起点，探讨<code>Generator</code>的本质，以及它和<code>callback</code>的关系。</p><p>还是那句话，搞明白原理，才能用的更加出色！</p><p>&nbsp;</p><h1>第七部分，Generator 的本质是什么？是否取代了 callback</h1><p>其实标题中的问题，是一个伪命题，因为<code>Generator</code>和<code>callback</code>根本没有任何关系，只是我们通过一些方式（而且是很复杂的方式）强行将他俩产生了关系，才会有现在的<code>Generator</code>处理异步。</p><h4>本节内容概述</h4><ul><li><code>Generator</code>的本质</li><li>和<code>callback</code>的结合</li></ul><h4><code>Generator</code>的本质</h4><p>介绍<code>Generator</code>的<a target=\"_blank\"  href=\"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/01-generator-in-es6.md\">第一节</a>中，多次提到&nbsp;暂停&nbsp;这个词 ————&nbsp;“暂停”才是<code>Generator</code>的本质&nbsp;———— 只有<code>Generator</code>能让一段程序执行到指定的位置先暂停，然后再启动，再暂停，再启动。</p><p>而这个&nbsp;暂停&nbsp;就很容易让它和异步操作产生联系，因为我们在处理异步操作时，即需要一种“开始读取文件，然后暂停一下，等着文件读取完了，再干嘛干嘛...”这样的需求。因此将<code>Generator</code>和异步操作联系在一起，并且产生一些比较简明的解决方案，这是顺其自然的事儿，大家要想明白这个道理。</p><p>不过，JS 还是 JS，单线程还是单线程，异步还是异步，<code>callback</code>还是<code>callback</code>。这一切都不会因为有一个<code>Generator</code>而有任何变化。</p><h4>和<code>callback</code>的结合</h4><p>之前在介绍<code>Promise</code>的最后，拿<code>Promise</code>和<code>callback</code>做过一些比较，最后发现<code>Promise</code>其实是利用了<code>callback</code>才能实现的。而这里，<code>Generator</code>也必须利用<code>callback</code>才能实现。</p><p>拿介绍<code>co</code>时的代码举例（代码如下），如果<code>yield</code>后面用的是<code>thunk</code>函数，那么<code>thunk</code>函数需要的就是一个<code>callback</code>参数。如果<code>yield</code>后面用的是<code>Promise</code>对象，<code>Promise</code>和<code>callback</code>的联系之前已经介绍过了。</p><div><div><pre>co(<span>function</span>*<span> () {\n    const r1 </span>= yield readFilePromise('some1.json'<span>)\n    console.log(r1)  </span><span>//</span><span> 打印第 1 个文件内容</span>\n    const r2 = yield readFileThunk('some2.json'<span>)\n    console.log(r2)  </span><span>//</span><span> 打印第 2 个文件内容</span>\n})</pre></div></div><p><!--StartFragment--><!--EndFragment--></p><p>因此，<code>Generator</code>离不开<code>callback</code>，<code>Promise</code>离不开<code>callback</code>，异步也离不开<code>callback</code>。</p><p><br></p>"}}
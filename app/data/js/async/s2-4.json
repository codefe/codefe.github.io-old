{"sta":1,"data":{"subTitle":"ES7 中引入 async-await","content":"<h3>第一部分，ES7 中引入 async-await</h3><p>前面介绍完了<code>Generator</code>的异步处理，可以说是跌跌撞撞，经过各种基础介绍和封装，好容易出了一个比较简洁的异步处理方案，学习成本非常高————这显然不是我们想要的！</p><p>因此，还未发布的 ES7 就干脆自己参照<code>Generator</code>封装了一套异步处理方案————<code>async-await</code>。说是参照，其实可以理解为是<code>Generator</code>的语法糖！</p><h4>本节内容概述</h4><ul><li><code>Generator</code>和<code>async-await</code>的对比</li><li>使用<code>async-await</code>的不同和好处</li><li>接下来...</li></ul><h4><code>Generator</code>和<code>async-await</code>的对比</h4><p>先来一段<code>Generator</code>处理异步的代码，前面已经介绍过了，看不明白的再获取接着看。</p><div><div><pre>co(<span>function</span>*<span> () {\n    const r1 </span>= yield readFilePromise('some1.json'<span>)\n    console.log(r1)  </span><span>//</span><span> 打印第 1 个文件内容</span>\n    const r2 = yield readFilePromise('some2.json'<span>)\n    console.log(r2)  </span><span>//</span><span> 打印第 2 个文件内容</span>\n})</pre></div></div><p>再来一段<code>async-await</code>的执行代码如下，两者做一个比较。</p><div><pre>const readFilePromise =<span> Q.denodeify(fs.readFile)\n\n</span><span>//</span><span> 定义 async 函数</span>\nconst readFileAsync = async <span>function</span><span> () {\n    const f1 </span>= await readFilePromise('data1.json'<span>)\n    const f2 </span>= await readFilePromise('data2.json'<span>)\n    console.log(</span>'data1.json'<span>, f1.toString())\n    console.log(</span>'data2.json'<span>, f2.toString())\n\n    </span><span>return</span> 'done' <span>//</span><span> 先忽略，后面会讲到</span>\n<span>}\n</span><span>//</span><span> 执行</span>\nconst result = readFileAsync()</pre></div><p>从上面两端代码比较看来，<code>async function</code>代替了<code>function*</code>，<code>await</code>代替了<code>yield</code>，其他的再没有什么区别了。哦，还有，使用<code>async-await</code>时候不用再引用<code>co</code>这种第三方库了，直接执行即可。</p><h4>使用<code>async-await</code>的不同和好处</h4><p>第一，<code>await</code>后面不能再跟<code>thunk</code>函数，而必须跟一个<code>Promise</code>对象（因此，<code>Promise</code>才是异步的终极解决方案和未来）。跟其他类型的数据也OK，但是会直接同步执行，而不是异步。</p><p>第二，执行<code>const result = readFileAsync()</code>返回的是个<code>Promise</code>对象，而且上面代码中的<code>return 'done'</code>会直接被下面的<code>then</code>函数接收到</p><div><div><pre>result.then(data =&gt;<span> {\n    console.log(data)  </span><span>//</span><span> done</span>\n})</pre></div></div><p>第三，从代码的易读性来将，<code>async-await</code>更加易读简介，也更加符合代码的语意。而且还不用引用第三方库，也无需学习<code>Generator</code>那一堆东西，使用成本非常低。</p><p>因此，如果 ES7 正式发布了之后，强烈推荐使用<code>async-await</code>。但是现在尚未正式发布，从稳定性考虑，还是<code>Generator</code>更好一些。</p><h4>接下来...</h4><p>node&nbsp;<code>v7</code>&nbsp;版本已经开始原生支持<code>async-await</code>了，不过 node 的目前稳定版本还是<code>v6</code>，尚不支持，怎么办？———— 当然是万能的<code>babel</code>！下一节就介绍。</p><p>&nbsp;</p><h3>第二部分，如何在 nodejs&nbsp;<code>v6.x</code>版本中使用 async-await</h3><p>本节介绍一下如何使用<code>babel</code>来让 node&nbsp;<code>v6</code>&nbsp;版本也能运行<code>async-await</code></p><h4>本节内容概述</h4><ul><li>安装必要的插件</li><li>创建入口文件并执行</li></ul><h4>安装必要的插件</h4><p>运行<code>npm i babel-core babel-plugin-transform-runtime babel-preset-es2015 babel-preset-stage-3 babel-runtime --save</code>安装一堆需要的插件。</p><p>然后在项目根目录创建<code>.babelrc</code>文件，文件内容编写为</p><div><div><pre><span>{\n  </span>\"presets\": [\"stage-3\", \"es2015\"<span>],\n  </span>\"plugins\": [\"transform-runtime\"<span>]\n}</span></pre></div></div><h4>创建入口文件并执行</h4><p>加入你编写<code>async-await</code>的代码文件是<code>test.js</code>，那么你需要创建另一个文件，例如<code>test-entry.js</code>作为入口文件。入口文件内容编写为</p><div><div><pre>require(\"babel-core/register\"<span>);\nrequire(</span>\"./test.js\");</pre></div></div><p>然后直接运行<code>node test-entry.js</code>就可以了</p><p>&nbsp;</p><h3>第三部分，async与await详解</h3><h4>1、async 函数是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。</h4><pre><code>var fs = require('fs');\n\nvar readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};</code></pre><p>写成async函数，就是下面这样。</p><pre><code>var asyncReadFile = async function () {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};</code></pre><p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p><h4>2、async函数对 Generator 函数的改进，体现在以下四点。</h4><p>a, 内置执行器。async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n<br><blockquote>var result = asyncReadFile();\n</blockquote>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法\n<br>\n<br>b, 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n<br>c, 更广的适用性。yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n<br>d, 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n<br>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。&nbsp;</p><h4>3、async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</h4><pre><code>async function getStockPriceByName(name) {\n  var symbol = await getStockSymbol(name);\n  var stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});</code></pre><p>函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><h4>4、另一个例子，指定多少毫秒后输出一个值。</h4><pre><code>function timeout(ms) {\n  return new Promise((resolve) =&gt; {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);</code></pre><h4>5、async 函数有多种使用形式。</h4><pre><code>// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () =&gt; {};</code></pre><h4>6、async函数返回一个 Promise 对象。</h4><p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p><pre><code>async function f() {\n  return 'hello world';\n}\n\nf().then(v =&gt; console.log(v))\n// \"hello world\"</code></pre><h4>7、async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</h4><pre><code>async function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v =&gt; console.log(v),\n  e =&gt; console.log(e)\n)\n// Error: 出错了</code></pre><h4>8、只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</h4><pre><code>async function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"</code></pre><p>上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\n<br><h4>9、正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</h4></p><pre><code>async function f() {\n  return await 123;\n}\n\nf().then(v =&gt; console.log(v))\n// 123</code></pre><p>上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。\n<br>\n<br>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。\n<br>\n<br><h4>10、有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</p><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。</p></h4><h4>11、多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</h4><pre><code>// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;</code></pre><h4>12、await命令只能用在async函数之中，如果用在普通函数，就会报错。</h4><pre><code>function dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}</code></pre><p>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p><pre><code>async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}</code></pre><p>如果确实希望多个请求并发执行，可以使用Promise.all方法。\n<br><h4>13、async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</h4></p><pre><code>async function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url =&gt; {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}</code></pre><p>上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</p>"}}
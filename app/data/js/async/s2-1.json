{"sta":1,"data":{"subTitle":"异步和事件轮询(event-loop)","content":"<h3>第一部分，jQuery-1.5 之后的 ajax</h3><p><code>$.ajax</code>这个函数各位应该都比较熟悉了，要完整的讲解 js 的异步操作，就必须先从<code>$.ajax</code>这个方法说起。</p><p>想要学到全面的知识，大家就不要着急，跟随我的节奏来，并且相信我。我安排的内容，肯定都是有用的，对主题无用的东西，我不会拿来占用大家的时间。</p><h4>本节内容概述</h4><ul><li>传统的<code>$.ajax</code></li><li>1.5 版本之后的<code>$.ajax</code></li><li>改进之后的好处</li><li>和后来的<code>Promise</code>的关系</li><li>如何实现的？</li></ul><h4>传统的<code>$.ajax</code></h4><p>先来一段最常见的<code>$.ajax</code>的代码，当然是使用万恶的<code>callback</code>方式</p><div><div><pre><span>var</span> ajax =<span> $.ajax({\n    url: </span>'data.json'<span>,\n    success: </span><span>function</span><span> () {\n        console.log(</span>'success'<span>)\n    },\n    error: </span><span>function</span><span> () {\n        console.log(</span>'error'<span>)\n    }\n})\n\nconsole.log(ajax) </span><span>//</span><span> 返回一个 XHR 对象</span></pre></div></div><p>至于这么做会产生什么样子的诟病，我想大家应该都很明白了。不明白的自己私下去查，但是你也可以继续往下看，你只需要记住这样做很不好就是了，要不然 jquery 也不会再后面进行改进</p><h4>1.5 版本之后的<code>$.ajax</code></h4><p>但是从<code>v1.5</code>开始，以上代码就可以这样写了：可以链式的执行<code>done</code>或者<code>fail</code>方法</p><div><div><pre><span>var</span> ajax = $.ajax('data.json'<span>)\najax.done(</span><span>function</span><span> () {\n        console.log(</span>'success 1'<span>)\n    })\n    .fail(</span><span>function</span><span> () {\n        console.log(</span>'error'<span>)\n    })\n    .done(</span><span>function</span><span> () {\n         console.log(</span>'success 2'<span>)\n    })\n\nconsole.log(ajax) </span><span>//</span><span> 返回一个 deferred 对象</span></pre></div></div><p>大家注意看以上两段代码中都有一个<code>console.log(ajax)</code>，但是返回值是完全不一样的。</p><ul><li><code>v1.5</code>之前，返回的是一个<code>XHR</code>对象，这个对象不可能有<code>done</code>或者<code>fail</code>的方法的</li><li><code>v1.5</code>开始，返回一个<code>deferred</code>对象，这个对象就带有<code>done</code>和<code>fail</code>的方法，并且是等着请求返回之后再去调用</li></ul><h4>改进之后的好处</h4><p>这是一个标志性的改造，不管这个概念是谁最先提出的，它在 jquery 中首先大量使用并让全球开发者都知道原来 ajax 请求还可以这样写。这为以后的<code>Promise</code>标准制定提供了很大意义的参考，你可以以为这就是后面<code>Promise</code>的原型。</p><p>记住一句话————<strong>虽然 JS 是异步执行的语言，但是人的思维是同步的</strong>————因此，开发者总是在寻求如何使用逻辑上看似同步的代码来完成 JS 的异步请求。而 jquery 的这一次更新，让开发者在一定程度上得到了这样的好处。</p><p>之前无论是什么操作，我都需要一股脑写到<code>callback</code>中，现在不用了。现在成功了就写到<code>done</code>中，失败了就写到<code>fail</code>中，如果成功了有多个步骤的操作，那我就写很多个<code>done</code>，然后链式连接起来就 OK 了。</p><h4>和后来的<code>Promise</code>的关系</h4><p>以上的这段代码，我们还可以这样写。即不用<code>done</code>和<code>fail</code>函数，而是用<code>then</code>函数。<code>then</code>函数的第一个参数是成功之后执行的函数（即之前的<code>done</code>），第二个参数是失败之后执行的函数（即之前的<code>fail</code>）。而且<code>then</code>函数还可以链式连接。</p><div><div><pre><span>var</span> ajax = $.ajax('data.json'<span>)\najax.then(</span><span>function</span><span> () {\n        console.log(</span>'success 1'<span>)\n    }, </span><span>function</span><span> () {\n        console.log(</span>'error 1'<span>)\n    })\n    .then(</span><span>function</span><span> () {\n        console.log(</span>'success 2'<span>)\n    }, </span><span>function</span><span> () {\n        console.log(</span>'error 2'<span>)\n    })</span></pre></div></div><p>如果你对现在 ES6 的<code>Promise</code>有了解，应该能看出其中的相似之处。不了解也没关系，你只需要知道它已经和<code>Promise</code>比较接近了。后面马上会去讲<code>Promise</code></p><h4>如何实现的？</h4><p>明眼人都知道，jquery 不可能改变异步操作需要<code>callback</code>的本质，它只不过是自己定义了一些特殊的 API，并对异步操作的<code>callback</code>进行了封装而已。</p><p>那么 jquery 是如何实现这一步的呢？请听下回分解！</p><p>&nbsp;</p><h3>第二部分，jQuery deferred</h3><p>上一节讲到 jquery v1.5 版本开始，<code>$.ajax</code>可以使用类似当前<code>Promise</code>的<code>then</code>函数以及链式操作。那么它到底是如何实现的呢？在此之前所用到的<code>callback</code>在这其中又起到了什么作用？本节给出答案</p><h4>本节内容概述</h4><ul><li>写一个传统的异步操作</li><li>使用<code>$.Deferred</code>封装</li><li>应用<code>then</code>方法</li><li>有什么问题？</li></ul><h4>写一个传统的异步操作</h4><p>给出一段非常简单的异步操作代码，使用<code>setTimeout</code>函数。</p><div><div><pre><span>var</span> wait = <span>function</span><span> () {\n    </span><span>var</span> task = <span>function</span><span> () {\n        console.log(</span>'执行完成'<span>)\n    }\n    setTimeout(task, </span>2000<span>)\n}\nwait()</span></pre></div></div><p>以上这些代码执行的结果大家应该都比较明确了，即 2s 之后打印出<code>执行完成</code>。<strong>但是我如果再加一个需求 ———— 要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤 ———— 那该怎么办？&nbsp;大家思考一下！</strong></p><p>如果你不看下面的内容，而且目前还没有<code>Promise</code>的这个思维，那估计你会说：直接在<code>task</code>函数中写就是了！不过相信你看完下面的内容之后，会放弃你现在的想法。</p><h4>使用$.Deferred封装</h4><p>好，接下来我们让刚才简单的几行代码变得更加复杂。<strong>为何要变得更加复杂？是因为让以后更加复杂的地方变得简单</strong>。这里我们使用了 jquery 的<code>$.Deferred</code>，至于这个是个什么鬼，大家先不用关心，<strong>只需要知道<code>$.Deferred()</code>会返回一个<code>deferred</code>对象</strong>，先看代码，<code>deferred</code>对象的作用我们会面会说。</p><div><div><pre><span>function</span><span> waitHandle() {\n    </span><span>var</span> dtd = $.Deferred()  <span>//</span><span> 创建一个 deferred 对象</span>\n\n    <span>var</span> wait = <span>function</span> (dtd) {  <span>//</span><span> 要求传入一个 deferred 对象</span>\n        <span>var</span> task = <span>function</span><span> () {\n            console.log(</span>'执行完成'<span>)\n            dtd.resolve()  </span><span>//</span><span> 表示异步任务已经完成</span>\n<span>        }\n        setTimeout(task, </span>2000<span>)\n        </span><span>return</span> dtd  <span>//</span><span> 要求返回 deferred 对象</span>\n<span>    }\n\n    </span><span>//</span><span> 注意，这里一定要有返回值</span>\n    <span>return</span><span> wait(dtd)\n}</span></pre></div></div><p>以上代码中，又使用一个<code>waitHandle</code>方法对<code>wait</code>方法进行再次的封装。<code>waitHandle</code>内部代码，我们分步骤来分析。跟着我的节奏慢慢来，保证你不会乱。</p><ul><li>使用<code>var dtd = $.Deferred()</code>创建<code>deferred</code>对象。通过上一节我们知道，一个<code>deferred</code>对象会有<code>done</code>&nbsp;<code>fail</code>和<code>then</code>方法（不明白的去看上一节）</li><li>重新定义<code>wait</code>函数，但是：第一，要传入一个<code>deferred</code>对象（<code>dtd</code>参数）；第二，当<code>task</code>函数（即<code>callback</code>）执行完成之后，要执行<code>dtd.resolve()</code>告诉传入的<code>deferred</code>对象，革命已经成功。第三；将这个<code>deferred</code>对象返回。</li><li>返回<code>wait(dtd)</code>的执行结果。因为<code>wait</code>函数中返回的是一个<code>deferred</code>对象（<code>dtd</code>参数），因此<code>wait(dtd)</code>返回的就是<code>dtd</code>————如果你感觉这里很乱，没关系，慢慢捋，一行一行看，相信两三分钟就能捋顺！</li></ul><p>最后总结一下，<code>waitHandle</code>函数最终<code>return wait(dtd)</code>即最终返回<code>dtd</code>（一个<code>deferred</code>）对象。针对一个<code>deferred</code>对象，它有<code>done</code>&nbsp;<code>fail</code>和<code>then</code>方法（上一节说过），它还有<code>resolve()</code>方法（其实和<code>resolve</code>相对的还有一个<code>reject</code>方法，后面会提到）</p><h4>应用<code>then</code>方法</h4><p>接着上面的代码继续写</p><div><div><pre><span>var</span> w =<span> waitHandle()\nw.then(</span><span>function</span><span> () {\n    console.log(</span>'ok 1'<span>)\n}, </span><span>function</span><span> () {\n    console.log(</span>'err 1'<span>)\n}).then(</span><span>function</span><span> () {\n    console.log(</span>'ok 2'<span>)\n}, </span><span>function</span><span> () {\n    console.log(</span>'err 2'<span>)\n})</span></pre></div></div><p>上面已经说过，<code>waitHandle</code>函数最终返回一个<code>deferred</code>对象，而<code>deferred</code>对象具有<code>done</code>&nbsp;<code>fail</code>&nbsp;<code>then</code>方法，现在我们正在使用的是<code>then</code>方法。至于<code>then</code>方法的作用，我们上一节已经讲过了，不明白的同学抓紧回去补课。</p><p>执行这段代码，我们打印出来以下结果。可以将结果对标以下代码时哪一行。</p><pre><code>执行完成</code></pre><div><pre>ok 1<span>\nok </span>2</pre></div><p>此时，你再回头想想我刚才说提出的需求（<em>要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤</em>），是不是有更好的解决方案了？</p><p>有同学肯定发现了，代码中<code>console.log('err 1')</code>和<code>console.log('err 2')</code>什么时候会执行呢 ———— 你自己把<code>waitHandle</code>函数中的<code>dtd.resolve()</code>改成<code>dtd.reject()</code>试一下就知道了。</p><ul><li><code>dtd.resolve()</code>&nbsp;表示革命已经成功，会触发<code>then</code>中第一个参数（函数）的执行，</li><li><code>dtd.reject()</code>&nbsp;表示革命失败了，会触发<code>then</code>中第二个参数（函数）执行</li></ul><h4>有什么问题？</h4><p>总结一下一个<code>deferred</code>对象具有的函数属性，并分为两组：</p><ul><li><code>dtd.resolve</code>&nbsp;<code>dtd.reject</code></li><li><code>dtd.then</code>&nbsp;<code>dtd.done</code>&nbsp;<code>dtd.fail</code></li></ul><p>我为何要分成两组 ———— 这两组函数，从设计到执行之后的效果是完全不一样的。第一组是主动触发用来改变状态（成功或者失败），第二组是状态变化之后才会触发的监听函数。</p><p>既然是完全不同的两组函数，就应该彻底的分开，否则很容易出现问题。例如，你在刚才执行代码的最后加上这么一行试试。</p><div><div><pre>w.reject()</pre></div></div><p>那么如何解决这一个问题？请听下回分解！</p><p>&nbsp;</p><h3>第三部分，jQuery promise</h3><p>上一节通过一些代码演示，知道了 jquery 的<code>deferred</code>对象是解决了异步中<code>callback</code>函数的问题</p><h4>本节内容概述</h4><ul><li>返回<code>promise</code></li><li>返回<code>promise</code>的好处</li><li>promise 的概念</li></ul><h4>返回<code>promise</code></h4><p>我们对上一节的的代码做一点小小的改动，只改动了一行，下面注释。</p><div><div><pre><span>function</span><span> waitHandle() {\n    </span><span>var</span> dtd =<span> $.Deferred()\n    </span><span>var</span> wait = <span>function</span><span> (dtd) {\n        </span><span>var</span> task = <span>function</span><span> () {\n            console.log(</span>'执行完成'<span>)\n            dtd.resolve()\n        }\n        setTimeout(task, </span>2000<span>)\n        </span><span>return</span> dtd.promise()  <span>//</span><span> 注意，这里返回的是 primise 而不是直接返回 deferred 对象</span>\n<span>    }\n    </span><span>return</span><span> wait(dtd)\n}\n\n</span><span>var</span> w = waitHandle() <span>//</span><span> 经过上面的改动，w 接收的就是一个 promise 对象</span>\n<span>$.when(w)\n .then(</span><span>function</span><span> () {\n    console.log(</span>'ok 1'<span>)\n })\n .then(</span><span>function</span><span> () {\n    console.log(</span>'ok 2'<span>)\n })</span></pre></div></div><p>改动的一行在这里<code>return dtd.promise()</code>，之前是<code>return dtd</code>。<code>dtd</code>是一个<code>deferred</code>对象，而<code>dtd.promise</code>就是一个<code>promise</code>对象。</p><p><code>promise</code>对象和<code>deferred</code>对象最重要的区别，记住了————<strong><code>promise</code>对象相比于<code>deferred</code>对象，缺少了<code>.resolve</code>和<code>.reject</code>这俩函数属性</strong>。这么一来，可就完全不一样了。</p><p>上一节我们提到一个问题，就是在程序的最后一行加一句<code>w.reject()</code>会导致乱套，你现在再在最后一行加<code>w.reject()</code>试试 ———— 保证乱套不了 ———— 而是你的程序不能执行，直接报错。因为，<code>w</code>是<code>promise</code>对象，不具备<code>.reject</code>属性。</p><h4>返回<code>promise</code>的好处</h4><p>上一节提到<code>deferred</code>对象有两组属性函数，而且提到应该把这两组彻底分开。现在通过上面一行代码的改动，就分开了。</p><ul><li><code>waitHandle</code>函数内部，使用<code>dtd.resolve()</code>来该表状态，做主动的修改操作</li><li><code>waitHandle</code>最终返回<code>promise</code>对象，只能去被动监听变化（<code>then</code>函数），而不能去主动修改操作</li></ul><p>一个“主动”一个“被动”，完全分开了。</p><h4>promise 的概念</h4><p>jquery v1.5 版本发布时间距离现在（2017年初春）已经老早之前了，那会儿大家网页标配都是 jquery 。无论里面的<code>deferred</code>和<code>promise</code>这个概念和想法最早是哪位提出来的，但是最早展示给全世界开发者的是 jquery ，这算是<code>Promise</code>这一概念最先的提出者。</p><p><!--StartFragment--><!--EndFragment--></p><p>其实本次课程主要是给大家分析 ES6 的<code>Promise</code>&nbsp;<code>Generator</code>和<code>async-await</code>，但是为何要从 jquery 开始（大家现在用 jquery 越来越少）？就是要给大家展示一下这段历史的一些起点和发展的知识。有了这些基础，你再去接受最新的概念会非常容易，因为所有的东西都是从最初顺其自然发展进化而来的，我们要去用一个发展进化的眼光学习知识，而不是死记硬背。</p>"}}
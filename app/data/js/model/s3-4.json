{"sta":1,"data":{"subTitle":"掺元类","content":"<pre><code>function augment(receivingClass, givingClass) {\n  if(arguments[2]) { // Only give certain methods.\n    for(var i = 2, len = arguments.length; i &lt; len; i++) {\n      receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];\n    }\n  }\n  else { // Give all methods.\n    for(methodName in givingClass.prototype) {\n      if(!receivingClass.prototype[methodName]) {\n        receivingClass.prototype[methodName] = givingClass.prototype[methodName];\n      }\n    }\n  }\n}\n\nvar Mixin = function() {};\nMixin.prototype = {\n  serialize: function() {\n    var output = [];\n    for(key in this) {\n      output.push(key + ': ' + this[key]);\n    }\n    return output.join(', ');\n  }\n};\n\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.getName = function () {\n  return this.name;\n}\n\naugment(Person, Mixin,'serialize');\nvar hugo = new Person('hugo');\nhugo.serialize();</code></pre><p>这种继承方式是为了扩充类的一些重复函数而不重写代码，这个也是一种多继承的效果。</p>"}}
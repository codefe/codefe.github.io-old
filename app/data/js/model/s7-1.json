{"sta":1,"data":{"subTitle":"抽象工厂模式","content":"<h3>抽象工厂模式</h3><p>抽象工厂是工厂模式的升级版，他用来创建一组相关或者相互依赖的对象。上节学习了工厂模式，类的创建依赖工厂类，程序需要扩展时，我们必须创建新的工厂类。工厂类是用来生产产品的，那我们也可以把“工厂类当成我们要生产的产品”，所以抽象工厂就是“工厂的工厂”，即生产工厂的工厂。下面通过一个例子来深入理解。</p><p></p><h3>代码</h3><pre><code>//抽象工厂模式    \n\nvar DP = require(\"./DesignPattern.js\");\n\nfunction CPUFactory() {\n  DP.Interface(this, ['createCPU']);\n}\n\nfunction IntelCPU() {\n  this.__proto__ = new CPUFactory();\n  this.createCPU = function () {\n    console.log('Intel CPU');\n  };\n}\n\nfunction AMDCPU() {\n  this.__proto__ = new CPUFactory();\n  this.createCPU = function () {\n    console.log('AMD CPU');\n  };\n}\n\nfunction Provider() {\n  DP.Interface(this, ['createCPUFactory']);\n}\nfunction InterCPUFactory() {\n  this.__proto__ = new Provider();\n  this.createCPUFactory = function () {\n    return new IntelCPU();\n  };\n}\n\nfunction AMDCPUFactory() {\n  this.__proto__ = new Provider();\n  this.createCPUFactory = function () {\n    return new AMDCPU();\n  };\n}\n\nvar cpufactory = new InterCPUFactory();\nvar IntelCpu = cpufactory.createCPUFactory();\nIntelCpu.createCPU();\n\ncpufactory = new AMDCPUFactory();\nvar AmdCpu = cpufactory.createCPUFactory();\nAmdCpu.createCPU();</code></pre><p><h3>抽象工厂的优点\n</h3>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联（例如不同厂商生产CPU）。\n<br>\n<br><h3>适用场景\n</h3>一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。</p>"}}
{"sta":1,"data":{"subTitle":"观察者模式","content":"<h3>观察者模式</h3><p>对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h3>观察者要素</h3><p>1.抽象主题(Subject)角色：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</p><p>2.抽象观察者(Observer)角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。</p><p>3.具体主题(ConcreteSubject)角色：在具体主题内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个子类实现。</p><p>4.具体观察者(ConcreteObserver)角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。</p><p><h3>观察者模式优点</h3>1.观察者和被观察者是抽象耦合的。\n<br>2.建立一套触发机制。\n<br>\n<br><h3>观察者模式缺点</h3>1.如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n<br>2.如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。\n<br>3.观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n<br>\n<br><h3>适用场景</h3>1.当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。\n<br>2.当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。\n<br>3.当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</p><h3>例子</h3><p></p><p>为了生产的安全，你决定为你的工厂安装火警报警器，现在你需要为这个报警器写个控制软件。</p><pre><code>// 观察者模式\n\nvar DP = require(\"./DesignPattern.js\");\n\nfunction Factory() {\n  DP.Interface(this, ['attach', 'detach', 'nofityObserver', 'fire'])\n  //添加火灾报警器\n  //移除火灾报警器\n  //通知报警器\n  //发生火灾\n}\nfunction FireAlarm(name) {\n  var _name=name\n  this.rang=function(){\n    console.log(_name+'：发生工厂火灾了,鸣笛');\n  }\n}\nfunction PorscheFactory() {\n  this.__proto__ = new Factory();\n  var _alarms = [];\n  this.attach = function (alarm) {\n    _alarms.push(alarm);\n  }\n  this.detach = function (alarm) {\n    _alarms.splice(_alarms.indexOf(alarm),1);\n  }\n  this.nofityObserver = function () {\n    _alarms.forEach(function(alarm){\n      alarm.rang()\n    })\n  }\n  this.fire=function(){\n    console.log('工厂着火了');\n    this.nofityObserver();\n  }\n}\n\nvar f=new PorscheFactory();\nvar fireAlarm1=new FireAlarm('门卫报警器');\nvar fireAlarm2=new FireAlarm('消防局报警器');\nvar fireAlarm3=new FireAlarm('门卫报警器');\nf.attach(fireAlarm1);\nf.attach(fireAlarm2);\nf.attach(fireAlarm3);\nf.fire();\nconsole.log('--------------------------------------');\nf.detach(fireAlarm3);\nf.fire();</code></pre><p><br></p>"}}
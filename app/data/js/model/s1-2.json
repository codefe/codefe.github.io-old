{"sta":1,"data":{"subTitle":"接口实现方法","content":"<p>《javascript设计模式》的一个例子</p><pre><code>var Interface = function(name, methods) {\n    if(arguments.length != 2) {\n        throw new Error(\"Interface constructor called with \" + arguments.length + \"arguments, but expected exactly 2.\");\n    }\n    \n    this.name = name;\n    this.methods = [];\n    for(var i = 0, len = methods.length; i &lt; len; i++) {\n        if(typeof methods[i] !== 'string') {\n            throw new Error(\"Interface constructor expects method names to be \" + \"passed in as a string.\");\n        }\n        this.methods.push(methods[i]);        \n    }    \n};    \n\n// Static class method.\n\nInterface.ensureImplements = function(object) {\n    if(arguments.length &lt; 2) {\n        throw new Error(\"Function Interface.ensureImplements called with \" + \n          arguments.length  + \"arguments, but expected at least 2.\");\n    }\n\n    for(var i = 1, len = arguments.length; i &lt; len; i++) {\n        var interface = arguments[i];\n        if(interface.constructor !== Interface) {\n            throw new Error(\"Function Interface.ensureImplements expects arguments \" + \"two and above to be instances of Interface.\");\n        }\n        \n        for(var j = 0, methodsLen = interface.methods.length; j &lt; methodsLen; j++) {\n            var method = interface.methods[j];\n            if(!object[method] || typeof object[method] !== 'function') {\n                throw new Error(\"Function Interface.ensureImplements: object \" + \"does not implement the \" + interface.name + \" interface. Method \" + method + \" was not found.\");\n            }\n        }\n    } \n};\nvar DynamicMap = new Interface('DynamicMap', ['centerOnPoint', 'zoom', 'draw']);\n\nfunction displayRoute(mapInstance) {\n    Interface.ensureImplements(mapInstace, DynamicMap);\n    mapInstance.centerOnPoint(12, 34);\n    mapInstance.zoom(5);\n    mapInstance.draw();\n    ...\n}</code></pre><p>以上是书中的实现方法。\n<br>\n<br>可以看到每次在使用前都会做一次接口的遍历这样会大大影响效率。而且这个有一定的强制性影响了JS代码的灵活性。我试着做了另一种方法来做到接口的提示作用。并减少强制性。\n<br>\n<br>我的方法</p><pre><code>var Interface = function (object, methods) {\n  for (var i = 0, len = methods.length; i &lt; len; i++) {\n    if (typeof methods[i] !== 'string') {\n      throw new Error('Interface constructor expects method names to be passed in as a string.');\n    }\n    object[methods[i]] = function () {\n      throw new Error(this.constructor.name + ' Interface function is undefined');\n    };\n  }\n};\nfunction Person(name) {\n  this.name = name;\n  this.sayjob = function () {\n    console.log('say');\n    this.job();\n  };\n  this.sayage = function () {\n    console.log('say');\n    this.age();\n  };\n}\nfunction creatPerson(name) {\n  var object = new Person(name);\n  Interface(object, ['job', 'age']);\n  return object;\n}\nfunction Student(name) {\n  this.__proto__ = creatPerson(name);\n  this.job = function () {\n    console.log('job is student');\n  };\n}\nfunction creatStudent(name) {\n  var object = new Student(name);\n  return object;\n}\nvar b = creatStudent('b');\nb.job();\n//b.age();\nb.sayjob();\n//b.sayage();</code></pre><p>我使用了JS的原型来实现，当接口函数被调用时候查看按照JS的运行原理当子类没有实现时候会调用父类中的方法弹出错误并给出提示。我认为接口的主要目的是做限制，不过在JS这种灵活度特别高的语言中，我个人认为这样的限制影响了性能。也带损失了灵活性。所以我把他修改为这种方式实现，已达到代码中给提示的目的来实现接口的个设计模式。</p>"}}
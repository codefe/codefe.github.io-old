{"sta":1,"data":{"subTitle":"浅谈Nodejs观察者模式","content":"<p><strong>一、前言</strong></p><p>Nodejs使用有些日子了，近来再回顾下其API、多使用新特性，以期有更高层次的掌握，本次API的总结区别于单纯对英文版的汉化，会多做些扩展和自己的理解，希望对大家有所帮助，先从最核心的Events开始</p><p>Nodejs的Events实现了一种观察者模式，其支持了Nodejs的核心机制，且http / fs / mongoose等都继承了Events，可以添加监听事件。这种设计模式在客户端的组件编程思想里经常会用到，我们先简单了解下该模式。</p><p>首次接触 观察者模式是在Extjs框架的 Ext.util.observable源码，那时刚接触js，感觉这种模式很强大，也是我最早接触到的设计模式，后来在 underscore.js 源码里也有看到，且后者实现更简捷、优雅，我编写组件时也基本是按照这种思想。</p><p>观察者模式就是为某一对象添加一监听事件，如on('show', callback)，由该对象在符合条件如show时自行触发，浏览器本身已经为dom实现了监听机制。</p><p></p><p>如我们为input添加keyup监听，目的是为了输出其value</p><pre><code>$( 'input' ).on( 'keyup', function(){\n   console.log( this.value );\n} );</code></pre><p>这样输入内容时会自行在日志中输出其value。\n<br>但我们自己做一个组件如Dialog，如何监听最常用的show / hide事件呢?\n<br>初级的做法是实例化时直接将回调配置进去，如</p><pre><code>var dialog = new Dialog({\n  content: '这里是弹出框的内容',\n  show: function(){\n    console.log( '当弹框时输出此段内容' );\n  }\n});</code></pre><p>这样也可以用，不过显然不够灵活，如何将dialog做的像input那样可随时添加事件呢\n<br>二、观察者模式实现\n<br>首先实现Events对象，这里提供基础的监听on和触发emit，事件是以json形式压栈在对象的_events里</p><pre><code>var Events = {\n  on: function( name, callback){\n    this._events = this._events || {};\n    this._events[ name ] = this._events[ name ] || [];\n    this._events[ name ].push( callback );\n  },\n  emit: function( name ){\n    this._events = this._events || {};\n    var args = Array.prototype.slice.call( arguments, 1 ),\n       me = this;\n    if( this._events[ name ] ){\n      $.each( this._events[ name ], function( k, v ){\n        v.call( me, args );\n      } )\n    }\n  }   \n}</code></pre><p>再抽象一个函数用于为对象复制属性</p><pre><code>function extend( source ){\n  var args = Array.prototype.slice.call( arguments, 1 );\n  for( var i = 0, parent; parent = args[i]; i++ ){\n    for( var prop in parent ){\n      source[ prop ] = parent[ prop ];\n    }\n  }\n}</code></pre><p>实现一个Dialog，\n<br>仅实现创建; method: show / hide; event: show / hide;\n<br>看效果时，加上这段样式</p><pre><code>.dialog{\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  margin: -50px 0 0 -100px;\n  width: 200px;\n  height: 120px;\n  background: #fff;\n  border: 5px solid #afafaf;\n}</code></pre><p>实现组件</p><pre><code>var Dialog = function( config ){\n  this.config = config;\n  this.init( this.config );\n};</code></pre><p>扩展属性</p><pre><code>extend( Dialog.prototype, {\n \n  init: function( config ){\n    this.render( config )\n  },\n \n  render: function( config ){\n    this.el = $( '&lt;div&gt;' ).addClass( 'dialog' );\n    this.el.html( config.content );\n    $( 'body' ).append( this.el );\n  },\n \n  show: function( param ){\n    this.el.fadeIn();\n    this.emit( 'show', param );\n  },\n \n  hide: function( param ){\n    this.el.fadeOut();\n    this.emit( 'hide', param );\n  }\n \n}, Events );</code></pre><p>生成实例，并为其添加三个show及hide监听事件</p><pre><code>var dialog = window.dialog = new Dialog({\n  content: 'dialog one'\n});\n \ndialog.on( 'show', function( txt ){\n  console.log( 'dialog show one ' + txt );\n} );\n \n//do something\n \ndialog.on( 'show', function( txt ){\n  console.log( 'dialog show two ' + txt );\n} );\n \n//do something\n \ndialog.on( 'show', function( txt ){\n  console.log( 'dialog show three ' + txt );\n} );\n \n//do something\n \ndialog.on( 'hide', function( txt ){\n  console.log( 'dialog hide one ' + txt );\n} );\n \n//do something\n \ndialog.on( 'hide', function( txt ){\n  console.log( 'dialog hide two ' + txt );\n} );\n \n//do something\n \ndialog.on( 'hide', function( txt ){\n  console.log( 'dialog hide three ' + txt );\n} );</code></pre><p>我们分六次添加了六个不同的show事件和hide事件。\n<br>当执行 dialog.show() 时就会输出三条对应的日志。添加的事件保存在 dialog._events里</p><p>添加的三个show都输出成功，事件保存在_events属性里\n<br>nodejs Events也是实现了这一过程。&nbsp;</p><p><br>三、结构</p><pre><code>var Events = require( 'events' );\nconsole.log( Events );\n/*\n输出如下数据，可以看出 Events指向其EventEmiter\n{ [Function: EventEmitter]\n  EventEmitter: [Circular],\n  usingDomains: [Getter/Setter],\n  defaultMaxListeners: 10,\n  init: [Function],\n  listenerCount: [Function] }\n*/\n \nvar myEmitter = new Events();\nconsole.log( myEmitter );\n/*\n{ domain: null,\n  _events: {},   //可以看到实例本身也有_events属性，添加的监听的事件就保存在这里\n  _maxListeners: undefined}\n*/\n \nconsole.log( myEmitter.__proto__ );\n/*\n{ domain: undefined,\n  _events: undefined,\n  _maxListeners: undefined,\n  setMaxListeners: [Function: setMaxListeners],\n  emit: [Function: emit],\n  addListener: [Function: addListener],\n  on: [Function: addListener],\n  once: [Function: once],\n  removeListener: [Function: removeListener],\n  removeAllListeners: [Function: removeAllListeners],\n  listeners: [Function: listeners] }\n*/\n \nmyEmitter.on( 'show', function( txt ){ console.log( 'one ' + txt )})\nmyEmitter.on( 'show', function( txt ){ console.log( 'tow ' + txt )})\nmyEmitter.on( 'hide', function( txt ){ console.log( 'one ' + txt )})\nmyEmitter.emit( 'show', 'show' );\nmyEmitter.setMaxListeners( 10 );\nconsole.log( myEmitter );\n/*\n{ domain: null,\n  _events: { show: [ [Function], [Function] ], hide: [Function] }, //添加后的事情，以json形式存放\n  _maxListeners: 10 }\n*/</code></pre><p>四、API\n<br>其提供的method有on，是addListener的简写都是为实例添加监听事件，其它属性也都顾名思义，就简单说明下</p><pre><code>property\n_events: undefined,   //以压栈形式存放on进来的事件\n_maxListeners: undefined  //设置最大监听数，超出提warn\n \n----------------------------------------------------------------------------------------------------------------\n \nmethod\nsetMaxListeners: [Function: setMaxListeners], \n/*设置私有属性_maxListeners的值，默认Events会在当某监听事件多于10个时发现警告(见上面Events.defaultMaxListeners)，以防止内存泄露，如\n(node) warning: possible EventEmitter memory leak detected. 11 show listeners added. Use emitter.setMaxListeners() to increase limit.\n但这只是个友好的提醒，可以通过设置最大监听数来规避这个问题\nmyEmitter.setMaxListeners( 20 );\n*/\n \nemit: [Function: emit],\n /*触发监听事件\nemitter.emit( event, [arg1], [arg2], ... )\n如myEmitter.on( 'show', 'prompt content' );\n 参数1为事件名，参数二供on回调里的参数\n */\n \naddListener: [Function: addListener],\n /*\n添加监听事件\nemitter.addListener( event, listener );\n如 myEmitter.addListener( 'show', function( txt ){ console.log( txt ) } );\n参数一是事件名，参数二是对应的回调，回调里的参数就是 emit里的arguments.prototype.slice.call(1);\n */\n \non: [Function: addListener],\n /*\n是addListener简写\n */\n \nonce: [Function: once],\n /*\n作用同 on，不过emit一次后就失效了\nemitter.once( event, listener );\n如 myEmitter.once( 'show', function( txt ){ console.log( txt ) } );\n当myEmitter.emit执行第二次时没有输出\n */\n \nremoveListener: [Function: removeListener],\n /*\n移除指定事件的指定回调，此时回调不能再用匿名函数。\nemitter.removeListener( event, listener );\n如 \nfunction show( txt ){ console.log( txt ) };\nmyEmitter.on( 'show', show );\nconsole.log( myEmitter._events ); \n// { show: [ Function: show ] }\nmyEmitter.removeListener( 'show', show );  \n console.log( myEmitter._events ); \n// {}\n */\n \nremoveAllListeners: [Function: removeAllListeners],\n /*\n 删除指定事件的所有回调\n emitter.removeAllListeners( [ event ] );\n 如 \n  myEmitter.removeAllListeners( 'show' );   //删除所有show监听\n  myEmitter.removeAllListeners();   //删除所有监听\n */\n \nlisteners: [Function: listeners]\n/*\n查看指定监听\nemitter.listeners( event );\n如 myEmitter.listeners( 'show' ); //返回一个数组\n同我们前面使用的 myEmitter._events[ 'show' ]\n*/\n \n另外Events类本身提供了一个方法\nEvents.listenerCount( emitter, event ); 获取指定实例下指定监听数\n如 Event.listenerCount( myEmitter, 'show' )\n \n-----------------------------------------------------------------------------------------------\n \n还有两个event\nnewListener / remoteListener，分别应用于为实例添加（ on / once ）和删除( removeListener ) 操作。\nemitter.on( event, listener );\nemitter.on( 'newListener', function( event, listener ){\n  console.log( emitter.listeners( 'show' ) );   //注意，此时监听还并没有添加到 emitter.listeners\n  console.log( arguments );  \n });\n \n emitter.on( 'removeListener', function(){\n  console.log( emitter.listeners( 'show' ) );\n  console.log( arguments );\n })</code></pre><p>五、应用\n<br>使用Events，通常就直接实例化即可，如上面API部分所例\n<br>不过，如果我们在nodejs端也实现了一个组件，如前面的Dialog，如何让Dialog也具备Events的功能呢？可以用Extjs实现的 extend方案\n<br>创建Dialog构建器</p><pre><code>var Dialog = function(){\n  //do something\n}\n \n//抽象apply函数，提供属性的深度复制，同上面的extend\nfunction apply( source ){\n  var args = Array.prototype.slice.call( arguments, 1 );\n  for( var i = 0, parent; parent = args[i]; i++ ){\n    for( var prop in parent ){\n      source[ prop ] = parent[ prop ];\n    }\n  }\n}\n \n//抽象extend函数，用于实现继承\nvar extend = function(){\n  // inline overrides\n  var io = function(o){\n    for(var m in o){\n      this[m] = o[m];\n    }\n  };\n  var oc = Object.prototype.constructor;\n \n  return function(sb, sp, overrides){\n    if(typeof sp == 'object'){\n      overrides = sp;\n      sp = sb;\n      sb = overrides.constructor != oc ? overrides.constructor : function(){sp.apply(this, arguments);};\n    }\n    var F = function(){},\n      sbp,\n      spp = sp.prototype;\n \n    F.prototype = spp;\n    sbp = sb.prototype = new F();\n    sbp.constructor=sb;\n    sb.superclass=spp;\n    if(spp.constructor == oc){\n      spp.constructor=sp;\n    }\n    sb.override = function(o){\n      apply(sb, o);\n    };\n    sbp.superclass = sbp.supr = (function(){\n      return spp;\n    });\n    sbp.override = io;\n    apply(sb, overrides);\n    sb.extend = function(o){return extend(sb, o);};\n    return sb;\n  };\n}();\n \n//将Events属性继承给Dialog\nDialog = extend( Dialog, Events );\n \n//为Dialog新增 method show，其内触发 event show\nDialog.prototype.show = function( txt ){\n  this.emit( 'show', txt );\n}\n \nvar dialog = new Dialog();\n \n//添加监听事件show\ndialog.on( 'show', function(txt){ console.log( txt )});\n \n//执行method show时，就会触发其内定义的show events，输出 this is show\ndialog.show( 'this is show' );</code></pre><p>这样就为一个组件实现了Events机制，当调用method时，会触发event\n<br>六、总结\n<br>nodejs提供了很好的监听机制，并且也应用在其所有模块，其支持了nodejs最特色的I/O模式，如我们启动http服务时会监听其 connect / close，http.request时会监听 data / end等，了解监听机制对学习理解nodejs的基础，也对提升编程思想有益。</p>"}}
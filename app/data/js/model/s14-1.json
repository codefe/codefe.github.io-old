{"sta":1,"data":{"subTitle":"策略模式","content":"<h3>策略模式</h3><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>策略模式是把一个类中经常改变或者将来可能改变的部分提取出来作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。</p><h3>策略模式要素</h3><p>1.Strategy：策略接口，用来约束一系列具体的策略算法。Context使用这个接口来调用具体的策略，实现定义的策略。<br>2.ConcreteStrategy：具体的策略实现，也就是具体的算法实现。<br>3.Context：上下文，负责与具体的策略交互，通常上下文会持有一个真正的策略实现。</p><p><h3>策略模式优点</h3>1.算法可以自由切换。\n<br>2.避免使用多重条件判断。\n<br>3.扩展性良好。\n<br>\n<br><h3>策略模式缺点</h3>1.策略类会增多。\n<br>2.所有策略类都需要对外暴露。\n<br>\n<br><h3>适用场景</h3>1.如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n<br>2.一个系统需要动态地在几种算法中选择一种。\n<br>3.一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</p><h3>实例</h3><p></p><p>现在车的价格可能根据市场需求变动随时调整，对于不同销售商订购辆数进行优惠。</p><pre><code>// 策略模式\n\nvar DP = require(\"./DesignPattern.js\");\nfunction Strategy() {\n  DP.Interface(this, ['calPrice']);\n}\n\nfunction Nodiscount() {\n  this.__proto__ = new Strategy();\n  this.calPrice = function (price, num) {\n    return price * num;\n  }\n}\n\nfunction Disount1() {\n  this.__proto__ = new Strategy();\n  this.calPrice = function (price, num) {\n    return price * num * 0.95;\n  }\n}\n\nfunction Context(strategy) {\n  var _strategy=strategy;\n  this.calPrice = function (price, num) {\n    return _strategy.calPrice(price, num)\n  }\n}\n\nvar nodiscount = new Nodiscount();\nvar disount1 = new Disount1();\n\nvar nodiscountContext = new Context(nodiscount);\nconsole.log(\"Nodiscount策略购买3辆总金额: \" + nodiscountContext.calPrice(10000,3));\nvar disount1Context = new Context(disount1);\nconsole.log(\"disount1策略购买3辆总金额: \" + disount1Context.calPrice(10000,3));</code></pre><p><br></p>"}}
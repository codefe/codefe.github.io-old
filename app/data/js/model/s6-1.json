{"sta":1,"data":{"subTitle":"工厂模式","content":"<h3>工厂模式</h3><p>之前讲了接口，封装，继承，单例等，现在就需要应用这些特性来完成一些设计模式了。首先吧之前的代码打包成一个新的JS</p><p></p><h3>DesignPattern.js</h3><pre><code>// 设计模式公用代码     \nexports.Interface = function (object, methods) {\n  for (var i = 0, len = methods.length; i &lt; len; i++) {\n    if (typeof methods[i] !== 'string') {\n      throw new Error('Interface constructor expects method names to be passed in as a string.');\n    }\n    object[methods[i]] = function () {\n      throw new Error(this.constructor.name + ' Interface function is undefined');\n    };\n  }\n};\n\nexports.Extend = function (subClass, superClass) {\n  var F = function () {\n  };\n  F.prototype = superClass.prototype;\n  subClass.prototype = new F();\n  subClass.prototype.constructor = subClass;\n\n  subClass.superclass = superClass.prototype;\n  if (superClass.prototype.constructor == Object.prototype.constructor) {\n    superClass.prototype.constructor = superClass;\n  }\n}\n\nexports.Clone = function (object) {\n  function F() {\n  }\n\n  F.prototype = object;\n  return new F;\n}\n\nexports.Augment = function (receivingClass, givingClass) {\n  if (arguments[2]) { // Only give certain methods.\n    for (var i = 2, len = arguments.length; i &lt; len; i++) {\n      receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];\n    }\n  }\n  else { // Give all methods.\n    for (methodName in givingClass.prototype) {\n      if (!receivingClass.prototype[methodName]) {\n        receivingClass.prototype[methodName] = givingClass.prototype[methodName];\n      }\n    }\n  }\n}</code></pre><p><h3>工厂模式要点\n</h3>1.工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。\n<br>\n<br>2.工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。\n<br>\n<br><h3>适用场景：\n</h3>1.在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，无需使用工厂模式。\n<br>\n<br>2.工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。\n<br>\n<br>3.当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n<br>\n<br><h3>代码</h3></p><pre><code>var DP = require(\"./DesignPattern.js\");\n\nfunction CarFactory() {//定义工厂\n  this.run = function () {\n    console.log(this.productCar()+'启动');\n  }\n  DP.Interface(this, ['productCar']);\n}\n\nfunction PorscheFactory() {//实例化保时捷工厂\n  this.__proto__ = new CarFactory();\n  this.productCar = function () {\n    return '保时捷';\n  }\n}\n\nfunction TractorFactory() {//实例化拖拉机工厂并不重写接口测试接口定义\n  this.__proto__ = new CarFactory();\n}\n\nvar Porsche = new PorscheFactory();\nPorsche.run();\n\n\nvar Tractor = new TractorFactory();\nTractor.run();</code></pre><p><h3>总结\n</h3>由于javascript没有原生接口，所以需要自己想方法来实现接口这个原则。使用了接口以后就可以方便实现工厂模式。</p>"}}
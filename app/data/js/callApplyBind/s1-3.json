{"sta":1,"data":{"subTitle":"bind","content":"<p><h3>fun.bind(context,[arg1],[arg2],[…])\n</h3>使fun方法执行的context永不变。\n<br>arg1:要传递到新函数的参数列表\n<br>返回一个函数供后续调用，其函数体和原函数fun一样，但新函数的this指向新传入的context对象。新函数会具有bind方法指定的初始参数arg1/arg2...，后续调用新函数时的实参要往已有参数的后面排。</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); white-space: pre-wrap;\">//原来的函数有4个参数</span><br></p><pre><code>var displayArgs = function (val1, val2, val3, val4) {\n  console.log(val1 + \" \" + val2 + \" \" + val3 + \" \" + val4);\n}\nvar emptyObject = {};\n// 生成新函数时bind方法指定了2个参数，则新函数会带着这个两个实参\nvar displayArgs2 = displayArgs.bind(emptyObject, 12, \"a\");\n// 调用时传入另2个参数，要在bind方法传入的2个实参后面\ndisplayArgs2(\"b\", \"c\");\n// Output: 12 a b c</code></pre><p>事件处理函数中使用bind：</p><pre><code>var obj = {\n  arg1 : 1,\n  attach: function(){\n    //var self = this; 普通传入this 的方法\n    $('xxx').on('click',function (event) {\n      console.log(this.arg1);//若不绑定this，回调函数中的this常指目标元素\n     }.bind(this));  //使用bind方法绑定this\n  }\n}</code></pre><p>使用bind()方法改写slice()方法：</p><pre><code>var _Slice = Array.prototype.slice;\nvar slice = Function.prototype.call.bind(_Slice);\nslice(…);</code></pre><p>bind()兼容Ie5~ie8处理</p><pre><code>if (!Function.prototype.bind) {\n  Function.prototype.bind = function(context) {\n    var self = this, // 调用bind方法的目标函数\n    args = arguments;\n    return function() {\n      self.apply(context, Array.prototype.slice.call(args, 1));//参数个数不确定时用apply\n    }\n  }\n}</code></pre><p>一般情况下setTimeout()的this指向window或global对象。当使用类的方法时需要this指向类实例，就可以使用bind()将this绑定到调用对象，而不用传入self方式传入this。</p>"}}
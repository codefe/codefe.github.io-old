{"sta":1,"data":{"subTitle":"串联 Promises","content":"<p>Promises最大的一个特征是，你可以串联各种操作。对于fetch来说，我们可以在各个fetch操作里共享一些逻辑操作。</p><p></p><p>在使用JSON API时，我们需要检查每次请求响应的状态，然后解析成JSON对象。使用promise，我们可以简单的将分析状态和解析JSON的代码放到一个单独函数里，然后当做promise返回，这样就是代码更条理了。</p><pre><code>function status(response) {  \n  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {  \n    return Promise.resolve(response)  \n  } else {  \n    return Promise.reject(new Error(response.statusText))  \n  }  \n}\n\nfunction json(response) {  \n  return response.json()  \n}\n\nfetch('users.json')  \n  .then(status)  \n  .then(json)  \n  .then(function(data) {  \n    console.log('Request succeeded with JSON response', data);  \n  }).catch(function(error) {  \n    console.log('Request failed', error);  \n  });</code></pre><p>我们用 status 函数来检查 response.status 并返回 Promise.resolve() 或 Promise.reject() 的结果，这个结果也是一个 Promise。我们的fetch() 调用链条中，首先如果fetch()执行结果是 resolve，那么，接着会调用 json() 方法，这个方法返回的也是一个 Promise，这样我们就得到一个分析后的JSON对象。如果分析失败，将会执行reject函数和catch语句。\n<br>\n<br>你会发现，在fetch请求中，我们可以共享一些业务逻辑，使得代码易于维护，可读性、可测试性更高。</p>"}}
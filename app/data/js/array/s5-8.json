{"sta":1,"data":{"subTitle":"删除数组中重复项（uniq）","content":"<p>巧妙去除数组中的重复项的方法参考，&nbsp;可以直接使用的代码:脚本之家修正版</p><pre><code>&lt;script&gt; \nfunction unique(data){ \ndata = data || []; \nvar a = {}; \nlen = data.length; \nfor (var i=0; i&lt;len;i++){ \nvar v = data[i]; \nif (typeof(a[v]) == 'undefined'){ \na[v] = 1; \n} \n}; \ndata.length=0; \nfor (var i in a){ \ndata[data.length] = i; \n} \nreturn data; \n} \nfunction test(){ \nvar arr = [9,1,3,8,7,7,6,6,5,7,8,8,7,4,3,1]; \nvar arr1 = unique(arr); \nalert(arr1.join(\",\")); \n} \ntest(); \n&lt;/script&gt;</code></pre><p>下面是进阶教程与说明，喜欢跟深入的朋友可以参考下。\n<br>首先让我们看下 YUI 是如何处理的：&nbsp;</p><pre><code>var toObject = function(a) { \nvar o = {}; \nfor (var i = 0; i &lt; a.length; i = i+1) { \no[a[i]] = true; \n} \nreturn o; \n}; \n\nvar keys = function(o) { \nvar a=[], i; \nfor (i in o) { \nif (lang.hasOwnProperty(o, i)) { // YUI的方法 \na.push(i); \n} \n} \nreturn a; \n}; \n\nvar uniq = function(a) { \nreturn keys(toObject(a)); \n};</code></pre><p>详细分析，见同事 长天 的分享 《巧妙去除数组中的重复项》。 \n<br>\n<br>自己使用的方式与 YUI 的方式十分相似，不过仅使用了一次循环便完成了删除数组中重复项，如下：</p><pre><code>var uniq = function (arr) { \nvar a = [], \no = {}, \ni, \nv, \nlen = arr.length; \n\nif (len &lt; 2) { \nreturn arr; \n} \n\nfor (i = 0; i &lt; len; i++) { \nv = arr[i]; \nif (o[v] !== 1) { \na.push(v); \no[v] = 1; \n} \n} \n\nreturn a; \n}</code></pre><p>经过了简单的测试：自己使用的方式性能远远高于 YUI 的方式。 \n<br>\n<br>抛砖引玉，欢迎大家提供更好的处理方法。 \n<br>\n<br>2009年12月28日更新： \n<br>\n<br>以上两种函数方法暂时都不能处理复杂的含有混合类型的数组（感谢 小猫 提出的疑问），如：[0,\"0\",1,\"1\",0]、[\"null\",null]。 \n<br>\n<br>对于能够约定类型为数字（注：要求非0开头的数字，小数除外）或字符串的数组，我们可以用改进后的函数方法（感谢 closurecache 提供的思路）：</p><pre><code>var uniq = function (arr) { \nvar a = [], \no = {}, \ni, \nv, \ncv, // corrected value \nlen = arr.length; \n\nif (len &lt; 2) { \nreturn arr; \n} \n\nfor (i = 0; i &lt; len; i++) { \nv = arr[i]; \n\n/* closurecache 提供的函数中使用的是 cv = v + 0;， \n* 这样就无法辨别类似[1, 10, \"1\", \"10\"]的数组， \n* 因为运算后 =&gt; 1, 10, 10, 100，很明显，出现了重复的标示符。 \n* 加前面就难道没问题吗？ \n* 有的：数组中不能出现类似01 、001，以 0 开头的数字， \n* 但适用性比原先更广。 \n*/ \ncv = 0 + v; \n\nif (!o[cv]) { \na.push(v); \no[cv] = true; \n} \n} \n\nreturn a; \n}</code></pre><p>如果大家想在此解题思路的基础上，更完美一点，推荐 Dexter.Yy 的方法，进行类型判断，给予唯一标示符，详见 评论 20 楼。 \n<br>\n<br>没有最好，只有最合适的方式，其实使用 Array.indexOf() 的思路也是不错的选择，对于已经支持的浏览器直接用原生的 Array.indexOf() 方法，对于未支持的，我们增加 Array.indexOf() 方法，如下：</p><pre><code>if(!Array.prototype.indexOf) { \nArray.prototype.indexOf = function (obj, fromIndex) { \nif (fromIndex == null) { \nfromIndex = 0; \n} else if (fromIndex &lt; 0) { \nfromIndex = Math.max(0, this.length + fromIndex); \n} \n\nfor (var i = fromIndex; i &lt; this.length; i++) { \nif (this[i] === obj) \nreturn i; \n} \nreturn -1; \n}; \n}</code></pre><p>接下来，实现的过程就非常简单了。 \n<br>\n<br>对于使用 Array.indexOf() 方法实现方案的优化提示：找到相同值时，从数组中移除，以减少下次遍历的量。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;<br></p><p>&nbsp;</p>"}}
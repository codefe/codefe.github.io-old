{"sta":1,"data":{"subTitle":"数组去重的六种方法汇总","content":"<p>面试前端必须准备的一个问题：怎样去掉Javascript的Array的重复项。据我所知，百度、腾讯、盛大等都在面试里出过这个题目。 这个问题看起来简单，但是其实暗藏杀机。 考的不仅仅是实现这个功能，更能看出你对计算机程序执行的深入理解。</p><p></p><p>&nbsp; &nbsp; 我总共想出了三种算法来实现这个目的：</p><pre><code>Array.prototype.unique1 = function()\n{\n var n = []; //一个新的临时数组\n for(var i = 0; i &lt; this.length; i++) //遍历当前数组\n {\n //如果当前数组的第i已经保存进了临时数组，那么跳过，\n //否则把当前项push到临时数组里面\n if (n.indexOf(this[i]) == -1) n.push(this[i]);\n }\n return n;\n}\nArray.prototype.unique2 = function()\n{\n var n = {},r=[]; //n为hash表，r为临时数组\n for(var i = 0; i &lt; this.length; i++) //遍历当前数组\n {\n if (!n[this[i]]) //如果hash表中没有当前项\n {\n  n[this[i]] = true; //存入hash表\n  r.push(this[i]); //把当前数组的当前项push到临时数组里面\n }\n }\n return r;\n}\nArray.prototype.unique3 = function()\n{\n var n = [this[0]]; //结果数组\n for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历\n {\n //如果当前数组的第i项在当前数组中第一次出现的位置不是i，\n //那么表示第i项是重复的，忽略掉。否则存入结果数组\n if (this.indexOf(this[i]) == i) n.push(this[i]);\n }\n return n;\n}</code></pre><p>其中第1种和第3种方法都用到了数组的indexOf方法。此方法的目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。 而第2中方法用的是hash表。把已经出现过的通过下标的形式存入一个object内。下标的引用要比用indexOf搜索数组快的多。\n<br>    为了判断这三种方法的效率如何，我做了一个测试程序，生成一个10000长度的随机数组成的数组，然后分别用几个方法来测试执行时间。 结果表明第二种方法远远快于其他两种方法。 但是内存占用方面应该第二种方法比较多，因为多了一个hash表。这就是所谓的空间换时间。  就是这个测试页面，你也可以去看看。\n<br>根据hpl大牛的思路，我写了第四种方法：</p><pre><code>Array.prototype.unique4 = function()\n{\n this.sort();\n var re=[this[0]];\n for(var i = 1; i &lt; this.length; i++)\n {\n if( this[i] !== re[re.length-1])\n {\n  re.push(this[i]);\n }\n }\n return re;\n}</code></pre><p>这个方法的思路是先把数组排序，然后比较相邻的两个值。 排序的时候用的JS原生的sort方法，JS引擎内部应该是用的快速排序吧。 最终测试的结果是此方法运行时间平均是第二种方法的三倍左右，不过比第一种和第三种方法快了不少。\n<br>第五种方法\n<br>最近在做【搜索历史记录】功能也用到，开始用了 indexOf 方法，该方法在 ECMA5才有支持，对于 IE8- 就不支持了。\n<br>我们可以自己写一个函数(Array对象的方法都是定义在原型对象上的)，如下：</p><pre><code>Array.prototype.unique = function(){\n  var length = this.length;\n  if(length &lt;= 1){\n    return this;\n  }\n  if(!Array.prototype.indexOf){    \n    Array.prototype.indexOf = function(item){\n      var l = this.length, i = 0, r = -1;\n      if(l &lt;= 0){\n　　　　　　 　　return -1;\n　　　　　　　}\n      for(; i &lt; l; i++){\n        if(this[i] === item){\n          r = i;\n        }\n      }\n      return r;\n    }\n  }\n   \n  var result = []; //去重数组\n  for(var i = 0; i &lt; length; i++){\n    if(result.indexOf(this[i]) === -1){\n      result.push(this[i]);\n    }\n  }\n  return result;\n}</code></pre><p>第六种方法\n<br>Array类型并没有提供去重复的方法，如果要把数组的重复元素干掉，那得自己想办法：</p><pre><code>function unique(arr) {\n  var result = [], isRepeated;\n  for (var i = 0, len = arr.length; i &lt; len; i++) {\n    isRepeated = false;\n    for (var j = 0, len = result.length; j &lt; len; j++) {\n      if (arr[i] == result[j]) {  \n        isRepeated = true;\n        break;\n      }\n    }\n    if (!isRepeated) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}</code></pre><p>总体思路是把数组元素逐个搬运到另一个数组，搬运的过程中检查这个元素是否有重复，如果有就直接丢掉。从嵌套循环就可以看出，这种方法效率极低。我们可以 用一个hashtable的结构记录已有的元素，这样就可以避免内层循环。</p><p><br></p>"}}
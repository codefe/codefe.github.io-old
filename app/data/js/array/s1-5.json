{"sta":1,"data":{"subTitle":"数组排序详解","content":"<p>JavaScript实现多维数组、对象数组排序,其实用的就是原生的sort()方法,用于对数组的元素进行排序。今天我们就来详细探讨下sort（）方法&nbsp;</p><p>如果你接触javascript有一段时间了，你肯定知道数组排序函数sort，sort是array原型中的一个方法，即array.prototype.sort(),sort(compareFunction),其中compareFunction是一个比较函数，下面我们看看来自Mozilla MDN 的一段描述:\n<br>If compareFunction is not supplied, elements are sorted by converting them to strings and comparing strings in lexicographic (“dictionary” or “telephone book,” not numerical) order. For example, “80″ comes before “9″ in lexicographic order, but in a numeric sort 9 comes before 80.\n<br></p><p>下面看些简单的例子：</p><pre><code>// Output [1, 2, 3]\nconsole.log([3, 2, 1].sort());\n// Output [\"a\", \"b\", \"c\"]\nconsole.log([\"c\", \"b\", \"a\"].sort());\n// Output [1, 2, \"a\", \"b\"]\nconsole.log([\"b\", 2, \"a\", 1].sort());</code></pre><p>从上例可以看出，默认是按字典中字母的顺序来排序的。\n<br>幸运的是，sort接受一个自定义的比较函数，如下例：</p><pre><code>function compareFunction(a, b) {\n if( a &gt; b) {\n  return -1;\n }else if(a &lt; b) {\n  return 1;\n }else {\n  return 0;\n }\n}\n//Outputs [\"zuojj\", \"Benjamin\", \"1\"] \nconsole.log([\"Benjamin\", \"1\", \"zuojj\"].sort(compareFunction));</code></pre><p>排序完我们又有个疑问，如何控制升序和降序呢？</p><pre><code>function compareFunction(flag) {\n flag = flag ? flag : \"asc\";\n return function(a, b) {\n  if( a &gt; b) {\n   return flag === \"desc\" ? -1 : 1;\n  }else if(a &lt; b) {\n   return flag === \"desc\" ? 1 : -1;\n  }else {\n   return 0;\n  }\n };\n}\n//Outputs [\"1\", \"Benjamin\", \"zuojj\"] \nconsole.log([\"Benjamin\", \"1\", \"zuojj\"].sort(compareFunction()));\n//Outputs [\"zuojj\", \"Benjamin\", \"1\"] \nconsole.log([\"Benjamin\", \"1\", \"zuojj\"].sort(compareFunction(\"desc\")));</code></pre><p>comparFunction的排序规则是这样的：\n<br>1.If it returns a negative number, a will be sorted to a lower index in the array.\n<br>2.If it returns a positive number, a will be sorted to a higher index.\n<br>3.And if it returns 0 no sorting is necessary.\n<br>下面我们来看看摘自Mozilla MDN上的一段话：\n<br>The behavior of the sort method changed between JavaScript 1.1 and JavaScript 1.2.为了解释这段描述，我们来看个例子：\n<br>In JavaScript 1.1, on some platforms, the sort method does not work. This method works on all platforms for JavaScript 1.2.\n<br>In JavaScript 1.2, this method no longer converts undefined elements to null; instead it sorts them to the high end of the array.</p><pre><code>var arr = [];\narr[0] = \"Ant\";\narr[5] = \"Zebra\";\n//Outputs [\"Ant\", 5: \"Zebra\"] \nconsole.log(arr);\n//Outputs 6\nconsole.log(arr.length);\n//Outputs \"Ant*****Zebra\"\nconsole.log(arr.join(\"*\"));\n//排序\nvar sortArr = arr.sort();\n//Outputs [\"Ant\", \"Zebra\"] \nconsole.log(sortArr);\n//Outputs 6\nconsole.log(sortArr.length);\n//Outputs \"Ant*Zebra****\"\nconsole.log(sortArr.join(\"*\"));</code></pre><p><br></p><p>&nbsp;<br></p>"}}
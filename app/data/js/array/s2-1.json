{"sta":1,"data":{"subTitle":"详解数组去重问题","content":"<p>首先，我想到的是另建一个结果数组，用来存储原始数组中不重复的数据。遍历原始数组依次跟结果数组中的元素进行比较，检测是否重复。于是乎，我写出了如下<strong>代码A</strong>：&nbsp;</p><pre><code>Array.prototype.clearRepetitionA = function(){\n   var result = [];\n   var isRepetition;\n   for(var i=0; i&lt;this.length; i++){\n     isRepetition = false;\n     for(var j=0; j&lt;result.length; j++){\n       if(this[i] === result[j]){\n         isRepetition = true;\n         break;\n       }\n     }\n     if(!isRepetition){\n       result.push(this[i]);\n     }\n   }\n   return result;\n }</code></pre><p>写完之后，忽然想起来前几天刚看的ECMAScript 5中的数组方法indexOf 可以检索数组元素。于是我又使用indexOf 方法替代了第二层循环，写出了如下代码B：</p><pre><code>Array.prototype.clearRepetitionB = function(){\n   var result = [];\n   for(var i=0; i&lt;this.length; i++){\n     if(result.indexOf(this[i]) == -1){\n       result.push(this[i]);\n     }\n   }\n   return result;\n }</code></pre><p>代码一下子从17行变成了9行了，简洁多了。高三数学大题解法一般都不止一种的啊，然后我就继续再想其他方法了。indexOf 方法的意思是搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引，没有找到就返回 -1 ，第一个参数就是要搜索的值，第二个参数可选：它指定数组中的一个索引，从那里开始搜索，如果省略这个参数，则从头搜索。思维一发散，想到了前面方法都是检测值是否重复的，现在有了indexOf 方法不就可以根据检测到的每个元素的第一次出现时的索引和这个元素自身的索引值比较相等来判断是否重复嘛。所以，我又写出了代码C:</p><pre><code>Array.prototype.clearRepetitionC = function(){\n  var result = [this[0]];\n  for(var i=1; i&lt;this.length; i++){\n    if(this.indexOf(this[i]) == i){\n      result.push(this[i]);\n    }\n  }\n  return result;\n}</code></pre><p>写完这个，又继续想了想，实在是想不出其他方法了，这三个方法都是很基础的方法。于是，我就去对照答案，检验自己了。一看答案，发现自己还是真实太弱了，简单的问题还是有些奇思妙想的。下面不是自己想的了，就不再说太多我的心路历程了。废话不多说，直接上经典的答案+解析了。\n<br>首先，先说一个算法中经常说的以空间换时间的解法，保持队形，我们就叫它代码D吧：</p><pre><code>Array.prototype.clearRepetitionD = function(){\n   var result = [];\n   var obj = {};\n   var key,type;\n   for(var i=0; i&lt;this.length; i++){\n     key = this[i];\n     type = typeof key;\n     if(!obj[key]){\n       obj[key] = [type];\n       result.push(key);\n     }else if(obj[key].indexOf(type)){\n       obj[key].push(type);\n       result.push(key);\n     }\n   }\n   return result;\n }</code></pre><p>这个方法中在遍历原始数组时用一个对象 obj 的属性来保存原始数组中元素的值。同时这个属性的值是一个数组，用来存储这个属性的类型，这一点可以把原始数组中类似数字1元素和字符串‘1'的元素区分开。这个方法通过额外构建一个对象的方式降低了上面三种方法中indexOf方法所花费的时间，可以说较为高效吧。\n<br>如果你已经满足于上面所说的以空间换时间的高效方法而不继续看下去的话，那就大错特错了，好戏总在后头嘛。现在好戏开场，毫无疑问，就是代码E了：</p><pre><code>Array.prototype.clearRepetitionE = function(){\n  var result = [];\n  for(var i=0; i&lt;this.length; i++){\n    for(var j=i+1; j&lt;this.length; j++){\n      if(this[i] === this[j]){\n        j = ++i;\n      }\n    }\n    result.push(this[i]);\n  }\n  return result;\n}</code></pre><p>代码D以空间换时间，感觉也就一般般。那么代码E呢？这代码是错误的吧，这个真的能去重吗？是的，起初我都没看懂这代码，看了解析后又看了一遍之后才明白过来。那么，没看懂的看官也要认真的看解析了：第一层从前往后遍历原始数组，第二层循环是检测每个元素是否跟它之后的元素重复，如果它之后有重复元素则跳过它；如果这个元素之后所有元素都跟他不重复了，则把它添加到结果数组中。这个方法实现思路就是：获取无重复的最右一值添加到结果数组中，这个跟第一种方法相比也优化了第二层的循环，效率要比它高，不过这个方法的结果数组中元素的顺序跟原始数组中元素的顺序不一样了。\n<br>看完了代码E解析的你是不是已经伸出了大拇指、投放出了敬佩的目光呢？（这些鲜花和荣誉别给我，应该给写这个方法的大神去）。下面再说最后一个方法：那就是先排序，再去重。老规矩，它叫代码F：</p><pre><code>Array.prototype.clearRepetitionF = function(){\n   this.sort();\n   var result = [this[0]];\n   for(var i=1; i&lt;this.length; i++){\n     if(this[i] !== result[result.length-1]){\n       result.push(this[i]);\n     }\n   }\n   return result;\n }</code></pre><p>这个先用数组的排序方法sort进行数组元素排序，然后再进行去重工作。\n<br>以上就是对javascript数组去重问题的一步步研究，不断改进代码，总共分享了六段代码，希望大家认真学习，能够有所收获。</p><p>&nbsp;<br></p>"}}
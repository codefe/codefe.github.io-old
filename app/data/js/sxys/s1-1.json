{"sta":1,"data":{"subTitle":"数学运算介绍","content":"<p>JavaScript中，数学运算可藉由两种操作来实现：</p><p></p><p>1.+、-、*、/、%等操作符。<br>2.使用Math对象的计算函数。比如，用Math.pow(2,3)来计算2的3次方。</p><p></p><p>与Java不同，JavaScript中的数学运算不会抛出任何错误。计算结果的溢出、除以0、对负数进行开方这些操作都是合法的，其结果为JavaScript中的特殊值：正负Infinity(无限)、正负0、NaN(非数)：</p><p></p><p>1.正负Infinity。当计算结果比JavaScript所能表示的最大数(Number.MAX_VALUE)还要大时，结果为正Infinity；当计算结果比JavaScript所能表示的最小数(-Number.MAX_VALUE)还要小时，结果为负Infinity。与Infinity相关的+、-、*、/等数学运算均遵循高等数学中关于极限计算的规则。1/0的结果为正Infinity，-1/0的结果则为负Infinity。</p><p></p><p>2.正负0。当计算结果为正，但小于JavaScript所能表示的最小小数(Number.MIN_VALUE)时，结果为正0；当计算结果为负，但大于JavaScript所能表示的最大负小数(-Number.MIN_VALUE)时，结果为负0。一般情况下，开发人员不需要关心正负0之间的区别。</p><p></p><p>3.NaN。对于某些即使用正负Infinity也无法表示的特殊计算结果，JavaScript使用NaN来表示(值得注意的是，虽然NaN的字面意思是“非数”，但其类型却是number)。这些特殊计算包括：</p><p></p><p>1).0/0。<br>2).Infinity/Infinity。<br>3).对负数进行开方。<br>4).对非数值的字符串进行数值转换操作。</p><p></p><p>对于Infinity和NaN，它们既是“无限”和“非数”的打印结果，同时也是JavaScript中表示这两个特殊值的全局变量名。事实上，在ECMAScript 3中，这两个全局变量还可以被赋以其它值；ECMAScript 5中对这一令人抓狂的规则进行了修正，使得这两个全局变量为只读。除了直接访问Infinity变量和NaN变量，还可以通过访问Number对象的成员变量来使用这两个特殊值：</p><p></p><p>1.Infinity与Number.POSITIVE_INFINITY是等价的。<br>2.-Infinity与Number.NEGATIVE_INFINITY是等价的。<br>3.NaN与Number.NaN是等价的。</p><p></p><p>在JavaScript中，NaN是一个很有趣的特殊值，它有一个特殊属性：与其它任何值(包括自身)都不相等。判定某个值是否为NaN可以有两个方法：</p><p></p><p>1.对于变量x，判定x!=x是否为true。此表达式仅当x为NaN时为true。</p><p>2.对于变量x，调用JavaScript中的全局函数isNaN()，判定isNaN(x)是否为true。用该方法判定NaN其实并不严谨，因为在4种情况下表达式isNaN(x)均为true：</p><p></p><p>1).x为NaN。<br>2).x为字符串，且该字符串不是数字。<br>3).x为对象。<br>4).x为undefined。</p><p></p><p>除了isNaN()，JavaScript还有另外一个有用的全局函数：isFinite()。对于变量a，isFinite(a)在以下几种情况下为true：</p><p></p><p>1).a为number，但不为NaN或正负Infinity。<br>2).a为字符串，但该字符串的内容为非NaN、非正负Infinity的数字。<br>3).a为null。<br>4).a为boolean值。</p><p><br>由于null、undefined等非数值类型会对结果产生影响，因此个人认为最好在使用isNaN()或isFinite()之前判断参数的类型。</p><h3>实验</h3><pre><code>//Test Infinity\nvar a = Number.MAX_VALUE;\nconsole.log(a*1.1);//Infinity\nconsole.log(a*-1.1);//-Infinity\nconsole.log(1/0);//Infinity\nconsole.log(-1/0);//-Infinity\n//Test positive/negative 0\nvar b = Number.MIN_VALUE;\nconsole.log(b/2);//0\nconsole.log(-b/2);//0\n//Test NaN\nconsole.log(0/0);//NaN\nconsole.log(Infinity/Infinity);//NaN\nconsole.log(Math.sqrt(-1));//NaN\nconsole.log(parseInt(\"string\"));//NaN\n//Test Infinity comparison\nconsole.log(Infinity === Number.POSITIVE_INFINITY);//true\nconsole.log(-Infinity === Number.NEGATIVE_INFINITY);//true\n//Test NaN comparison\nconsole.log(NaN === NaN);//false\n//Test isNaN()\nconsole.log(isNaN(NaN));//true\nconsole.log(isNaN(\"42\"));//false\nconsole.log(isNaN(\"string\"));//true\nconsole.log(isNaN({}));//true\nconsole.log(isNaN(undefined));//true\nconsole.log(isNaN(null));//false\n//Test isFinite()\nconsole.log(isFinite(42));//true\nconsole.log(isFinite(Infinity));//false\nconsole.log(isFinite(NaN));//false\nconsole.log(isFinite(\"29\"));//true\nconsole.log(isFinite(\"string\"));//false\nconsole.log(isFinite(null));//true\nconsole.log(isFinite(undefined));//false\nconsole.log(isFinite(true));//true\nconsole.log(isFinite(false));//true</code></pre><p><br></p>"}}
{"sta":1,"data":{"subTitle":"浮点运算精度问题分析与解决","content":"<p>浮点数的精度问题不是JavaScript特有的，因为有些小数以二进制表示位数是无穷的&nbsp;</p><p>分析\n<br>JavaScript 只有一种数字类型 Number ，而且在Javascript中所有的数字都是以IEEE-754标准格式表示的。 浮点数的精度问题不是JavaScript特有的，因为有些小数以二进制表示位数是无穷的：\n<br>十进制           二进制\n<br>0.1              0.0001 1001 1001 1001 ...\n<br>0.2              0.0011 0011 0011 0011 ...\n<br>0.3              0.0100 1100 1100 1100 ...\n<br>0.4              0.0110 0110 0110 0110 ...\n<br>0.5              0.1\n<br>0.6              0.1001 1001 1001 1001 ...\n<br>所以比如 1.1 ，其程序实际上无法真正的表示 ‘1.1'，而只能做到一定程度上的准确,这是无法避免的精度丢失：\n<br>1.09999999999999999\n<br>在JavaScript中问题还要复杂些，这里只给一些在Chrome中测试数据：\n<br> 输入               输出\n<br>1.0-0.9 == 0.1     False\n<br>1.0-0.8 == 0.2     False\n<br>1.0-0.7 == 0.3     False\n<br>1.0-0.6 == 0.4     True\n<br>1.0-0.5 == 0.5     True\n<br>1.0-0.4 == 0.6     True\n<br>1.0-0.3 == 0.7     True\n<br>1.0-0.2 == 0.8     True\n<br>1.0-0.1 == 0.9     True\n<br>解决\n<br></p><p>那如何来避免这类 1.0-0.9 != 0.1 的非bug型问题发生呢？下面给出一种目前用的比较多的解决方案, 在判断浮点运算结果前对计算结果进行精度缩小，因为在精度缩小的过程总会自动四舍五入:</p><p>代码如下:</p><pre><code>(1.0-0.9).toFixed(digits)                   // toFixed() 精度参数须在 0 与20 之间\nparseFloat((1.0-0.9).toFixed(10)) === 0.1   // 结果为True\nparseFloat((1.0-0.8).toFixed(10)) === 0.2   // 结果为True\nparseFloat((1.0-0.7).toFixed(10)) === 0.3   // 结果为True\nparseFloat((11.0-11.8).toFixed(10)) === -0.8   // 结果为True</code></pre><p><br></p><p>&nbsp;方法提炼 代码如下:<br></p><pre><code>// 通过isEqual工具方法判断数值是否相等\nfunction isEqual(number1, number2, digits){\n digits = digits == undefined? 10: digits; // 默认精度为10\n return number1.toFixed(digits) === number2.toFixed(digits);\n}\nisEqual(1.0-0.7, 0.3);  // return true\n// 原生扩展方式，更喜欢面向对象的风格\nNumber.prototype.isEqual = function(number, digits){\n digits = digits == undefined? 10: digits; // 默认精度为10\n return this.toFixed(digits) === number.toFixed(digits);\n}\n(1.0-0.7).isEqual(0.3); // return true</code></pre><p><br></p>"}}
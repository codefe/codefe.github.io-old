{"sta":1,"data":{"subTitle":"混合书写(Mixins)","content":"<h3>混入</h3><p>混入和函数定义方法一致，但是应用却大相径庭。</p><p>例如，下面有定义的<code>border-radius(n)</code>方法，其却作为一个<em>mixin</em>（如，作为状态调用，而非表达式）调用。</p><p>当<code>border-radius()</code>选择器中调用时候，属性会被扩展并复制在选择器中。</p><pre><code>border-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius(5px)</code></pre><p>编译成：</p><pre><code>form input[type=button] {\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n}</code></pre><p>使用混入书写，你可以完全忽略括号，提供梦幻般私有属性的支持。</p><pre><code>border-radius(n)\n  -webkit-border-radius n\n  -moz-border-radius n\n  border-radius n\n\nform input[type=button]\n  border-radius 5px</code></pre><p>注意到我们混合书写中的<code>border-radius</code>当作了属性，而不是一个递归函数调用。</p><p>更进一步，我们可以利用<code>arguments</code>这个局部变量，传递可以包含多值的表达式。</p><pre><code>border-radius()\n  -webkit-border-radius arguments\n  -moz-border-radius arguments\n  border-radius arguments</code></pre><p>现在，我们可以像这样子传值：<code>border-radius 1px 2px / 3px 4px</code>!</p><p>另外一个很赞的应用是特定的私有前缀支持——例如IE浏览器的透明度：</p><pre><code>support-for-ie ?= true\n\nopacity(n)\n  opacity n\n  if support-for-ie\n    filter unquote('progid:DXImageTransform.Microsoft.Alpha(Opacity=' + round(n * 100) + ')')\n\n#logo\n  &amp;:hover\n    opacity 0.5</code></pre><p>渲染为：</p><pre><code>#logo:hover {\n  opacity: 0.5;\n  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);\n}</code></pre><h3>父级引用</h3><p>混合书写可以利用父级引用字符<code>&amp;</code>, 继承父业而不是自己筑巢。</p><p>例如，我们要用<code>stripe(even, odd)</code>创建一个条纹表格。<code>even</code>和<code>odd</code>均提供了默认颜色值，每行也指定了<code>background-color</code>属性。我们可以在<code>tr</code>嵌套中使用<code>&amp;</code>来引用<code>tr</code>，以提供<code>even</code>颜色。</p><pre><code>stripe(even = #fff, odd = #eee)\n tr\n   background-color odd\n   &amp;.even\n   &amp;:nth-child(even)\n       background-color even</code></pre><p>然后，利用混合书写，如下：</p><pre><code>table\n  stripe()\n  td\n    padding 4px 10px\n\ntable#users\n  stripe(#303030, #494848)\n  td\n    color white</code></pre><p>另外，<code>stripe()</code>的定义无需父引用：</p><pre><code>stripe(even = #fff, odd = #eee)\n  tr\n    background-color odd\n  tr.even\n  tr:nth-child(even)\n    background-color even</code></pre><p>如果你愿意，你可以把<code>stripe()</code>当作属性调用。</p><pre><code>stripe #fff #000</code></pre><h3>混合书写中的混合书写</h3><p>自然，混合书写可以利用其它混合书写，建立在它们自己的属性和选择器上。</p><p>例如，下面我们创建内联<code>comma-list()</code>（通过<code>inline-list()</code>）以及逗号分隔的无序列表。</p><pre><code>inline-list()\n  li\n    display inline\n\ncomma-list()\n  inline-list()\n  li\n    &amp;:after\n      content ', '\n    &amp;:last-child:after\n      content ''\n\nul\n  comma-list()</code></pre><p>渲染：</p><p><!--StartFragment--><!--EndFragment--></p><pre><code>ul li:after {\n  content: \", \";\n}\nul li:last-child:after {\n  content: \"\";\n}\nul li {\n  display: inline;\n}</code></pre>"}}
{"sta":1,"data":{"subTitle":"WebGL交互式立方体","content":"<div>在本章中，我们将举一个例子来演示如何绘制3D魔方，可以用鼠标控制旋转。</div><div><h3>示例&nbsp;-&nbsp;绘制一个互动立方体</h3><div>下面的程序展示了如何使用鼠标控制旋转的立方体&nbsp;-</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"570\" height = \"570\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*============= Creating a canvas ======================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl');\n\n         /*========== Defining and storing the geometry ==========*/\n\n         var vertices = [\n            -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,\n            -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,\n            -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,\n            1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1,\n            -1,-1,-1, -1,-1, 1, 1,-1, 1, 1,-1,-1,\n            -1, 1,-1, -1, 1, 1, 1, 1, 1, 1, 1,-1, \n         ];\n\n         var colors = [\n            5,3,7, 5,3,7, 5,3,7, 5,3,7,\n            1,1,3, 1,1,3, 1,1,3, 1,1,3,\n            0,0,1, 0,0,1, 0,0,1, 0,0,1,\n            1,0,0, 1,0,0, 1,0,0, 1,0,0,\n            1,1,0, 1,1,0, 1,1,0, 1,1,0,\n            0,1,0, 0,1,0, 0,1,0, 0,1,0 \n         ];\n\n         var indices = [\n            0,1,2, 0,2,3, 4,5,6, 4,6,7,\n            8,9,10, 8,10,11, 12,13,14, 12,14,15,\n            16,17,18, 16,18,19, 20,21,22, 20,22,23 \n         ];\n\n         // Create and store data into vertex buffer\n         var vertex_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Create and store data into color buffer\n         var color_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n\n         // Create and store data into index buffer\n         var index_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n                                              \n         /*=================== SHADERS =================== */\n\n         var vertCode = 'attribute vec3 position;'+\n            'uniform mat4 Pmatrix;'+\n            'uniform mat4 Vmatrix;'+\n            'uniform mat4 Mmatrix;'+\n            'attribute vec3 color;'+//the color of the point\n            'varying vec3 vColor;'+\n            'void main(void) { '+//pre-built function\n               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+\n               'vColor = color;'+\n            '}';\n\n         var fragCode = 'precision mediump float;'+\n            'varying vec3 vColor;'+\n            'void main(void) {'+\n               'gl_FragColor = vec4(vColor, 1.);'+\n            '}';\n\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n         gl.shaderSource(vertShader, vertCode);\n         gl.compileShader(vertShader);\n\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n         gl.shaderSource(fragShader, fragCode);\n         gl.compileShader(fragShader);\n\t\t\t\n         var shaderprogram = gl.createProgram();\n         gl.attachShader(shaderprogram, vertShader);\n         gl.attachShader(shaderprogram, fragShader);\n         gl.linkProgram(shaderprogram);\n         \n         /*======== Associating attributes to vertex shader =====*/\n         var _Pmatrix = gl.getUniformLocation(shaderprogram, \"Pmatrix\");\n         var _Vmatrix = gl.getUniformLocation(shaderprogram, \"Vmatrix\");\n         var _Mmatrix = gl.getUniformLocation(shaderprogram, \"Mmatrix\");\n\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         var _position = gl.getAttribLocation(shaderprogram, \"position\");\n         gl.vertexAttribPointer(_position, 3, gl.FLOAT, false,0,0);\n         gl.enableVertexAttribArray(_position);\n\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n         var _color = gl.getAttribLocation(shaderprogram, \"color\");\n         gl.vertexAttribPointer(_color, 3, gl.FLOAT, false,0,0) ;\n         gl.enableVertexAttribArray(_color);\n         gl.useProgram(shaderprogram);\n\n         /*==================== MATRIX ====================== */\n         \n         function get_projection(angle, a, zMin, zMax) {\n            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5\n            return [\n               0.5/ang, 0 , 0, 0,\n               0, 0.5*a/ang, 0, 0,\n               0, 0, -(zMax+zMin)/(zMax-zMin), -1,\n               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 \n\t\t\t   ];\n         }\n         \n         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);\n         var mo_matrix = [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];\n         var view_matrix = [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];\n\n         view_matrix[14] = view_matrix[14]-6;\n\n         /*================= Mouse events ======================*/\n\n         var AMORTIZATION = 0.95;\n         var drag = false;\n         var old_x, old_y;\n         var dX = 0, dY = 0;\n\t\t\t\n         var mouseDown = function(e) {\n            drag = true;\n            old_x = e.pageX, old_y = e.pageY;\n            e.preventDefault();\n            return false;\n         };\n         \n         var mouseUp = function(e){\n            drag = false;\n         };\n         \n         var mouseMove = function(e) {\n            if (!drag) return false;\n            dX = (e.pageX-old_x)*2*Math.PI/canvas.width,\n            dY = (e.pageY-old_y)*2*Math.PI/canvas.height;\n            THETA+= dX;\n            PHI+=dY;\n            old_x = e.pageX, old_y = e.pageY;\n            e.preventDefault();\n         };\n         \n         canvas.addEventListener(\"mousedown\", mouseDown, false);\n         canvas.addEventListener(\"mouseup\", mouseUp, false);\n         canvas.addEventListener(\"mouseout\", mouseUp, false);\n         canvas.addEventListener(\"mousemove\", mouseMove, false);\n\n         /*=========================rotation================*/\n\n         function rotateX(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv1 = m[1], mv5 = m[5], mv9 = m[9];\n\t\t\t\t\n            m[1] = m[1]*c-m[2]*s;\n            m[5] = m[5]*c-m[6]*s;\n            m[9] = m[9]*c-m[10]*s;\n\n            m[2] = m[2]*c+mv1*s;\n            m[6] = m[6]*c+mv5*s;\n            m[10] = m[10]*c+mv9*s;\n         }\n\n         function rotateY(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv0 = m[0], mv4 = m[4], mv8 = m[8];\n\t\t\t\t\n            m[0] = c*m[0]+s*m[2];\n            m[4] = c*m[4]+s*m[6];\n            m[8] = c*m[8]+s*m[10];\n\n            m[2] = c*m[2]-s*mv0;\n            m[6] = c*m[6]-s*mv4;\n            m[10] = c*m[10]-s*mv8;\n         }\n\n         /*=================== Drawing =================== */\n\n         var THETA = 0,\n         PHI = 0;\n         var time_old = 0;\n\t\t\t\t\n         var animate = function(time) {\n            var dt = time-time_old;\n\t\t\t\t\t\n            if (!drag) {\n               dX *= AMORTIZATION, dY*=AMORTIZATION;\n               THETA+=dX, PHI+=dY;\n            }\n               \n            //set model matrix to I4\n\t\t\t\t\t\n            mo_matrix[0] = 1, mo_matrix[1] = 0, mo_matrix[2] = 0,\n            mo_matrix[3] = 0,\n\t\t\t\t\t\n            mo_matrix[4] = 0, mo_matrix[5] = 1, mo_matrix[6] = 0,\n            mo_matrix[7] = 0,\n\t\t\t\t\t\n            mo_matrix[8] = 0, mo_matrix[9] = 0, mo_matrix[10] = 1,\n            mo_matrix[11] = 0,\n\t\t\t\t\t\n            mo_matrix[12] = 0, mo_matrix[13] = 0, mo_matrix[14] = 0,\n            mo_matrix[15] = 1;\n\n            rotateY(mo_matrix, THETA);\n            rotateX(mo_matrix, PHI);\n\t\t\t\t\t\n            time_old = time; \n            gl.enable(gl.DEPTH_TEST);\n\t\t\t\t\t\n            // gl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\n            gl.clearColor(0.5, 0.5, 0.5, 0.9);\n            gl.clearDepth(1.0);\n            gl.viewport(0.0, 0.0, canvas.width, canvas.height);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n            gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);\n            gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);\n            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n\t\t\t\t\t\n            window.requestAnimationFrame(animate);\n         }\n\t\t\t\n         animate(0);\n\t\t\t\t\n      &lt;/script&gt;\n\t\t\n   &lt;/body&gt;\n&lt;/html&gt; \n</pre><div>这将产生以下结果(运行上面的代码，可用鼠标点或拖动中间的立方体，看看其效果) -<br><img src=\"/app/data/html5/webgl/img/1-1512202212254T.png\" alt=\"\"></div></div>"}}
{"sta":1,"data":{"subTitle":"WebGL几何体","content":"<div><div><span>所有原语(或对象模型)应该有明确定义的几何细节。这些细节可以包括顶点，指数，颜色，纹理等。在WebGL中几何详细信息存储在JavaScript数组。</span></div></div><div><div>图形对象由其中在GPU上运行的着色器程序来创建。几何信息传递到使用缓冲区对象着色器程序。</div><h3>定义所需的几何体</h3><div>使用顶点所绘的2D或3D模型被称为网格。在网格的每个面被称为多边形和多边形是由3个或更多的顶点组成。</div><div>要绘制模型在WebGL中渲染，必须定义使用&nbsp;JavaScript&nbsp;数组的顶点和索引。举例来说，如果我们想创建一个三角形的位于坐标{(5,5)，(5,5)，(-5，-5)}如图所示，图中，那么可以创建一个数组的顶点-</div><pre>var vertices = [\n   0.5,0.5,  //Vertex 1\n   0.5,-0.5, //Vertex 2\n  -0.5,-0.5, //Vertex 3\n]; \n</pre><div><img src=\"/app/data/html5/webgl/img/1-15122020561Y47.jpg\" alt=\"\"><br>同样，可以创建一个数组的索引。指数为上述三角形索引将是[0，1，2]，可以定义为&nbsp;-</div><pre>var indices = [ 0,1,2 ]\n</pre><div>为了更好地理解索引，考虑更多复杂的模型，如正方形。我们可以代表一个正方形为一组的两个三角形。如果(0,3,1)和(3,1,2)是用两个三角形，我们打算绘制一个正方形，那么索引将被定义为&nbsp;-</div><pre>var indices = [0,3,1,3,1,2];\n</pre><p><img src=\"/app/data/html5/webgl/img/1-151220205644G6.jpg\" alt=\"\"><br>注意&nbsp;−</p><div>对于绘图图元，WebGL 提供了以下两种方法&nbsp;-</div><ul><li><p>drawArrays()&nbsp;−&nbsp;当使用这种方法，我们通过原语使用JavaScript数组的顶点。</p></li><li><p>drawElements()&nbsp;−&nbsp;当使用这种方法，我们通过这两个顶点和原语使用JavaScript数组的索引。</p></li></ul><h3>缓冲区对象</h3><div>缓冲对象是由WebGL的提供了一个机制，用于指示分配到系统中的存储器区域。在这些缓冲区对象，可以存储要绘制模型的数据，对应的顶点，索引，颜色等。</div><div>使用这些缓冲区对象，可以通过它的属性变量中的一个传递多个数据的着色器程序(顶点着色器)。由于这些缓冲对象驻留在GPU存储器，它们可以被直接呈现，这反过来又提高了性能。</div><div>为了处理几何形状，有两种类型的缓冲区的对象。他们是-</div><ul><li><p>顶点缓冲区对象&nbsp;(VBO)&nbsp;−&nbsp;它保持所述图形模型，要被渲染的每个顶点的数据。我们使用顶点缓冲对象中的WebGL存储和处理关于顶点诸如顶点坐标，法线，色彩，纹理坐标数据。</p></li><li><p>索引缓冲区对象(IBO)&nbsp;−&nbsp;它保持所述图形模型的索引(索引数据)，这是要被渲染的。</p><div>限定所需的几何形状和它们存储在JavaScript数组，需要将这些阵列传递给对象缓冲器，数据将被传递到着色器程序。下面的步骤是在缓冲器要遵循数据存储。</div></li><li><div>创建一个空的缓冲区。</div></li><li><div>绑定相应的数组对象为空缓冲区。</div></li><li><div>传递数据(顶点/索引)使用类型数组的一个缓冲区。</div></li><li><div>取消绑定缓存(可选)。</div></li></ul><p>注−</p><div>WebGL提供了一种特殊类型数组称为类型数组来传输数据元素，如索引顶点和纹理。这些类型的数组存储大量数据并处理它们在本地二进制格式，这将产生更好的性能。使用WebGL类型数组是Int8Array，Uint8Array，Int16Array，Uint16Array，Int32Array，UInt32Array，Float32Array和Float64Array。</div><ul><li><div>通常，用于存储顶点数据，我们用Float32Array;&nbsp;要存储索引数据，我们使用Uint16Array。</div></li><li><div>可以创建类型数组就像使用new关键字JavaScript数组。</div></li></ul><div>现在，让我们来了解步骤存储在缓冲区的数据&nbsp;-</div><h3>创建缓冲区</h3><div>要创建一个空的缓冲区对象，WebGL提供了一个名为createBuffer()的方法。该方法如果创建成功，返回一个新创建的缓冲区对象; 否则返回失败的情况下一个 null 值。</div><div>WebGL操作为状态机。一旦缓冲器被创建，任何后续缓冲操作将在当前缓冲器被执行，直到我们解除绑定它。使用下面的代码来创建缓冲区&nbsp;-</div><pre>var vertex_buffer = <b>gl</b>.createBuffer();\n</pre><p>注&nbsp;− gl&nbsp;是参考变量的当前的 WebGL 的上下文。</p><h3>绑定缓冲</h3><div>创建一个空的缓冲区对象后，需要一个合适的数组缓冲区(目标)绑定到它。&nbsp;WebGL提供)用于此目的称为bindBuffer() 方法。</div><h3>语法</h3><p>bindBuffer()方法的语法如下&nbsp;−</p><pre>void <b>bindBuffer</b> (enum target, Object buffer)\n</pre><div>这个方法有两个参数，它们将在下面讨论。</div><p>target&nbsp;−&nbsp;第一变量是一个枚举值，表示我们要绑定到空缓冲器的缓冲的类型。有两个预定义枚举值作为该参数选项。他们是-</p><ul><li><p>ARRAY_BUFFER&nbsp;&nbsp;表示顶点的数据。</p></li><li><p>ELEMENT_ARRAY_BUFFER&nbsp;表示索引数据。</p></li></ul><p>Object buffer&nbsp;−&nbsp;第二个是参考变量，在上一步中创建的缓冲区对象。参考变量可以是一个索引缓存对象或顶点缓冲对象。</p><h3>示例</h3><div>下面的代码片段展示了如何使用 bindBuffer()方法。</div><pre>//vertex buffer\nvar vertex_buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\n//Index buffer\nvar Index_Buffer = gl.createBuffer();\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n</pre><h3>数据传递到缓冲区</h3><div>下一步骤是将数据(顶点/索引)传送给缓冲器。截至目前数据是一个数组的形式在传递到缓冲区之前，我们需要把它包在WebGL的一个类型数组。&nbsp;WebGL提供用于此目的 的 bufferData()方法。</div><h3>语法</h3><div>bufferData()方法的语法如下&nbsp;-</div><pre>void <b>bufferData</b> (enum target, Object data, enum usage)\n</pre><div>这个方法接受三个参数，它们将在下面讨论&nbsp;-</div><p>target&nbsp;−&nbsp;第一个参数是一个枚举值，表示我们使用了数组中缓冲的类型。它们可以是ARRAY_BUFFER或ELEMENT_ARRAY_BUFFER。</p><p>Object data&nbsp;−&nbsp;第二个参数是包含数据写入到缓冲对象的对象的值。在这里，我们使用类型数组来传递数据。</p><p>Usage&nbsp;−&nbsp;该方法的第三个参数是一个枚举变量，来指定如何使用缓冲区对象的数据(存储的数据)来绘制形状。有三种选择此参数如下表所示。</p><ul><li><p>gl.STATIC_DRAW&nbsp;−&nbsp;数据将指定一次，多次使用。</p></li><li><p>gl.STREAM_DRAW&nbsp;−&nbsp;数据将指定一次，使用几次。</p></li><li><p>gl.DYNAMIC_DRAW&nbsp;−&nbsp;数据将被重复指定和多次使用。</p></li></ul><h3>示例</h3><div>下面的代码片段展示了如何使用bufferData()方法。假设顶点和指数分别保持在顶点和索引数据的数组。</div><ins data-ad-client=\"ca-pub-1090193214637198\" data-ad-slot=\"6494738921\"></ins><pre>//vertex buffer\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n//Index buffer\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n</pre><h3>取消绑定缓冲区</h3><div>建议解除绑定缓存使用后。它可以通过使一个零值代替缓冲对象来完成，如下所示。</div><pre>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n</pre><div>WebGL提供以下方法来执行缓冲区操作&nbsp;-</div><table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><th>S.No.</th><th><div>方法及说明</div></th></tr><tr><td>1</td><td><p>void&nbsp;<b>bindBuffer</b>&nbsp;(enum&nbsp;<i>target</i>, Object&nbsp;<i>buffer</i>)</p><p><i>target</i>&nbsp;− ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p></td></tr><tr><td>2</td><td><p>void&nbsp;<b>bufferData</b>(enum&nbsp;<i>target</i>, long&nbsp;<i>size</i>, enum&nbsp;<i>usage</i>)</p><p><i>target</i>&nbsp;− ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p><p><i>usage</i>&nbsp;− STATIC_DRAW, STREAM_DRAW, DYNAMIC_DRAW</p></td></tr><tr><td>3</td><td><p>void&nbsp;<b>bufferData</b>&nbsp;(enum&nbsp;<i>target</i>, Object&nbsp;<i>data</i>, enum&nbsp;<i>usage</i>)</p><p><i>target</i>&nbsp;and&nbsp;<i>usage</i>&nbsp;− Same as for&nbsp;<b>bufferData</b>&nbsp;above</p></td></tr><tr><td>4</td><td><p>void&nbsp;<b>bufferSubData</b>(enum&nbsp;<i>target</i>, long&nbsp;<i>offset</i>, Object&nbsp;<i>data</i>)</p><p><i>target</i>&nbsp;− ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p></td></tr><tr><td>5</td><td>Object&nbsp;<b>createBuffer()</b></td></tr><tr><td>6</td><td>void&nbsp;<b>deleteBuffer</b>(Object&nbsp;<i>buffer</i>)</td></tr><tr><td>7</td><td><p>any&nbsp;<b>getBufferParameter</b>(enum&nbsp;<i>target</i>, enum&nbsp;<i>pname</i>)</p><p><i>target</i>&nbsp;− ARRAY_BUFFER, ELEMENT_ ARRAY_BUFFER</p><p><i>pname</i>&nbsp;− BUFFER_SIZE, BUFFER_USAGE</p></td></tr><tr><td>8</td><td>bool&nbsp;<b>isBuffer</b>(Object&nbsp;<i>buffer</i>)</td></tr></tbody></table></div>"}}
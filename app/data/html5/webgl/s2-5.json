{"sta":1,"data":{"subTitle":"WebGL Context上下文","content":"<div><div>要编写一个WebGL的应用程序，第一步是让WebGL渲染上下文 - Context 对象。这个对象与 WebGL 绘制缓冲区进行交互，可以调用所有WebGL的方法。执行以下操作来获取WebGL的上下文-</div></div><div><ul><li><div>创建HTML5&nbsp;canvas</div></li><li><div>获取画布&nbsp;canvas 的 ID</div></li><li><div>获取WebGL</div></li></ul><h3>创建HTML5&nbsp;canvas元素</h3><div>我们知道，建立一个HTML5&nbsp;canvas 元素&nbsp;-</div><ul><li><div>在HTML5主体内写入canvas语句声明</div></li><li><div>给定&nbsp;canvas&nbsp;一个ID</div></li><li>使用高度和宽度(height &amp; width)属性(可选)更改画布尺寸</li></ul><div>一个例子在这里应该更清楚。</div><h3>示例</h3><div>下面的例子说明如何创建一个 canvas 元素。创建了一个边框使用 CSS 可视性画布的尺寸(500×500)。复制并粘贴到下面的代码到&nbsp;my_canvas.html&nbsp;文件。</div><pre>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n   &lt;head&gt;\n      &lt;title&gt;Canvas示例  -www.yiibai.com&lt;/title\n      &lt;style&gt;\n         #mycanvas{border:1px solid blue;}\n      &lt;/style&gt;\n   &lt;/head&gt;\n\t\n   &lt;body&gt;\n      &lt;canvas id = \"mycanvas\" width = \"300\" height = \"300\"&gt;&lt;/canvas&gt;\n   &lt;/body&gt;\n\t\n&lt;/html&gt;\n</pre><div>这将产生以下结果&nbsp;-<br><img alt=\"\" src=\"/app/data/html5/webgl/img/1-151220205136404.png\"></div><div>获取Canvas的ID</div><div>Canvas&nbsp;ID是通过调用DOM(文档对象模型)的getElementById()方法获得的。这个方法接受一个字符串值作为参数，所以我们传递了当前&nbsp;Canvas&nbsp;的名字。</div><div>例如，如果&nbsp;canvas&nbsp;名称是my_canvas，则canvas&nbsp;ID被得到&nbsp;-&nbsp;如图如下</div><pre>var canvas = document.getElementById('my_Canvas');</pre><h3>获取WebGL的绘图上下文</h3><div>为了得到 WebGLRenderingContext 对象(或图形的WebGL上下文对象或只在WebGL的情况下)，调用当前 HTMLCanvasElement 的getContext()方法。getContext()的语法如下&nbsp;-</div><pre>canvas.getContext(contextType, contextAttributes);\n</pre><div>通过&nbsp;WebGL字符串或experimental-webgl&nbsp;作为&nbsp;contentType。contextAttributes参数是可选的。&nbsp;(虽然在进行这一步，请确保您的浏览器实现了WebGL 1.0版本(OpenGL&nbsp;ES&nbsp;2.0))。</div><div>下面的代码片段展示了如何获取WebGL的渲染上下文。在这里，gl是参考变量所获得的上下文对象。</div><pre>var canvas = document.getElementById('my_Canvas');\nvar gl = canvas.getContext('experimental-webgl');\n</pre><h3>WebGLContextAttributes</h3><div>参数 WebGLContextAttributes 不是强制性的。此参数提供接受布尔值，如下面列出各种选项&nbsp;-</div><table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><td><b>Alpha</b></td><td><div>如果它的值是&nbsp;true，它提供了一个alpha缓冲区到画布上。默认情况下，它的值是&nbsp;true</div></td></tr><tr><td><b>depth</b></td><td><div>如果它的值是true，会得到一个绘图的缓冲区，其中包含至少16位的深度缓冲。默认情况下，它的值是true</div></td></tr><tr><td><b>stencil</b></td><td><div>如果它的值是true，会得到一个绘图的缓冲区，其中包含至少8位的模板缓存。默认情况下，它的值是false</div></td></tr><tr><td><b>antialias</b></td><td><div>如果它的值是true，会得到一个绘图缓冲区，执行抗锯齿。默认情况下，它的值是true</div></td></tr><tr><td><b>premultipliedAlpha</b></td><td><div>如果它的值是true，会得到一个绘图缓冲区，其中包含的颜色与预乘alpha。默认情况下它的值是true</div></td></tr><tr><td><b>preserveDrawingBuffer</b></td><td><div>如果它的值是true，缓冲区将不会被清零，直到被清除或由作者改写将保留它们的值。默认情况下，它的值是false</div></td></tr></tbody></table><div>下面的代码片段展示了如何创建一个WebGL的上下文模板缓存，这将不执行抗锯齿。</div><ins data-ad-client=\"ca-pub-1090193214637198\" data-ad-slot=\"6494738921\"></ins><pre>var canvas = document.getElementById('canvas1');\nvar context = canvas.getContext('webgl', { antialias: false, stencil: true });\n</pre><div>在创建&nbsp;WebGLRenderingContext&nbsp;的时候，一个绘图缓冲器被创建。上下文对象管理OpenGL&nbsp;状态，并呈现到图形缓冲区。</div><h3>WebGLRenderingContext</h3><div>它是 WebGL 的主要接口。它表示 WebGL 绘图上下文。该接口包含了所有用于在绘图缓冲执行各种任务的方法。此接口的属性给出在下表中。</div><table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><th>S.No.</th><th><div>属性和说明</div></th></tr><tr><td>1</td><td><p><b>Canvas</b></p><div>这是一个对创建此&nbsp;canvas&nbsp;元素的上下文</div></td></tr><tr><td>2</td><td><p><b>drawingBufferWidth</b></p><div>此属性表示绘图缓冲器的实际宽度。它可以不同于 HTMLCanvasElement 的宽度属性。</div></td></tr><tr><td>3</td><td><p><b>drawingBufferHeight</b></p><div>此属性表示绘图缓冲器的实际高度。它可以不同于 HTMLCanvasElement 的高度属性。</div></td></tr></tbody></table></div>"}}
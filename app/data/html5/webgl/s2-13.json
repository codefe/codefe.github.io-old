{"sta":1,"data":{"subTitle":"WebGL绘制四边形","content":"<div><div>在前面的章节中，我们讨论了WebGL提供不同的绘图模式。我们也可以使用索引来绘制使用这些模式中的一个原语。要在WebGL中绘制模型，我们要选择这些原语其中的一种，并绘制所需的网格(即使用一个或多个原语形成一个模型)。</div></div><div><div>在本章中，我们将举一个例子来演示如何使用 WebGL 来绘制一个四边形。</div><h3>绘制四边形的步骤</h3><div>下面是创建一个WebGL应用程序来绘制一个四边形的步骤。</div><div><strong>第1步&nbsp;-&nbsp;准备Canvas和获取WebGL渲染上下文</strong></div><div>在这一步中，我们得到了 WebGL 的渲染上下文对象 usinggetContext()。</div><div><strong>第2步&nbsp;-&nbsp;定义几何并将其存储在缓冲区对象</strong></div><div>正方形可以用两个三角形来绘制。在这个例子中，我们提供的顶点两个三角形(具有一个公共边缘)和索引。</div><pre>var vertices = [\n   -0.5,0.5,0.0,\n   -0.5,-0.5,0.0,\n   0.5,-0.5,0.0,\n   0.5,0.5,0.0 \n];\n\nindices = [3,2,1,3,1,0]; \n</pre><div><strong>第3步&nbsp;-&nbsp;创建和编译着色器程序</strong></div><div>在这一步中，你需要编写的顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并程序。</div><ul><li><div>顶点着色器-&nbsp;在程序的顶点着色器，我们定义向量属性来存储三维坐标，并指定为&nbsp;gl_position。</div></li></ul><pre>var vertCode =\n   'attribute vec3 coordinates;' +\n   'void main(void) {' +\n      ' gl_Position = vec4(coordinates, 1.0);' +\n   '}';\n</pre><ul><li><div>片段着色器-&nbsp;在片段着色器，我们只分配碎片颜色到&nbsp;gl_FragColor&nbsp;变量。</div></li></ul><pre>var fragCode = 'void main(void) {' +' gl_FragColor = vec4(0.5, 0.3, 0.0, 7.5);' +'}';\n</pre><div><strong>第4步&nbsp;-&nbsp;关联着色器程序到缓冲区对象</strong></div><div>在这一步，我们关联着色器程序到缓冲器的对象。</div><div>第5步&nbsp;-&nbsp;绘制所需的对象</div><div>由于我们正在绘制两个三角形，形成四边形，使用索引，我们将使用的方法 drawElements()。对于这个方法，我们必须传递索引的数量。&nbsp;indices.length 值为索引的数量。</div><pre>gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);\n</pre><h3>示例&nbsp;-&nbsp;画一个四边形</h3><div>下面的程序展示了如何创建一个 WebGL 的应用程序来绘制一个四边形。</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*============ Creating a canvas =================*/\n      \n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl');\n      \n         /*========== Defining and storing the geometry =========*/\n\n         var vertices = [\n            -0.5,0.5,0.0,\n            -0.5,-0.5,0.0,\n            0.5,-0.5,0.0,\n            0.5,0.5,0.0 \n         ];\n          \n         indices = [3,2,1,3,1,0];\n      \n         // Create an empty buffer object to store vertex buffer\n         var vertex_buffer = gl.createBuffer();\n\n         // Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n \n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Unbind the buffer\n         gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n         // Create an empty buffer object to store Index buffer\n         var Index_Buffer = gl.createBuffer();\n\n         // Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);\n\n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n\n         // Unbind the buffer\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n         /*====================== Shaders =======================*/\n \n         // Vertex shader source code\n         var vertCode =\n            'attribute vec3 coordinates;' +\n            'void main(void) {' +\n               ' gl_Position = vec4(coordinates, 1.0);' +\n            '}';\n         \n         // Create a vertex shader object\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n\n         // Attach vertex shader source code\n         gl.shaderSource(vertShader, vertCode);\n\n         // Compile the vertex shader\n         gl.compileShader(vertShader);\n\n         // Fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n         \n         // Create fragment shader object \n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n         // Attach fragment shader source code\n         gl.shaderSource(fragShader, fragCode);\n\n         // Compile the fragmentt shader\n         gl.compileShader(fragShader);\n\n         // Create a shader program object to\n         // store the combined shader program\n         var shaderProgram = gl.createProgram();\n\n         // Attach a vertex shader\n         gl.attachShader(shaderProgram, vertShader);\n\n         // Attach a fragment shader\n         gl.attachShader(shaderProgram, fragShader);\n\n         // Link both the programs\n         gl.linkProgram(shaderProgram);\n\n         // Use the combined shader program object\n         gl.useProgram(shaderProgram);\n\n         /* ======= Associating shaders to buffer objects =======*/\n\n         // Bind vertex buffer object\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\n         // Bind index buffer object\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer); \n \n         // Get the attribute location\n         var coord = gl.getAttribLocation(shaderProgram, \"coordinates\");\n\n         // Yiibai an attribute to the currently bound VBO\n         gl.vertexAttribYiibaier(coord, 3, gl.FLOAT, false, 0, 0);\n \n         // Enable the attribute\n         gl.enableVertexAttribArray(coord);\n\n         /*============= Drawing the Quad ================*/\n\n         // Clear the canvas\n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n\n         // Enable the depth test\n         gl.enable(gl.DEPTH_TEST);\n\n         // Clear the color buffer bit\n         gl.clear(gl.COLOR_BUFFER_BIT);\n\n         // Set the view port\n         gl.viewport(0,0,canvas.width,canvas.height);\n\n         // Draw the triangle\n         gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);\n\n      &lt;/script&gt;\n   \n   &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果&nbsp;-<br><img src=\"/app/data/html5/webgl/img/1-151220214JVM.png\" alt=\"\"></div></div>"}}
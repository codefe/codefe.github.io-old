{"sta":1,"data":{"subTitle":"WebGL绘制点","content":"<div>我们在前面已经有介绍如何一步一步绘制原请过程的讨论。我们已在五个步骤解释这一过程。接下来需要在每次绘制一个新的形状时重复这些步骤。本章介绍如何绘制点WebGL的三维坐标。在进一步学习前，让我们来重新审视在五个步骤。</div><div><h3>所需的步骤</h3><div>下面的步骤是创建一个WebGL的应用程序用来绘制点。</div><div><strong>第1步&nbsp;-&nbsp;准备Canvas和获取WebGL的渲染上下文</strong></div><div><div>在此步骤中，我们使用getContext()方法得到WebGL的渲染上下文对象。</div></div><div><strong>第2步&nbsp;-&nbsp;定义几何并将其存储在缓冲区对象</strong></div><div>因为我们绘制三个点，这里定义了三个顶点三维坐标，并将它们存储在缓冲区中。</div><pre>var vertices = [\n   -0.5,0.5,0.0,\n   0.0,0.5,0.0,\n   -0.25,0.25,0.0, \n];\n</pre><div><strong>第3步&nbsp;-&nbsp;创建和编译着色器程序</strong></div><div>在这一步中，需要写顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并程序。</div><ul><li><div>顶点着色器-&nbsp;在给出的示例中的顶点着色器，我们定义了一个向量属性来存储三维坐标，并将其分配给&nbsp;gl_position&nbsp;变量。</div></li><li><div>gl_pointsize 是用于一个大小分配给该点的变量。我们指定点大小为10。</div></li></ul><pre>var vertCode = 'attribute vec3 coordinates;' +\n\n   'void main(void) {' +\n      ' gl_Position = vec4(coordinates, 1.0);' +\n      'gl_TutorialsSize = 10.0;'+\n   '}';\n</pre><ul><li><div>片段着色器&nbsp;-&nbsp;在片段着色器，只分配碎片颜色给 gl_FragColor 变量</div></li></ul><pre>var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';\n</pre><div><strong>第4步&nbsp;-&nbsp;关联着色器程序到缓冲区对象</strong></div><div>在这一步，我们关联着色器程序到缓冲器的对象。</div><div><strong>第5步&nbsp;-&nbsp;绘制所需的对象</strong></div><div>我们使用 drawArrays()方法来绘制点。因为要画的点的数量为三个，所以计数值为3。</div><pre>gl.drawArrays(gl.POINTS, 0, 3)\n</pre><h3>示例&nbsp;-&nbsp;使用WebGL绘制三点</h3><div>下面是完整的WebGL程序绘制三个点代码-</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*================Creating a canvas=================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl'); \n      \n         /*==========Defining and storing the geometry=======*/\n\n         var vertices = [\n            -0.5,0.5,0.0,\n            0.0,0.5,0.0,\n            -0.25,0.25,0.0, \n         ];\n         \n         // Create an empty buffer object to store the vertex buffer\n         var vertex_buffer = gl.createBuffer();\n\n         //Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n      \n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Unbind the buffer\n         gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\n         /*=========================Shaders========================*/\n      \n         // vertex shader source code\n         var vertCode =\n            'attribute vec3 coordinates;' +\n\t\t\t\t\n            'void main(void) {' +\n               ' gl_Position = vec4(coordinates, 1.0);' +\n               'gl_TutorialsSize = 10.0;'+\n            '}';\n         \n         // Create a vertex shader object\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n\n         // Attach vertex shader source code\n         gl.shaderSource(vertShader, vertCode);\n\n         // Compile the vertex shader\n         gl.compileShader(vertShader);\n\n         // fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n         \n         // Create fragment shader object\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n         // Attach fragment shader source code\n         gl.shaderSource(fragShader, fragCode);\n      \n         // Compile the fragmentt shader\n         gl.compileShader(fragShader);\n\n         // Create a shader program object to store\n         // the combined shader program\n         var shaderProgram = gl.createProgram();\n\n         // Attach a vertex shader\n         gl.attachShader(shaderProgram, vertShader); \n \n         // Attach a fragment shader\n         gl.attachShader(shaderProgram, fragShader);\n\n         // Link both programs\n         gl.linkProgram(shaderProgram);\n\n         // Use the combined shader program object\n         gl.useProgram(shaderProgram);\n\n         /*======== Associating shaders to buffer objects ========*/\n\n         // Bind vertex buffer object\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\n         // Get the attribute location\n         var coord = gl.getAttribLocation(shaderProgram, \"coordinates\");\n\n         // Tutorials an attribute to the currently bound VBO\n         gl.vertexAttribTutorialser(coord, 3, gl.FLOAT, false, 0, 0);\n\n         // Enable the attribute\n         gl.enableVertexAttribArray(coord);\n\n         /*============= Drawing the primitive ===============*/\n\n         // Clear the canvas\n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n\n         // Enable the depth test\n         gl.enable(gl.DEPTH_TEST);\n \n         // Clear the color buffer bit\n         gl.clear(gl.COLOR_BUFFER_BIT);\n\n         // Set the view port\n         gl.viewport(0,0,canvas.width,canvas.height);\n\n         // Draw the triangle\n         gl.drawArrays(gl.POINTS, 0, 3);\n\n      &lt;/script&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果&nbsp;-</div><div></div></div><p><img src=\"/app/data/html5/webgl/img/1-151220211414194.png\" style=\"max-width:100%;\"></p><div></div>"}}
{"sta":1,"data":{"subTitle":"WebGL立方体旋转","content":"<div>在本章中，我们将举一个例子来演示如何使用WebGL绘制一个旋转3D立方体。</div><div><h3>示例&nbsp;-&nbsp;绘制一个旋转的3D立方体</h3><div>以下程序显示了如何绘制一个旋转的3D立方体&nbsp;-</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"570\" height = \"570\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*============= Creating a canvas =================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl');\n         \n         /*============ Defining and storing the geometry =========*/\n\n         var vertices = [\n            -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,\n            -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,\n            -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,\n            1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1,\n            -1,-1,-1, -1,-1, 1, 1,-1, 1, 1,-1,-1,\n            -1, 1,-1, -1, 1, 1, 1, 1, 1, 1, 1,-1, \n         ];\n\n         var colors = [\n            5,3,7, 5,3,7, 5,3,7, 5,3,7,\n            1,1,3, 1,1,3, 1,1,3, 1,1,3,\n            0,0,1, 0,0,1, 0,0,1, 0,0,1,\n            1,0,0, 1,0,0, 1,0,0, 1,0,0,\n            1,1,0, 1,1,0, 1,1,0, 1,1,0,\n            0,1,0, 0,1,0, 0,1,0, 0,1,0\n         ];\n\n         var indices = [\n            0,1,2, 0,2,3, 4,5,6, 4,6,7,\n            8,9,10, 8,10,11, 12,13,14, 12,14,15,\n            16,17,18, 16,18,19, 20,21,22, 20,22,23 \n         ];\n\n         // Create and store data into vertex buffer\n         var vertex_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Create and store data into color buffer\n         var color_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n\n         // Create and store data into index buffer\n         var index_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n                                              \n         /*=================== Shaders =========================*/\n         \n         var vertCode = 'attribute vec3 position;'+\n            'uniform mat4 Pmatrix;'+\n            'uniform mat4 Vmatrix;'+\n            'uniform mat4 Mmatrix;'+\n            'attribute vec3 color;'+//the color of the point\n            'varying vec3 vColor;'+\n\t\t\t\n            'void main(void) { '+//pre-built function\n               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+\n               'vColor = color;'+\n            '}';\n\n         var fragCode = 'precision mediump float;'+\n            'varying vec3 vColor;'+\n            'void main(void) {'+\n               'gl_FragColor = vec4(vColor, 1.);'+\n            '}';\n         \n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n         gl.shaderSource(vertShader, vertCode);\n         gl.compileShader(vertShader);\n\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n         gl.shaderSource(fragShader, fragCode);\n         gl.compileShader(fragShader);\n\n         var shaderProgram = gl.createProgram();\n         gl.attachShader(shaderProgram, vertShader);\n         gl.attachShader(shaderProgram, fragShader);\n         gl.linkProgram(shaderProgram);\n\n         /* ====== Associating attributes to vertex shader =====*/\n         var Pmatrix = gl.getUniformLocation(shaderProgram, \"Pmatrix\");\n         var Vmatrix = gl.getUniformLocation(shaderProgram, \"Vmatrix\");\n         var Mmatrix = gl.getUniformLocation(shaderProgram, \"Mmatrix\");\n\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         var position = gl.getAttribLocation(shaderProgram, \"position\");\n         gl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0) ;\n         \n         // Position\n         gl.enableVertexAttribArray(position);\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n         var color = gl.getAttribLocation(shaderProgram, \"color\");\n         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ;\n         \n         // Color\n         gl.enableVertexAttribArray(color);\n         gl.useProgram(shaderProgram);\n\n         /*==================== MATRIX =====================*/\n\n         function get_projection(angle, a, zMin, zMax) {\n            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5\n            return [\n               0.5/ang, 0 , 0, 0,\n               0, 0.5*a/ang, 0, 0,\n               0, 0, -(zMax+zMin)/(zMax-zMin), -1,\n               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 \n            ];\n         }\n\t\t\t\n         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);\n\n         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n\n         // translating z\n         view_matrix[14] = view_matrix[14]-6;//zoom\n\n         /*==================== Rotation ====================*/\n\n         function rotateZ(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv0 = m[0], mv4 = m[4], mv8 = m[8];\n\t\t\t\t\n            m[0] = c*m[0]-s*m[1];\n            m[4] = c*m[4]-s*m[5];\n            m[8] = c*m[8]-s*m[9];\n\n            m[1]=c*m[1]+s*mv0;\n            m[5]=c*m[5]+s*mv4;\n            m[9]=c*m[9]+s*mv8;\n         }\n\n         function rotateX(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv1 = m[1], mv5 = m[5], mv9 = m[9];\n\t\t\t\t\n            m[1] = m[1]*c-m[2]*s;\n            m[5] = m[5]*c-m[6]*s;\n            m[9] = m[9]*c-m[10]*s;\n\n            m[2] = m[2]*c+mv1*s;\n            m[6] = m[6]*c+mv5*s;\n            m[10] = m[10]*c+mv9*s;\n         }\n\n         function rotateY(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv0 = m[0], mv4 = m[4], mv8 = m[8];\n\t\t\t\t\n            m[0] = c*m[0]+s*m[2];\n            m[4] = c*m[4]+s*m[6];\n            m[8] = c*m[8]+s*m[10];\n\n            m[2] = c*m[2]-s*mv0;\n            m[6] = c*m[6]-s*mv4;\n            m[10] = c*m[10]-s*mv8;\n         }\n\n         /*================= Drawing ===========================*/\n         var time_old = 0;\n\t\t\t\n         var animate = function(time) {\n\n            var dt = time-time_old;\n            rotateZ(mov_matrix, dt*0.005);//time\n            rotateY(mov_matrix, dt*0.002);\n            rotateX(mov_matrix, dt*0.003);\n            time_old = time;\n\n            gl.enable(gl.DEPTH_TEST);\n            gl.depthFunc(gl.LEQUAL);\n            gl.clearColor(0.5, 0.5, 0.5, 0.9);\n            gl.clearDepth(1.0);\n\n            gl.viewport(0.0, 0.0, canvas.width, canvas.height);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);\n            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);\n            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n\t\t\t\t\n            window.requestAnimationFrame(animate);\n         }\n         animate(0);\n\t\t\t\n      &lt;/script&gt;\n\n   &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果(这里只能放静态图片，具体旋转效果可自己运行代码观察)&nbsp;&nbsp;-<br><img src=\"/app/data/html5/webgl/img/1-151220221035211.png\" alt=\"\"></div></div>"}}
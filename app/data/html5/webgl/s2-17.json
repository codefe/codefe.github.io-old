{"sta":1,"data":{"subTitle":"WebGL旋转","content":"<div>在本章中，我们将举一个例子来演示如何使用WebGL的来旋转三角形。</div><div><h3>示例&nbsp;-&nbsp;旋转三角形</h3><div>下面的程序展示了如何使用 WebGL 来旋转三角形。</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n         \n      &lt;script&gt;\n\t\t\n         /*=================Creating a canvas=========================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl');\n            \n         /*===========Defining and storing the geometry==============*/\n            \n         var vertices = [ -1,-1,-1, 1,-1,-1, 1, 1,-1 ];\n         var colors = [ 1,1,1, 1,1,1, 1,1,1 ];\n         var indices = [ 0,1,2 ];\n\n         //Create and store data into vertex buffer\n         var vertex_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         //Create and store data into color buffer\n         var color_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n\n         //Create and store data into index buffer\n         var index_buffer = gl.createBuffer ();\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n\n         /*==========================Shaders=========================*/\n\n         var vertCode = 'attribute vec3 position;'+\n            'uniform mat4 Pmatrix;'+\n            'uniform mat4 Vmatrix;'+\n            'uniform mat4 Mmatrix;'+\n            'attribute vec3 color;'+//the color of the point\n            'varying vec3 vColor;'+\n\t\t\t\t\n            'void main(void) { '+//pre-built function\n               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+\n               'vColor = color;'+\n            '}';\n\n         var fragCode = 'precision mediump float;'+\n            'varying vec3 vColor;'+\n            'void main(void) {'+\n               'gl_FragColor = vec4(vColor, 1.);'+\n            '}';\n\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n         gl.shaderSource(vertShader, vertCode);\n         gl.compileShader(vertShader);\n\t\t\t\t\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n         gl.shaderSource(fragShader, fragCode);\n         gl.compileShader(fragShader);\n\n         var shaderProgram = gl.createProgram();\n         gl.attachShader(shaderProgram, vertShader);\n         gl.attachShader(shaderProgram, fragShader);\n         gl.linkProgram(shaderProgram);\n\n         /*===========associating attributes to vertex shader ============*/\n    \n         var Pmatrix = gl.getUniformLocation(shaderProgram, \"Pmatrix\");\n         var Vmatrix = gl.getUniformLocation(shaderProgram, \"Vmatrix\");\n         var Mmatrix = gl.getUniformLocation(shaderProgram, \"Mmatrix\");\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\t\t\t\t\n         var position = gl.getAttribLocation(shaderProgram, \"position\");\n         gl.vertexAttribTutorialser(position, 3, gl.FLOAT, false,0,0) ; //position\n         gl.enableVertexAttribArray(position);\n         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);\n\t\t\t\t\n         var color = gl.getAttribLocation(shaderProgram, \"color\");\n         gl.vertexAttribTutorialser(color, 3, gl.FLOAT, false,0,0) ; //color\n         gl.enableVertexAttribArray(color);\n         gl.useProgram(shaderProgram);\n\n         /*========================= MATRIX ========================= */\n            \n         function get_projection(angle, a, zMin, zMax) {\n            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5\n            return [\n               0.5/ang, 0 , 0, 0,\n               0, 0.5*a/ang, 0, 0,\n               0, 0, -(zMax+zMin)/(zMax-zMin), -1,\n               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0\n            ];\n         }\n\t\t\t\n         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);\n         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n         \n         //translating z\n         view_matrix[14] = view_matrix[14]-6; //zoom\n\n         /*=======================rotation========================*/\n         function rotateZ(m, angle) {\n            var c = Math.cos(angle);\n            var s = Math.sin(angle);\n            var mv0 = m[0], mv4 = m[4], mv8 = m[8]; \n\t\t\t\t\n            m[0] = c*m[0]-s*m[1];\n            m[4] = c*m[4]-s*m[5];\n            m[8] = c*m[8]-s*m[9];\n            m[1] = c*m[1]+s*mv0;\n            m[5] = c*m[5]+s*mv4;\n            m[9] = c*m[9]+s*mv8;\n         }\n\n         /*=================Drawing===========================*/\n\n         var time_old = 0;\n         var animate = function(time) {\n            var dt = time-time_old;\n            rotateZ(mov_matrix, dt*0.002);\n            time_old = time;\n\t\t\t\t\n            gl.enable(gl.DEPTH_TEST);\n            gl.depthFunc(gl.LEQUAL);\n            gl.clearColor(0.5, 0.5, 0.5, 0.9);\n            gl.clearDepth(1.0);\n            gl.viewport(0.0, 0.0, canvas.width, canvas.height);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\t\t\t\t\n            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);\n            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);\n            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);\n\t\t\t\t\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n            window.requestAnimationFrame(animate);\n         }\n\t\t\t\n         animate(0);\n\t\t\t\n      &lt;/script&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果(这里只能放静态图片，具体旋转效果可自己运行代码观察) -</div><div><img src=\"/app/data/html5/webgl/img/1-151220220ZO40.png\" alt=\"\"></div></div>"}}
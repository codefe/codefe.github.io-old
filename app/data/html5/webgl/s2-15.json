{"sta":1,"data":{"subTitle":"WebGL平移","content":"<div><div>到目前为止，我们讨论了如何绘制各种形状和使用 WebGL 应用它们的颜色。在本章中，我们将举个例子来说明如何平移一个三角形。</div></div><h3>平移</h3><div>平移是由&nbsp;WebGL&nbsp;提供的仿射变换之一。使用平移，我们可以继续在XYZ平面三角形(任何对象)。假设我们有一个三角形[A，B，C]，我们想的三角形移动到的位置上是5个单位向着X轴正和3个单位向正Y轴。然后将新的顶点。将[A&nbsp;+5，B&nbsp;+3，C&nbsp;+0]。这意味着，平移三角形，我们需要添加平移距离，比方说，tx,&nbsp;ty,&nbsp;tz&nbsp;到每个顶点。</div><div>既然是每个顶点的操作，我们可以在顶点着色器程序实现它。</div><div>在顶点着色器，伴随着属性，坐标(持有顶点位置)，我们定义了容纳平移距离(X，Y，Z)变量。之来我们这个统一的变量添加到变量中的坐标和分配结果到gl_Position&nbsp;变量。</div><div>注&nbsp;-&nbsp;由于顶点着色器将在每个顶点上运行，三角形的所有顶点将被平移。</div><h3>转换一个三角形步骤</h3><p>下面的步骤是必需的，以建立一个WebGL的应用来绘制三角形，然后将其平移到一个新的位置。</p><div><strong>第1步&nbsp;-&nbsp;准备Canvas和获取WebGL渲染上下文</strong></div><p>在此步骤中，我们使用getContext()得到&nbsp;WebGL&nbsp;渲染上下文对象。</p><p><strong>第2步&nbsp;-&nbsp;定义几何并将其存储在缓冲区对象</strong><br></p><div>因为我们画一个三角形，我们必须通过三角形的三个顶点，并将它们存储在缓冲区中。</div><pre>var vertices = [ -0.5,0.5,0.0, -0.5,-0.5,0.0, 0.5,-0.5,0.0, ];\n</pre><div><strong>第3步&nbsp;-&nbsp;创建和编译着色器程序</strong></div><div>在这一步中，你需要编写的顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并程序。</div><ul><li><div>顶点着色器&nbsp;-&nbsp;在程序的顶点着色器，我们定义一个向量属性来存储三维坐标。除了它，我们定义存储平移的距离一个统一变量，最后，我们添加这两个值并将其分配给&nbsp;gl_position&nbsp;它保存顶点的最终位置。</div></li></ul><pre>var vertCode =\n   'attribute vec4 coordinates;' +\n   'uniform vec4 translation;'+\n   'void main(void) {' +\n      ' gl_Position = coordinates + translation;' +\n   '}';\n</pre><ul><li><div>片段着色器&nbsp;-&nbsp;在片段着色器，我们只分配片段颜色变 gl_FragColor。</div></li></ul><pre>var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';\n</pre><div><strong>第4步&nbsp;-&nbsp;关联着色器程序到缓冲区对象</strong></div><p>在这一步，我们关联着色器程序到缓冲器的对象。</p><p><strong>第5步&nbsp;-&nbsp;绘制所需的对象</strong><br></p><div>由于我们使用索引绘制三角形，我们将使用&nbsp;drawArrays() 方法。该方法，我们必须通过被认为是对顶点/元件的数目。因为我们画一个三角形，我们将通过传递&nbsp;3&nbsp;作为一个参数。</div><pre>gl.drawArrays(gl.TRIANGLES, 0, 3);\n</pre><h3>示例&nbsp;-&nbsp;平移三角形</h3><div>下面的例子演示了如何在&nbsp;XYZ&nbsp;平面上平移三角形。</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n         \n      &lt;script&gt;\n         \n         /*=================Creating a canvas=========================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl'); \n \n         /*===========Defining and storing the geometry==============*/\n         var vertices = [\n            -0.5,0.5,0.0, \t\n            -0.5,-0.5,0.0, \t\n            0.5,-0.5,0.0,   \n         ];\n            \n         //Create an empty buffer object and store vertex data            \n         var vertex_buffer = gl.createBuffer(); \n\t\t\t\n         //Create a new buffer\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);   \n\t\t\t\n         //bind it to the current buffer\t\t\t\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); \n\t\t\t\n         // Pass the buffer data\n         gl.bindBuffer(gl.ARRAY_BUFFER, null);  \n            \n         /*========================Shaders============================*/\n            \n         //vertex shader source code \n         var vertCode =\n            'attribute vec4 coordinates;' + \n            'uniform vec4 translation;'+\n            'void main(void) {' +\n               '  gl_Position = coordinates + translation;' +\n            '}';\n            \n         //Create a vertex shader program object and compile it              \n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n         gl.shaderSource(vertShader, vertCode);\n         gl.compileShader(vertShader);\n            \n   \n         //fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               '   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n               \n         //Create a fragment shader program object and compile it            \n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n         gl.shaderSource(fragShader, fragCode);\n         gl.compileShader(fragShader);\n            \n         //Create and use combiened shader program\n         var shaderProgram = gl.createProgram();\n         gl.attachShader(shaderProgram, vertShader);\n         gl.attachShader(shaderProgram, fragShader);\n         gl.linkProgram(shaderProgram);\n   \n         gl.useProgram(shaderProgram); \n   \n   \n         /* ===========Associating shaders to buffer objects============*/\n      \n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);    \n         var coordinatesVar = gl.getAttribLocation(shaderProgram, \"coordinates\");\n         gl.vertexAttribYiibaier(coordinatesVar, 3, gl.FLOAT, false, 0, 0);   \n         gl.enableVertexAttribArray(coordinatesVar); \n   \n         /* ==========translation======================================*/\n         var Tx = 0.5, Ty = 0.5, Tz = 0.0;\n         var translation = gl.getUniformLocation(shaderProgram, 'translation');\n         gl.uniform4f(translation, Tx, Ty, Tz, 0.0);\n \n         /*=================Drawing the riangle and transforming it========================*/ \n            \n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n         gl.enable(gl.DEPTH_TEST);\n   \n         gl.clear(gl.COLOR_BUFFER_BIT);\n         gl.viewport(0,0,canvas.width,canvas.height);\n         gl.drawArrays(gl.TRIANGLES, 0, 3);\n               \n      &lt;/script&gt;\n \n    &lt;/body&gt;\n &lt;/html&gt;\n</pre><p>这将产生以下结果&nbsp;-</p><p><img src=\"/app/data/html5/webgl/img/1-151220215544547.png\" alt=\"\"></p>"}}
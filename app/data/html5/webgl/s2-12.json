{"sta":1,"data":{"subTitle":"WebGL绘图的模式","content":"<div>在前面的章节，我们讨论了如何使用WebGL画一个三角形。除了三角形，WebGL支持其他各种绘图模式。本章介绍了通过WebGL支持的绘图模式。</div><div><h3>mode参数</h3><div>让我们看看这些方法的语法&nbsp;-&nbsp;drawElements()，并绘制Arrays()。</div><pre>void drawElements(enum mode, long count, enum type, long offset);\n\nvoid drawArrays(enum mode, int first, long count);\n</pre><div>这两种方法接受一个参数:&nbsp;mode。使用此参数，程序员可以选择WebGL的绘图模式。</div><div>通过 WebGL 的所提供的绘图模式列在下表中。</div><table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><th>S.No.</th><th>模式</th><th>描述</th></tr><tr><td>1</td><td>gl.POINTS</td><td><div>要绘制一系列的点</div></td></tr><tr><td>2</td><td>gl.LINES</td><td><div>要绘制了一系列未连接直线段(单独行)</div></td></tr><tr><td>3</td><td>gl.LINE_STRIP</td><td><div>要绘制一系列连接的线段</div></td></tr><tr><td>4</td><td>gl.LINE_LOOP</td><td><div>要绘制一系列连接的线段。它还连接的第一和最后的顶点，以形成一个环</div></td></tr><tr><td>5</td><td>gl.TRIANGLES</td><td><div>要绘制一系列独立的三角形</div></td></tr><tr><td>6</td><td>gl.TRIANGLE_STRIP</td><td><div>要绘制了一系列相连的三角形中条状</div></td></tr><tr><td>7</td><td>gl.TRIANGLE_FAN</td><td><div>要绘制了一系列相连的三角形共享的第一个顶点的扇形</div></td></tr></tbody></table><h3>示例&nbsp;-&nbsp;绘制三个平行线</h3><div>下面的示例演示了如何使用 gl.LINES 绘制三条平行线。</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*======= Creating a canvas =========*/\n\n         var canvas = document.getElementById('my_Canvas');\n         var gl = canvas.getContext('experimental-webgl');\n\n\n         /*======= Defining and storing the geometry ======*/\n\n         var vertices = [\n            -0.7,-0.1,0,\n            -0.3,0.6,0,\n            -0.3,-0.3,0,\n            0.2,0.6,0,\n            0.3,-0.3,0,\n            0.7,0.6,0 \n         ]\n          \n         // Create an empty buffer object\n         var vertex_buffer = gl.createBuffer();\n\n         // Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n      \n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Unbind the buffer\n         gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n         /*=================== Shaders ====================*/\n\n         // Vertex shader source code\n         var vertCode =\n            'attribute vec3 coordinates;' +\n            'void main(void) {' +\n               ' gl_Position = vec4(coordinates, 1.0);' +\n            '}';\n\n         // Create a vertex shader object\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n\n         // Attach vertex shader source code\n         gl.shaderSource(vertShader, vertCode);\n\n         // Compile the vertex shader\n         gl.compileShader(vertShader);\n\n         // Fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n\n         // Create fragment shader object\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n         // Attach fragment shader source code\n         gl.shaderSource(fragShader, fragCode);\n\n         // Compile the fragmentt shader\n         gl.compileShader(fragShader);\n\n         // Create a shader program object to store\n         // the combined shader program\n         var shaderProgram = gl.createProgram();\n\n         // Attach a vertex shader\n         gl.attachShader(shaderProgram, vertShader);\n\n         // Attach a fragment shader\n         gl.attachShader(shaderProgram, fragShader);\n\n         // Link both the programs\n         gl.linkProgram(shaderProgram);\n\n         // Use the combined shader program object\n         gl.useProgram(shaderProgram);\n\n         /*======= Associating shaders to buffer objects ======*/\n\n         // Bind vertex buffer object\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\n         // Get the attribute location\n         var coord = gl.getAttribLocation(shaderProgram, \"coordinates\");\n\n         // Tutorials an attribute to the currently bound VBO\n         gl.vertexAttribTutorialser(coord, 3, gl.FLOAT, false, 0, 0);\n\n         // Enable the attribute\n         gl.enableVertexAttribArray(coord);\n\n         /*============ Drawing the triangle =============*/\n\n         // Clear the canvas\n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n\n         // Enable the depth test\n         gl.enable(gl.DEPTH_TEST);\n\n         // Clear the color and depth buffer\n         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n         // Set the view port\n         gl.viewport(0,0,canvas.width,canvas.height);\n\n         // Draw the triangle\n         gl.drawArrays(gl.LINES, 0, 6);\n\n         // POINTS, LINE_STRIP, LINE_LOOP, LINES,\n         // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES\n      \n      &lt;/script&gt;\n\t\t\n   &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果&nbsp;-<br><img src=\"/app/data/html5/webgl/img/1-151220214355c1.png\" alt=\"\"></div><h3>绘图模式</h3><div>另外，在上述程序中，如果替换 drawArrays()改为描画模式中的一个的模式时，它每次将产生不同的输出。</div><table border=\"1\" cellpadding=\"2\" cellspacing=\"0\"><tbody><tr><th><div>绘图模式</div></th><th>输出</th></tr><tr><td>LINE_STRIP</td><td>Line Strip</td></tr><tr><td>LINE_LOOP</td><td>Line Loop</td></tr><tr><td>TRIANGLE_STRIP</td><td>Triangle Strip</td></tr><tr><td>TRIANGLE_FAN</td><td>Triangle Fan</td></tr><tr><td>TRIANGLES</td><td>Triangles</td></tr></tbody></table></div>"}}
{"sta":1,"data":{"subTitle":"WebGL绘制三角形","content":"<div><div>在前面的章节，我们讨论了如何使用WebGL绘制三个点。并使用示例应用程序来演示如何画一个三角形。在这两个例子中，我们绘制仅仅使用顶点图元。</div></div><div><div>绘制更复杂的形状/网格，我们通过一个几何图形索引也一样，如：顶点，向着色器。在本章中，我们将学习如何使用索引来画一个三角形。</div><h3>绘制三角形所需的步骤</h3><div>下面的步骤是用来创建一个WebGL的应用程序以绘制一个三角形。</div><div><strong>第1步&nbsp;-&nbsp;准备Canvas和获取WebGL的渲染上下文</strong></div><div>在此步骤中，我们使用的getContext()得到WebGL的渲染上下文对象。</div><div><strong>第2步&nbsp;-&nbsp;定义几何并将其存储在缓冲区对象</strong></div><div>由于我们使用的索引画一个三角形，我们必须通过三角形的三个顶点，包括索引，并把它们存储在缓冲器。</div><pre>var vertices = [\n   -0.5,0.5,0.0,\n   -0.5,-0.5,0.0,\n   0.5,-0.5,0.0, \n];\n\t\nindices = [0,1,2]; \n</pre><div><strong>第3步&nbsp;-&nbsp;创建和编译着色器程序</strong></div><div>在这一步中，需要写顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并程序。</div><ul><li><div>顶点着色器&nbsp;-&nbsp;在程序的顶点着色器，我们定义向量属性来存储三维坐标，并指定为&nbsp;gl_position。</div></li></ul><pre>var vertCode =\n   'attribute vec3 coordinates;' +\n\t\n   'void main(void) {' +\n      ' gl_Position = vec4(coordinates, 1.0);' +\n   '}';\n</pre><ul><li><div>片段着色器&nbsp;-&nbsp;在片段着色器，我们只分配碎片颜色到gl_FragColor变量。</div></li></ul><pre>var fragCode = 'void main(void) {' +\n   ' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +\n'}';\n</pre><div><strong>第4步&nbsp;-&nbsp;关联着色器程序到缓冲区对象</strong></div><div>在这一步，我们关联缓冲器对象和着色器程序。</div><div><strong>第5步&nbsp;-&nbsp;绘制所需的对象</strong></div><div>由于我们使用的索引画一个三角形，我们将使用drawElements()。对于这个方法，必须传递索引的数量。indices.length的值表示索引的数量。</div><pre>gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);\n</pre><h3>示例&nbsp;-&nbsp;绘制一个三角形</h3><div>以下程序代码显示了如何使用的索引来在WebGL中绘制的一个三角形&nbsp;-</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n\n      &lt;script&gt;\n\n         /*============== Creating a canvas ====================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl');\n      \n         /*======== Defining and storing the geometry ===========*/\n\n         var vertices = [\n            -0.5,0.5,0.0,\n            -0.5,-0.5,0.0,\n            0.5,-0.5,0.0, \n         ];\n         \n         indices = [0,1,2];\n         \n         // Create an empty buffer object to store vertex buffer\n         var vertex_buffer = gl.createBuffer();\n\n         // Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n         \n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n         // Unbind the buffer\n         gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n         // Create an empty buffer object to store Index buffer\n         var Index_Buffer = gl.createBuffer();\n\n         // Bind appropriate array buffer to it\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);\n\n         // Pass the vertex data to the buffer\n         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n         \n         // Unbind the buffer\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n         /*================ Shaders ====================*/\n         \n         // Vertex shader source code\n         var vertCode =\n            'attribute vec3 coordinates;' +\n\t\t\t\t\n            'void main(void) {' +\n               ' gl_Position = vec4(coordinates, 1.0);' +\n            '}';\n            \n         // Create a vertex shader object\n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n\n         // Attach vertex shader source code\n         gl.shaderSource(vertShader, vertCode);\n\n         // Compile the vertex shader\n         gl.compileShader(vertShader);\n\n         //fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n            \n         // Create fragment shader object\n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n         // Attach fragment shader source code\n         gl.shaderSource(fragShader, fragCode); \n         \n         // Compile the fragmentt shader\n         gl.compileShader(fragShader);\n\n         // Create a shader program object to store\n         // the combined shader program\n         var shaderProgram = gl.createProgram();\n\n         // Attach a vertex shader\n         gl.attachShader(shaderProgram, vertShader);\n\n         // Attach a fragment shader\n         gl.attachShader(shaderProgram, fragShader);\n\n         // Link both the programs\n         gl.linkProgram(shaderProgram);\n\n         // Use the combined shader program object\n         gl.useProgram(shaderProgram);\n\n         /*======= Associating shaders to buffer objects =======*/\n\n         // Bind vertex buffer object\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);\n\n         // Bind index buffer object\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);\n         \n         // Get the attribute location\n         var coord = gl.getAttribLocation(shaderProgram, \"coordinates\");\n\n         // Tutorials an attribute to the currently bound VBO\n         gl.vertexAttribTutorialser(coord, 3, gl.FLOAT, false, 0, 0); \n         \n         // Enable the attribute\n         gl.enableVertexAttribArray(coord);\n\n         /*=========Drawing the triangle===========*/\n\n         // Clear the canvas\n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n\n         // Enable the depth test\n         gl.enable(gl.DEPTH_TEST);\n\n         // Clear the color buffer bit\n         gl.clear(gl.COLOR_BUFFER_BIT);\n\n         // Set the view port\n         gl.viewport(0,0,canvas.width,canvas.height);\n\n         // Draw the triangle\n         gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);\n\n      &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre><div>这将产生以下结果&nbsp;-<br><img src=\"/app/data/html5/webgl/img/1-15122021392M60.png\" alt=\"\"><br></div></div>"}}
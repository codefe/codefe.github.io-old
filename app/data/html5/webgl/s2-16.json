{"sta":1,"data":{"subTitle":"WebGL缩放","content":"<div><div>在本章中，我们将举个例子来说明如何使用WebGL修改一个三角形的缩放比例。</div></div><div><h3>缩放</h3><div>缩放只不过是增加或减少的对象的大小。例如，如果一个三角形的大小的顶点是[a,b,c]，然后三角形的顶点[2a，2b，2c]将扩大两倍大小。因此，缩放一个三角形，要乘以每个顶点的缩放比例。还可以扩展一个特定的顶点。</div><div>缩放一个三角形，在该程序的顶点着色器，我们产生均匀的矩阵并用该矩阵乘以坐标值。之后，我们传递 x，y 的比例因子为 4×4 的对角矩阵和z坐标中的对角位置(最近对角位置1)。</div><h3>所需的步骤</h3><div>下面的步骤来创建一个 WebGL 应用程序来扩展三角形。</div><div><strong>第1步&nbsp;-&nbsp;准备Canvas和获取 WebGL 渲染上下文</strong></div><div>在此步骤中，我们使用 getContext()得到&nbsp;WebGL&nbsp;渲染上下文对象。</div><div><strong>第2步&nbsp;-&nbsp;定义几何并将其存储在缓冲区对象</strong></div><div>由于我们画一个三角形，我们必须通过三角形的三个顶点，并将它们存储在缓冲区中。</div><pre>var vertices = [ -0.5,0.5,0.0, -0.5,-0.5,0.0, 0.5,-0.5,0.0, ];\n</pre><div><strong>第3步&nbsp;-&nbsp;创建和编译着色器程序</strong></div><div>在这一步中，你需要编写的顶点着色器和片段着色器程序，编译它们，并通过连接这两个程序将创建一个合并程序。</div><ul><li><div>顶点着色器 -&nbsp;在程序的顶点着色器，我们定义一个向量属性来存储三维坐标。除了它，我们定义了一个统一的矩阵存储缩放系数，最后，我们乘这两个值并将其分配给gl_position&nbsp;保存顶点的最终位置。</div></li></ul><pre>var vertCode =\n   'attribute vec4 coordinates;' +\n   'uniform mat4 u_xformMatrix;' +\n   'void main(void) {' +\n      ' gl_Position = u_xformMatrix * coordinates;' +\n   '}';\n</pre><ul><li><div>片段着色器-&nbsp;在片段着色器，我们只分配碎片颜色到&nbsp;gl_FragColor&nbsp;变量。</div></li></ul><pre>var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';\n</pre><div>片段着色器-&nbsp;在片段着色器，我们只分配碎片颜色到&nbsp;gl_FragColor&nbsp;变量。</div><div>在这一步，我们关联着色器程序到缓冲器的对象。</div><div><strong>第5步&nbsp;-&nbsp;绘制所需的对象</strong></div><div><div>由于我们使用索引绘制三角形，这里使用&nbsp;drawArrays()方法。该方法必须通过被视为对顶点/元件的数目。由于我们画一个三角形，将传递3作为一个参数。</div></div><pre>gl.drawArrays(gl.TRIANGLES, 0, 3);\n</pre><h3>示例&nbsp;-&nbsp;缩放三角形</h3><div>下面的例子演示了如何扩展三角形&nbsp;-</div><pre>&lt;!doctype html&gt;\n&lt;html&gt;\n   &lt;body&gt;\n      &lt;canvas width = \"300\" height = \"300\" id = \"my_Canvas\"&gt;&lt;/canvas&gt;\n         \n      &lt;script&gt;\n         \n         /*=================Creating a canvas=========================*/\n         var canvas = document.getElementById('my_Canvas');\n         gl = canvas.getContext('experimental-webgl'); \n \n         /*===========Defining and storing the geometry==============*/\n         var vertices =  [\n            -0.5,0.5,0.0, \t\n            -0.5,-0.5,0.0, \t\n            0.5,-0.5,0.0,   \n         ];\n            \n         //Create an empty buffer object and store vertex data\n            \n         var vertex_buffer = gl.createBuffer();                                                     \n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);                                                \n         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);           \n         gl.bindBuffer(gl.ARRAY_BUFFER, null);  \n            \n         /*========================Shaders============================*/\n           \n         //Vertex shader source code\n         var vertCode =\n            'attribute vec4 coordinates;' + \n            'uniform mat4 u_xformMatrix;' +\n            'void main(void) {' +\n               '  gl_Position = u_xformMatrix * coordinates;' +\n            '}';\n               \n         //Create a vertex shader program object and compile it                \n         var vertShader = gl.createShader(gl.VERTEX_SHADER);\n         gl.shaderSource(vertShader, vertCode);\n         gl.compileShader(vertShader);\n            \n         //fragment shader source code\n         var fragCode =\n            'void main(void) {' +\n               '   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\n            '}';\n            \n         //Create a fragment shader program object and compile it \n         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n         gl.shaderSource(fragShader, fragCode);\n         gl.compileShader(fragShader);\n  \n         //Create and use combiened shader program\n         var shaderProgram = gl.createProgram();\n         gl.attachShader(shaderProgram, vertShader);\n         gl.attachShader(shaderProgram, fragShader);\n         gl.linkProgram(shaderProgram);\n   \n         gl.useProgram(shaderProgram); \n          \n         /*===================scaling==========================*/\n          \n         var Sx = 1.0, Sy = 1.5, Sz = 1.0;\n         var xformMatrix = new Float32Array([\n            Sx,   0.0,  0.0,  0.0,\n            0.0,  Sy,   0.0,  0.0,\n            0.0,  0.0,  Sz,   0.0,\n            0.0,  0.0,  0.0,  1.0  \n         ]);\n   \n         var u_xformMatrix = gl.getUniformLocation(shaderProgram, 'u_xformMatrix');\n         gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);\n      \n         /* ===========Associating shaders to buffer objects============*/\n         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);   \n   \n         var coordinatesVar = gl.getAttribLocation(shaderProgram, \"coordinates\"); \n         gl.vertexAttribPointer(coordinatesVar, 3, gl.FLOAT, false, 0, 0);  \n         gl.enableVertexAttribArray(coordinatesVar);\n   \n         /*=================Drawing the Quad========================*/ \n         gl.clearColor(0.5, 0.5, 0.5, 0.9);\n         gl.enable(gl.DEPTH_TEST);\n   \n         gl.clear(gl.COLOR_BUFFER_BIT);\n         gl.viewport(0,0,canvas.width,canvas.height);\n         gl.drawArrays(gl.TRIANGLES, 0, 3);\n\t\t\t\n      &lt;/script&gt;      \n      \n   &lt;/body&gt;\n&lt;/html&gt;      \n</pre><div>这将产生以下结果&nbsp;-<br><img src=\"/app/data/html5/webgl/img/1-151220220H1555.png\" alt=\"\"></div></div>"}}